diff --git a/Algoritmos/C++/ComputacionalGeometry/ClosestPointsGivenAMetric.cpp b/Algoritmos/C++/ComputacionalGeometry/ClosestPointsGivenAMetric.cpp
deleted file mode 100644
index 337451c..0000000
--- a/Algoritmos/C++/ComputacionalGeometry/ClosestPointsGivenAMetric.cpp
+++ /dev/null
@@ -1,97 +0,0 @@
-using namespace std;
-#include <bits/stdc++.h>
-#define all(A) A.begin(),A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define ll long long
-#define ull unsigned long long
-
-
-struct pt {
-    ll x, y, id;
-};
-
-struct cmp_x {
-    bool operator()(const pt &a, const pt &b) const {
-        return a.x < b.x || (a.x == b.x && a.y < b.y);
-    }
-};
-
-struct cmp_y {
-    bool operator()(const pt &a, const pt &b) const {
-        return a.y < b.y;
-    }
-};
-
-istream &operator>>(istream &is, pt &p) {
-    return is >> p.x >> p.y;
-}
-
-
-ostream &operator<<(ostream &os, const pt &p) {
-    return os << "(" << p.x << "," << p.y << ")";
-}
-
-int n;
-vector<pt> t;
-
-vector<pt> a;
-
-double mindist;
-pair<ll, ll> best_pair;
-
-void upd_ans(const pt &a, const pt &b) {
-    double dist = sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
-    if (dist < mindist) {
-        mindist = dist;
-        best_pair = {a.id, b.id};
-    }
-}
-
-
-void rec(int l, int r) {
-    if (r - l <= 3) {
-        for (int i = l; i < r; ++i) {
-            for (int j = i + 1; j < r; ++j) {
-                upd_ans(a[i], a[j]);
-            }
-        }
-        sort(a.begin() + l, a.begin() + r, cmp_y());
-        return;
-    }
-
-    int m = (l + r) >> 1;
-    int midx = a[m].x;
-    rec(l, m);
-    rec(m, r);
-
-    merge(a.begin() + l, a.begin() + m, a.begin() + m, a.begin() + r, t.begin(), cmp_y());
-    copy(t.begin(), t.begin() + r - l, a.begin() + l);
-    int tsz = 0;
-    for (int i = l; i < r; ++i) {
-        if (abs(a[i].x - midx) < mindist) {
-            for (int j = tsz - 1; j >= 0 && a[i].y - t[j].y < mindist; --j)
-                upd_ans(a[i], t[j]);
-            t[tsz++] = a[i];
-        }
-    }
-}
-
-void solve() {
-    cin >> n;
-    a.assign(n, {});
-    fori(i, 0, n) {
-        cin >> a[i];
-        a[i].id = i;
-    }
-    t.resize(n);
-    sort(a.begin(), a.end(), cmp_x());
-    mindist = 1E20;
-    rec(0, n);
-    //ids of the closest points
-    ll x1 = best_pair.first;
-    ll x2 = best_pair.second;
-    cout << "Closest Distance: " << fixed << setprecision(6) << mindist << ln;
-}
-
-
diff --git a/Algoritmos/C++/ComputacionalGeometry/Convex Hull.cpp b/Algoritmos/C++/ComputacionalGeometry/Convex Hull.cpp
deleted file mode 100644
index 3aa0cbf..0000000
--- a/Algoritmos/C++/ComputacionalGeometry/Convex Hull.cpp	
+++ /dev/null
@@ -1,44 +0,0 @@
-struct Point {
-    double x, y;
-    
-    bool operator==(const Point& other) const {
-        return x == other.x && y == other.y;
-    }
-    
-    Point operator-(const Point& other) const {
-        return {x - other.x, y - other.y};
-    }
-};
-
-int orientation(const Point& a, const Point& b, const Point& c) {
-    double cross = (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);
-    return (cross < 0) ? -1 : (cross > 0) ? 1 : 0;
-}
-
-vector<Point> convexHull(vector<Point> points, bool includeCollinear = false) {
-    if (points.size() <= 1) return points;
-    
-    sort(points.begin(), points.end(), [](const Point& a, const Point& b) {
-        return make_pair(a.x, a.y) < make_pair(b.x, b.y);
-    });
-    
-    vector<Point> hull;
-    for (int phase = 0; phase < 2; ++phase) {
-        auto start = hull.size();
-        for (const auto& p : points) {
-            while (hull.size() >= start + 2) {
-                auto a = hull[hull.size()-2];
-                auto b = hull.back();
-                int o = orientation(a, b, p);
-                if (o < 0 || (!includeCollinear && o == 0)) break;
-                hull.pop_back();
-            }
-            hull.push_back(p);
-        }
-        hull.pop_back();
-        reverse(points.begin(), points.end());
-    }
-    
-    if (hull.size() == 2 && hull[0] == hull[1]) hull.pop_back();
-    return hull;
-}
diff --git a/Algoritmos/C++/ComputacionalGeometry/PointClass.cpp b/Algoritmos/C++/ComputacionalGeometry/PointClass.cpp
deleted file mode 100644
index 2d54a0d..0000000
--- a/Algoritmos/C++/ComputacionalGeometry/PointClass.cpp
+++ /dev/null
@@ -1,21 +0,0 @@
-struct Point
-{
-    double x, y;
-
-    Point operator+(const Point &o) const { return {x + o.x, y + o.y}; }
-    Point operator-(const Point &o) const { return {x - o.x, y - o.y}; }
-    double operator*(const Point &o) const { return x * o.x + y * o.y; }
-    double operator^(const Point &o) const { return x * o.y - y * o.x; }
-};
-
-Point operator*(double k, const Point &p) { return {k * p.x, k * p.y}; }
-
-istream &operator>>(istream &is, Point &p)
-{
-    return is >> p.x >> p.y;
-}
-
-ostream &operator<<(ostream &os, const Point &p)
-{
-    return os << "(" << p.x << "," << p.y << ")";
-}
diff --git a/Algoritmos/C++/ComputacionalGeometry/Polygon Intersection.cpp b/Algoritmos/C++/ComputacionalGeometry/Polygon Intersection.cpp
deleted file mode 100644
index fe2bd64..0000000
--- a/Algoritmos/C++/ComputacionalGeometry/Polygon Intersection.cpp	
+++ /dev/null
@@ -1,38 +0,0 @@
-class PolygonIntersectionChecker {
-public:
-    static bool check(const vector<Point>& poly1, const vector<Point>& poly2) {
-        return checkSeparatingAxis(poly1, poly2) && checkSeparatingAxis(poly2, poly1);
-    }
-
-private:
-    static bool checkSeparatingAxis(const vector<Point>& poly1, const vector<Point>& poly2) {
-        for (size_t i = 0; i < poly1.size(); ++i) {
-            Point edge = poly1[(i+1)%poly1.size()] - poly1[i];
-            Point normal = {-edge.y, edge.x};
-          
-            double len = sqrt(normal.x*normal.x + normal.y*normal.y);
-            normal.x /= len;
-            normal.y /= len;
-            
-            auto [min1, max1] = projectPolygon(poly1, normal);
-            auto [min2, max2] = projectPolygon(poly2, normal);
-            
-            if (max1 < min2 || max2 < min1) return false;
-        }
-        return true;
-    }
-    
-    static pair<double, double> projectPolygon(const vector<Point>& poly, const Point& axis) {
-        double min_proj = axis.x*poly[0].x + axis.y*poly[0].y;
-        double max_proj = min_proj;
-        
-        for (const auto& p : poly) {
-            double proj = axis.x*p.x + axis.y*p.y;
-            min_proj = min(min_proj, proj);
-            max_proj = max(max_proj, proj);
-        }
-        return {min_proj, max_proj};
-    }
-};
-
-//llamar al metodo: PolygonIntersectionChecker::check(Poly1, Poly2)
diff --git a/Algoritmos/C++/ComputacionalGeometry/PolygonArea.cpp b/Algoritmos/C++/ComputacionalGeometry/PolygonArea.cpp
deleted file mode 100644
index 3ef74ac..0000000
--- a/Algoritmos/C++/ComputacionalGeometry/PolygonArea.cpp
+++ /dev/null
@@ -1,17 +0,0 @@
-struct Point{
-    long long x, y;
-    long long operator^(const Point &o) const { return x * o.y - y * o.x; }
-};
-istream &operator>>(istream &is, Point &p){
-    return is >> p.x >> p.y;
-}
-long long area(vector<Point> &A, int n){
-    long long ans = 0;
-    fori(i, 0, n - 1) {
-        Point p1 = A[i];
-        Point p2 = A[i + 1];
-        long long cross = (p1 ^ p2);
-        ans += cross;
-    }
-    return abs(ans + (A[n - 1] ^ A[0]));
-}
diff --git a/Algoritmos/C++/ComputacionalGeometry/isPointInTriangle.cpp b/Algoritmos/C++/ComputacionalGeometry/isPointInTriangle.cpp
deleted file mode 100644
index 724a7eb..0000000
--- a/Algoritmos/C++/ComputacionalGeometry/isPointInTriangle.cpp
+++ /dev/null
@@ -1,12 +0,0 @@
-double triangleArea(double x1, double y1, double x2, double y2, double x3, double y3) {
-    return abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0;
-}
-
-bool isPointInTriangle(pair<double, double> A, pair<double, double> B, pair<double, double> C, pair<double, double> P) {
-    double A_area = triangleArea(A.first, A.second, B.first, B.second, C.first, C.second);
-    double A_area1 = triangleArea(P.first, P.second, B.first, B.second, C.first, C.second);
-    double A_area2 = triangleArea(A.first, A.second, P.first, P.second, C.first, C.second);
-    double A_area3 = triangleArea(A.first, A.second, B.first, B.second, P.first, P.second);
-
-    return A_area == (A_area1 + A_area2 + A_area3);
-}
diff --git a/Algoritmos/C++/Grafos/Articulation Points.cpp b/Algoritmos/C++/Grafos/Articulation Points.cpp
deleted file mode 100644
index 3aa211c..0000000
--- a/Algoritmos/C++/Grafos/Articulation Points.cpp	
+++ /dev/null
@@ -1,35 +0,0 @@
-int n; 
-vector<vector<int>> adj;
-vector<bool> visited;
-vector<int> d, low;
-vector<int> ap;
-int time;
-void dfs(int v, int p = -1) {
-    visited[v] = true;
-    d[v] = low[v] = time++;
-    int children=0;
-    for (int to : adj[v]) {
-        if (to == p) continue;
-        if (visited[to]) {
-            low[v] = min(low[v], d[to]);
-        } else {
-            dfs(to, v);
-            low[v] = min(low[v], low[to]);
-            if (low[to] >= d[v] && p!=-1)
-                ap.push_back(v);
-            ++children;
-        }
-    }
-    if(p == -1 && children > 1)
-        ap.push_back(v);
-}
-void find_cutpoints() {
-    time = 0;
-    visited.assign(n, false);
-    d.assign(n, -1);
-    low.assign(n, -1);
-    for (int i = 0; i < n; ++i) {
-        if (!visited[i])
-            dfs (i);
-    }
-}
diff --git a/Algoritmos/C++/Grafos/Bipartite Check.cpp b/Algoritmos/C++/Grafos/Bipartite Check.cpp
deleted file mode 100644
index 714f5c3..0000000
--- a/Algoritmos/C++/Grafos/Bipartite Check.cpp	
+++ /dev/null
@@ -1,23 +0,0 @@
-int n;
-vector<vector<int>> adj;
-vector<int> side(n, -1);
-bool is_bipartite = true;
-queue<int> q;
-for (int st = 0; st < n; ++st) {
-    if (side[st] == -1) {
-        q.push(st);
-        side[st] = 0;
-        while (!q.empty()) {
-            int v = q.front();
-            q.pop();
-            for (int u : adj[v]) {
-                if (side[u] == -1) {
-                    side[u] = side[v] ^ 1;
-                    q.push(u);
-                } else {
-                    is_bipartite &= side[u] != side[v];
-                }
-            }
-        }
-    }
-}
diff --git a/Algoritmos/C++/Grafos/Bridges.cpp b/Algoritmos/C++/Grafos/Bridges.cpp
deleted file mode 100644
index 8ef3ec4..0000000
--- a/Algoritmos/C++/Grafos/Bridges.cpp
+++ /dev/null
@@ -1,29 +0,0 @@
-#define Pair pair<int,int>
-#define eb emplace_back
-int n;
-int t;
-vector<int> d;
-vector<int> low;
-vector<vector<int>> adj;
-vector<Pair>bridge;
-void dfs(int u, int par) {
-    d[u] = t++;
-    low[u] = d[u];
-    for(int v:adj[u]) {
-        if (v==par) continue;
-        if (d[v]>0)
-            low[u] = min(low[u], d[v]);
-        else {
-            dfs(v, u);
-            low[u] = min(low[u], low[v]);
-            if (low[v]>d[u]) bridge.eb(make_pair(u,v));
-        }
-    }
-}
-void get_bridges() {
-    d.assign(n, 0);
-    low.assign(n,0);
-    t = 1;
-    bridge.clear();
-    dfs(0, -1);
-}
diff --git a/Algoritmos/C++/Grafos/Cycles Undirected Graph.cpp b/Algoritmos/C++/Grafos/Cycles Undirected Graph.cpp
deleted file mode 100644
index fc412ff..0000000
--- a/Algoritmos/C++/Grafos/Cycles Undirected Graph.cpp	
+++ /dev/null
@@ -1,42 +0,0 @@
-int n;
-vector<vector<int> > adj;
-vector<bool> state;
-vector<int> pi;
-int cycle_start, cycle_end;
-
-bool dfs(int u, int par) {
-    state[u] = true;
-    for (int v: adj[u]) {
-        if (v == par) continue;
-        if (state[v]) {
-            cycle_end = u;
-            cycle_start = v;
-            return true;
-        }
-        pi[v] = u;
-        if (dfs(v, pi[v]))
-            return true;
-    }
-    return false;
-}
-
-vector<int> find_cycle() {
-    state.assign(n, false);
-    pi.assign(n, -1);
-    cycle_start = -1;
-    for (int u = 0; u < n; u++) {
-        if (!state[u] && dfs(u, pi[u]))
-            break;
-    }
-
-    if (cycle_start == -1) {
-        vector<int> cycle;
-        return cycle;
-    }
-    vector<int> cycle;
-    cycle.push_back(cycle_start);
-    for (int v = cycle_end; v != cycle_start; v = pi[v])
-        cycle.push_back(v);
-    cycle.push_back(cycle_start);
-    return cycle;
-}
diff --git a/Algoritmos/C++/Grafos/Dijkstra.cpp b/Algoritmos/C++/Grafos/Dijkstra.cpp
deleted file mode 100644
index 2431a2c..0000000
--- a/Algoritmos/C++/Grafos/Dijkstra.cpp
+++ /dev/null
@@ -1,29 +0,0 @@
-
-typedef unsigned long long ll;
-typedef pair<ll, int> Pair;
-ll INF=18446744073709551615;
-vector<ll> dijkstra(int source, vector<vector<Pair>>& graph) {
-    int n = graph.size();
-    vector<ll> d(n, INF);
-    d[source] = 0;
-    priority_queue<Pair, vector<Pair>, greater<Pair>> pq;
-    vector<bool> state(n, false);
-    pq.push({0, source});
-    while (!pq.empty()) {
-        int u = pq.top().second;
-        pq.pop();
-        if (state[u]) continue;
-        state[u] = true;
-        for (const Pair& edge : graph[u]) {
-            ll w = edge.first;
-            int v = edge.second;
-            if(!state[v]) {
-                if (d[u] + w < d[v]) {
-                    d[v] = d[u] + w;
-                    pq.push({d[v], v});
-                }
-            }
-        }
-    }
-    return d;
-}
diff --git a/Algoritmos/C++/Grafos/Flow Dinic.cpp b/Algoritmos/C++/Grafos/Flow Dinic.cpp
deleted file mode 100644
index 49310fe..0000000
--- a/Algoritmos/C++/Grafos/Flow Dinic.cpp	
+++ /dev/null
@@ -1,75 +0,0 @@
-struct FlowEdge {
-    int v, u;
-    long long cap, flow = 0;
-    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}
-};
-struct Dinic {
-    const long long flow_inf = 1e18;
-    vector<FlowEdge> edges;
-    vector<vector<int>> adj;
-    int n, m = 0;
-    int s, t;
-    vector<int> level, ptr;
-    queue<int> q;
-    Dinic(int n, int s, int t) : n(n), s(s), t(t) {
-        adj.resize(n);
-        level.resize(n);
-        ptr.resize(n);
-    }
-    void add_edge(int v, int u, long long cap) {
-        edges.emplace_back(v, u, cap);
-        edges.emplace_back(u, v, 0);
-        adj[v].push_back(m);
-        adj[u].push_back(m + 1);
-        m += 2;
-    }
-    bool bfs() {
-        while (!q.empty()) {
-            int v = q.front();
-            q.pop();
-            for (int id : adj[v]) {
-                if (edges[id].cap == edges[id].flow)
-                    continue;
-                if (level[edges[id].u] != -1)
-                    continue;
-                level[edges[id].u] = level[v] + 1;
-                q.push(edges[id].u);
-            }
-        }
-        return level[t] != -1;
-    }
-    long long dfs(int v, long long pushed) {
-        if (pushed == 0)
-            return 0;
-        if (v == t)
-            return pushed;
-        for (int& cid = ptr[v]; cid < (int)adj[v].size(); cid++) {
-            int id = adj[v][cid];
-            int u = edges[id].u;
-            if (level[v] + 1 != level[u])
-                continue;
-            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));
-            if (tr == 0)
-                continue;
-            edges[id].flow += tr;
-            edges[id ^ 1].flow -= tr;
-            return tr;
-        }
-        return 0;
-    }
-    long long flow() {
-        long long f = 0;
-        while (true) {
-            fill(level.begin(), level.end(), -1);
-            level[s] = 0;
-            q.push(s);
-            if (!bfs())
-                break;
-            fill(ptr.begin(), ptr.end(), 0);
-            while (long long pushed = dfs(s, flow_inf)) {
-                f += pushed;
-            }
-        }
-        return f;
-    }
-};
diff --git a/Algoritmos/C++/Grafos/Flow Edmond Karp.cpp b/Algoritmos/C++/Grafos/Flow Edmond Karp.cpp
deleted file mode 100644
index 63ab619..0000000
--- a/Algoritmos/C++/Grafos/Flow Edmond Karp.cpp	
+++ /dev/null
@@ -1,47 +0,0 @@
-int n;
-vector<vector<int>> capacity;
-vector<vector<int>> adj;
-
-int bfs(int s, int t, vector<int>& parent) {
-    fill(parent.begin(), parent.end(), -1);
-    parent[s] = -2;
-    queue<pair<int, int>> q;
-    q.push({s, INF});
-
-    while (!q.empty()) {
-        int cur = q.front().first;
-        int flow = q.front().second;
-        q.pop();
-
-        for (int next : adj[cur]) {
-            if (parent[next] == -1 && capacity[cur][next]) {
-                parent[next] = cur;
-                int new_flow = min(flow, capacity[cur][next]);
-                if (next == t)
-                    return new_flow;
-                q.push({next, new_flow});
-            }
-        }
-    }
-
-    return 0;
-}
-
-int maxflow(int s, int t) {
-    int flow = 0;
-    vector<int> parent(n);
-    int new_flow;
-
-    while (new_flow = bfs(s, t, parent)) {
-        flow += new_flow;
-        int cur = t;
-        while (cur != s) {
-            int prev = parent[cur];
-            capacity[prev][cur] -= new_flow;
-            capacity[cur][prev] += new_flow;
-            cur = prev;
-        }
-    }
-
-    return flow;
-}
diff --git a/Algoritmos/C++/Grafos/Flow minCost .cpp b/Algoritmos/C++/Grafos/Flow minCost .cpp
deleted file mode 100644
index 7ad5713..0000000
--- a/Algoritmos/C++/Grafos/Flow minCost .cpp	
+++ /dev/null
@@ -1,68 +0,0 @@
-//https://github.com/AleXamuel/Proyecto-Nestor/tree/main
-#include <bits/stdc++.h>
-using namespace std;
-#define INF (1<<30)
-#define ll long long
-#define nmax 101
-struct edge {
-    int from, to, flow, cost;
-    edge(int fr, int t, int fl,int c) {
-        from=fr;
-        to=t;
-        flow=fl;
-        cost=c;
-    }
-};
-vector<edge> Edges;
-vector<int> adj[nmax];
-int d[nmax],pi[nmax];
-void addEdge(int u, int v, int f, int c) {
-    adj[u].push_back(Edges.size());
-    Edges.push_back(edge(u,v,f,c));
-    adj[v].push_back(Edges.size());
-    Edges.push_back(edge(v,u,0,-c));
-}
-void shortest_path(int n, int s) {
-    bool state[nmax];
-    for(int i=0;i<n;i++)
-        d[i]=INF,pi[i]=-1,state[i]=0;
-    d[s]=0;
-    queue<int> q;
-    q.push(s);
-    while(!q.empty()) {
-        int u = q.front();
-        q.pop();
-        state[u]=0;
-        for(int i=0;i<adj[u].size();i++) {
-            int id=adj[u][i];
-            int v=Edges[id].to;
-            if(Edges[id].flow>0&&d[v]>d[u]+Edges[id].cost) {
-                pi[v]=id;
-                d[v]=d[u]+Edges[id].cost;
-                if(!state[v]) state[v]=1,q.push(v);
-            }
-        }
-    }
-}
-int min_cost_flow(int n,int k, int s, int t) {
-    int flow=0,ret=0;
-    while(flow<k) {
-        shortest_path(n,s);
-        if(d[t]==INF)return -1;
-        int f=k-flow,cur=t;
-        while(cur!=s) {
-            f=min(f,Edges[pi[cur]].flow);
-            cur=Edges[pi[cur]].from;
-        }
-        flow+=f;
-        ret+=f*d[t];
-        cur=t;
-        while(cur!=s) {
-            Edges[pi[cur]].flow-=f;
-            Edges[pi[cur]^1].flow+=f;
-            cur=Edges[pi[cur]].from;
-        }
-    }
-    return flow<k?-1:ret;
-}
-}
diff --git a/Algoritmos/C++/Grafos/FloydWarshall.cpp b/Algoritmos/C++/Grafos/FloydWarshall.cpp
deleted file mode 100644
index e8c6686..0000000
--- a/Algoritmos/C++/Grafos/FloydWarshall.cpp
+++ /dev/null
@@ -1,10 +0,0 @@
-ll INF=18446744073709551615;
-vector<vector<ll>> floydWarshall(vector<vector<ll>> madj) {
-    int n = madj.size();
-    for (int k = 0; k < n; k++)
-        for (int i = 0; i < n; i++)
-            for (int j = 0; j < n; j++)
-                if (madj[i][k] < INF && madj[k][j] < INF)
-                    madj[i][j] = min(madj[i][j], madj[i][k] + madj[k][j]);
-    return madj;
-}
diff --git a/Algoritmos/C++/Grafos/Longest Path in a DAG.cpp b/Algoritmos/C++/Grafos/Longest Path in a DAG.cpp
deleted file mode 100644
index 9fe97c8..0000000
--- a/Algoritmos/C++/Grafos/Longest Path in a DAG.cpp	
+++ /dev/null
@@ -1,24 +0,0 @@
-vector<vector<int>> adj;
-vector<int> in_deg;
-int n;
-int kahn() {
-    queue<int>q;
-    int res=-1;
-    for(int u =0;u<n;u++)
-        if(!in_deg[u])
-            q.push(u);
-    while(!q.empty()) {
-        int level=q.size();
-        for(int i=0;i<level;i++) {
-            int u=q.front();
-            q.pop();
-            for(int v:adj[u]) {
-                in_deg[v]--;
-                if(!in_deg[v])
-                    q.push(v);
-            }
-        }
-        res++;
-    }
-    return res;
-}
diff --git a/Algoritmos/C++/Grafos/MST Prim Sparse.cpp b/Algoritmos/C++/Grafos/MST Prim Sparse.cpp
deleted file mode 100644
index 1e1f232..0000000
--- a/Algoritmos/C++/Grafos/MST Prim Sparse.cpp	
+++ /dev/null
@@ -1,42 +0,0 @@
-struct Edge {
-    int w, to;
-
-    bool operator<(const Edge& other) const {
-        if(w!=other.w) return w<other.w;
-        return to<other.to;
-    }
-};
-int n;
-vector<vector<Edge>> adj;
-long long prim(int s) {
-    set<Edge> q;
-    vector<long long> d(n, INF);
-    vector<bool> state(n, false);
-    d[s]=0;
-    q.insert({0,s});
-    while(!q.empty()) {
-        Edge cur = *q.begin();
-        q.erase(q.begin());
-        int u=cur.to;
-        if(!state[u]) {
-            state[u]=true;
-            for(Edge e : adj[u]) {
-                int v=e.to;
-                int w=e.w;
-                if(!state[v]) {
-                    if(w<d[v]) {
-                        d[v]=w;
-                        q.insert({w, v});
-                    }
-                }
-            }
-
-        }
-    }
-    long long c=0;
-    for(long long i:d) {
-        if(i==INF) return -1;
-        c+=i;
-    }
-    return c;
-}
diff --git a/Algoritmos/C++/Grafos/Matching Kuhn.cpp b/Algoritmos/C++/Grafos/Matching Kuhn.cpp
deleted file mode 100644
index 9cc89f5..0000000
--- a/Algoritmos/C++/Grafos/Matching Kuhn.cpp	
+++ /dev/null
@@ -1,15 +0,0 @@
-vector<vector<int>> adj;
-vector<int> mt;
-vector<bool> used;
-bool try_kuhn(int v) {
-    if (used[v])
-        return false;
-    used[v] = true;
-    for (int to : adj[v]) {
-        if (mt[to] == -1 || try_kuhn(mt[to])) {
-            mt[to] = v;
-            return true;
-        }
-    }
-    return false;
-}
diff --git a/Algoritmos/C++/Grafos/SCC Condensed Graph.cpp b/Algoritmos/C++/Grafos/SCC Condensed Graph.cpp
deleted file mode 100644
index a2c5047..0000000
--- a/Algoritmos/C++/Grafos/SCC Condensed Graph.cpp	
+++ /dev/null
@@ -1,38 +0,0 @@
-vector<bool> visited;
-void dfs(int v, vector<vector<int>> const& adj, vector<int> &output) {
-    visited[v] = true;
-    for (auto u : adj[v])
-        if (!visited[u])
-            dfs(u, adj, output);
-    output.push_back(v);
-}
-void strongly_connected_components(vector<vector<int>> const& adj,vector<vector<int>> &components,vector<vector<int>> &adj_cond) {
-    int n = adj.size();
-    components.clear(), adj_cond.clear();
-    vector<int> order;
-    visited.assign(n, false);
-    for (int i = 0; i < n; i++)
-        if (!visited[i])
-            dfs(i, adj, order);
-    vector<vector<int>> adj_rev(n);
-    for (int v = 0; v < n; v++)
-        for (int u : adj[v])
-            adj_rev[u].push_back(v);
-    visited.assign(n, false);
-    reverse(order.begin(), order.end());
-    vector<int> roots(n, 0);
-    for (auto v : order)
-        if (!visited[v]) {
-            std::vector<int> component;
-            dfs(v, adj_rev, component);
-            components.push_back(component);
-            int root = *min_element(begin(component), end(component));
-            for (auto u : component)
-                roots[u] = root;
-        }
-    adj_cond.assign(n, {});
-    for (int v = 0; v < n; v++)
-        for (auto u : adj[v])
-            if (roots[v] != roots[u])
-                adj_cond[roots[v]].push_back(roots[u]);
-}
diff --git a/Algoritmos/C++/Grafos/Top Sort Kahn.cpp b/Algoritmos/C++/Grafos/Top Sort Kahn.cpp
deleted file mode 100644
index 2bb99f6..0000000
--- a/Algoritmos/C++/Grafos/Top Sort Kahn.cpp	
+++ /dev/null
@@ -1,25 +0,0 @@
-vector<vector<int>> adj;
-vector<int> in_deg;
-int n;
-vector<int> kahn() {
-    queue<int>q;
-    for(int u =0;u<n;u++)
-        if(!in_deg[u])
-            q.push(u);
-    int index=0;
-    vector<int> topSort(n);
-    while(!q.empty()) {
-        int u=q.front();
-        q.pop();
-        topSort[index++]=u;
-        for(int v:adj[u]) {
-            in_deg[v]--;
-            if(!in_deg[v])
-                q.push(v);
-        }
-    }
-    if(index!=n)
-        return {};
-    return topSort;
-
-}
diff --git a/Algoritmos/C++/Grafos/Top Sort.cpp b/Algoritmos/C++/Grafos/Top Sort.cpp
deleted file mode 100644
index 23cb1bd..0000000
--- a/Algoritmos/C++/Grafos/Top Sort.cpp	
+++ /dev/null
@@ -1,23 +0,0 @@
-int n;
-vector<vector<int> > adj;
-vector<bool> visited;
-vector<int> ans;
-void dfs(int v) {
-    visited[v] = true;
-    for (int u: adj[v]) {
-        if (!visited[u]) {
-            dfs(u);
-        }
-    }
-    ans.push_back(v);
-}
-void topological_sort() {
-    visited.assign(n, false);
-    ans.clear();
-    for (int i = 0; i < n; ++i) {
-        if (!visited[i]) {
-            dfs(i);
-        }
-    }
-    reverse(ans.begin(), ans.end());
-}
diff --git a/Algoritmos/C++/Grafos/Union Find.cpp b/Algoritmos/C++/Grafos/Union Find.cpp
deleted file mode 100644
index ad06daf..0000000
--- a/Algoritmos/C++/Grafos/Union Find.cpp	
+++ /dev/null
@@ -1,25 +0,0 @@
-vector<int>pi, Size;
-int Find(int u) {
-    int aux = u;
-    while (u != pi[u])
-        u = pi[u];
-    while (aux != pi[aux]) {
-        aux = pi[aux];
-        pi[aux] = u;
-    }
-    return u;
-}
-
-void Union(int u, int v) {
-    int x = Find(u);
-    int y = Find(v);
-    if (x == y)
-        return;
-    if (Size[x] < Size[y]) {
-        pi[x] = y;
-        Size[y] += Size[x];
-    } else {
-        pi[y] = x;
-        Size[x] += Size[y];
-    }
-}
diff --git a/Algoritmos/C++/Math/Apply permutations.cpp b/Algoritmos/C++/Math/Apply permutations.cpp
deleted file mode 100644
index d1b235f..0000000
--- a/Algoritmos/C++/Math/Apply permutations.cpp	
+++ /dev/null
@@ -1,18 +0,0 @@
-vector<int> applyPermutation(vector<int> sequence, vector<int> permutation) {
-    vector<int> newSequence(sequence.size());
-    for(int i = 0; i < sequence.size(); i++) {
-        newSequence[i] = sequence[permutation[i]];
-    }
-    return newSequence;
-}
-
-vector<int> permute(vector<int> sequence, vector<int> permutation, long long k) {
-    while (k > 0) {
-        if (k & 1) {
-            sequence = applyPermutation(sequence, permutation);
-        }
-        permutation = applyPermutation(permutation, permutation);
-        k >>= 1;
-    }
-    return sequence;
-}
diff --git a/Algoritmos/C++/Math/Binomial Coeficient.cpp b/Algoritmos/C++/Math/Binomial Coeficient.cpp
deleted file mode 100644
index c75b15a..0000000
--- a/Algoritmos/C++/Math/Binomial Coeficient.cpp	
+++ /dev/null
@@ -1,42 +0,0 @@
-#define ll unsigned long long
-//for small numbers use de next code, for bigger ones where a module is necesary use the second one
-ll ncr(int n, int k) {
-    if (k > n || k < 0) return 0;
-    if (k > n - k) k = n - k;
-    ll result = 1;
-    for (int i = 0; i < k; i++) {
-        result *= (n - i);
-        result /= (i + 1);
-    }
-    return result;
-}
-//2
-vector<ll> fact;
-vector<ll> invFact;
-ll modPow(ll base, ll exp, int mod) {
-    ll res = 1, x = base % mod;
-    while (exp > 0) {
-        if (exp & 1)
-            res = res * x % mod;
-        x = (x * x) % mod;
-        exp >>= 1;
-    }
-    return res;
-}
-void getFactorials(int n) {
-    fact.resize(n + 1);
-    invFact.resize(n + 1);
-    fact[0] = invFact[0] = 1;
-    for (int i = 1; i <= n; i++) {
-        fact[i] = fact[i - 1] * i % MOD;
-    }
-    invFact[n] = modPow(fact[n], MOD - 2, MOD);
-    for (int i = n - 1; i >= 1; i--) {
-        invFact[i] = invFact[i + 1] * (i + 1) % MOD;
-    }
-}
-ll ncr(int n, int r) {
-    if (r > n || r < 0)
-        return 0;
-    return fact[n] * invFact[r] % MOD * invFact[n - r] % MOD;
-}
diff --git a/Algoritmos/C++/Math/Extended Euclidean Algorithm.cpp b/Algoritmos/C++/Math/Extended Euclidean Algorithm.cpp
deleted file mode 100644
index e19c209..0000000
--- a/Algoritmos/C++/Math/Extended Euclidean Algorithm.cpp	
+++ /dev/null
@@ -1,12 +0,0 @@
-int gcd(int a, int b, int& x, int& y) {
-    if (b == 0) {
-        x = 1;
-        y = 0;
-        return a;
-    }
-    int x1, y1;
-    int d = gcd(b, a % b, x1, y1);
-    x = y1;
-    y = x1 - y1 * (a / b);
-    return d;
-}
diff --git a/Algoritmos/C++/Math/GetDivisors.cpp b/Algoritmos/C++/Math/GetDivisors.cpp
deleted file mode 100644
index 8c16f1c..0000000
--- a/Algoritmos/C++/Math/GetDivisors.cpp
+++ /dev/null
@@ -1,11 +0,0 @@
-vector<int> get_divisors(const int n) {
-    vector<int> divisors;
-    for (int i = 1; i * i <= n; i++) {
-        if (n % i == 0) {
-            divisors.emplace_back(i);
-            if (i != n / i)
-                divisors.emplace_back(n / i);
-        }
-    }
-    return divisors;
-}
diff --git a/Algoritmos/C++/Math/RacionalClass.cpp b/Algoritmos/C++/Math/RacionalClass.cpp
deleted file mode 100644
index c2b09f8..0000000
--- a/Algoritmos/C++/Math/RacionalClass.cpp
+++ /dev/null
@@ -1,20 +0,0 @@
-struct Racional {
-    int num, den;
-
-    void simplificar() {
-        long div = gcd(num, den);
-        if (div != 1) {
-            num /= div;
-            den /= div;
-        }
-    }
-    static int mcd(const int a, const int b) {
-        if (a % b == 0)
-            return b;
-        return mcd(b, a % b);
-    }
-}
-
-ostream &operator<<(ostream &os, const Racional &p) {
-    return os << p.num << "/" << p.den;
-}
diff --git a/Algoritmos/C++/Math/SieveOfEratosthenesAndPrimeDecomposition.cpp b/Algoritmos/C++/Math/SieveOfEratosthenesAndPrimeDecomposition.cpp
deleted file mode 100644
index 8c92466..0000000
--- a/Algoritmos/C++/Math/SieveOfEratosthenesAndPrimeDecomposition.cpp
+++ /dev/null
@@ -1,38 +0,0 @@
-using namespace std;
-#include <iostream>
-#include <vector>
-
-vector<int> primos;
-
-vector<int> sieve(int n)
-{
-    vector<bool> is_prime(n + 1, true);
-    is_prime[0] = is_prime[1] = false;
-    for (int i = 2; i <= n; i++)
-        if (is_prime[i] && (long long)i * i <= n)
-            for (int j = i * i; j <= n; j += i)
-                is_prime[j] = false;
-    vector<int> ans;
-    for (int i = 2; i < n + 1; i++)
-        if (is_prime[i])
-            ans.push_back(i);
-    return ans;
-}
-
-vector<int> decompose(int n)
-{
-    vector<int> ans;
-    for (int i : primos)
-    {
-        if ((long long)i * i > n)
-            break;
-        while (n % i == 0)
-        {
-            ans.push_back(i);
-            n /= i;
-        }
-    }
-    if (n > 1)
-        ans.push_back(n);
-    return ans;
-}
diff --git a/Algoritmos/C++/Math/mod_exponential.cpp b/Algoritmos/C++/Math/mod_exponential.cpp
deleted file mode 100644
index 15cff51..0000000
--- a/Algoritmos/C++/Math/mod_exponential.cpp
+++ /dev/null
@@ -1,10 +0,0 @@
-const int MOD = 1000000007;
-long long modExp(long base, long exp, long mod) {
-    long long res = 1,x=base%mod;
-    while (exp>0) {
-        if ((exp & 1)>0) res=(res*x)%mod;
-        x = (x*x)%mod;
-        exp >>= 1;
-    }
-    return res;
-}
diff --git a/Algoritmos/C++/Math/primeCheck.cpp b/Algoritmos/C++/Math/primeCheck.cpp
deleted file mode 100644
index 1c4e0ee..0000000
--- a/Algoritmos/C++/Math/primeCheck.cpp
+++ /dev/null
@@ -1,12 +0,0 @@
-bool isPrime(const int n) {
-    if (n <= 1)
-        return false;
-    if (n <= 3)
-        return true;
-    if (n % 2 == 0 || n % 3 == 0)
-        return false;
-    for (int i = 5; i * i <= n; i += 6)
-        if (n % i == 0 || n % (i + 2) == 0)
-            return false;
-    return true;
-}
diff --git a/Algoritmos/C++/Segment Tree/FreqMinMax.cpp b/Algoritmos/C++/Segment Tree/FreqMinMax.cpp
deleted file mode 100644
index c228eb2..0000000
--- a/Algoritmos/C++/Segment Tree/FreqMinMax.cpp	
+++ /dev/null
@@ -1,48 +0,0 @@
-//Compute the Maximum or Minimum of a given segment of an Array and the number of times it appears on that segment.
-using namespace std;
-#include <bits/stdc++.h>
-#define MAXN 100000
-int n;
-pair<long long, int> t[4 * MAXN];
-pair<long long, int> combine(pair<long long, int> a, pair<long long, int> b){
-    if (a.first < b.first)
-        return a;
-    if (b.first < a.first)
-        return b;
-    return {a.first, a.second + b.second};
-}
-void build(long long a[], int v = 1, int tl = 0, int tr = n - 1){
-    if (tl == tr)
-        t[v] = {a[tl], 1};
-    else
-    {
-        int tm = (tl + tr) / 2;
-        build(a, v * 2, tl, tm);
-        build(a, v * 2 + 1, tm + 1, tr);
-        t[v] = combine(t[v * 2], t[v * 2 + 1]);
-    }
-}
-pair<long long, int> query(int v, int tl, int tr, int l, int r){
-    if (l > r)
-        return {INT_MAX, 0};
-    if (l == tl && r == tr)
-        return t[v];
-    int tm = (tl + tr) / 2;
-    return combine(query(v * 2, tl, tm, l, min(r, tm)),
-                   query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));
-}
-void update(int v, int tl, int tr, int pos, int new_val){
-    if (tl == tr)
-        t[v] = {new_val, 1};
-    else
-    {
-        int tm = (tl + tr) / 2;
-        if (pos <= tm)
-            update(v * 2, tl, tm, pos, new_val);
-        else
-            update(v * 2 + 1, tm + 1, tr, pos, new_val);
-        t[v] = combine(t[v * 2], t[v * 2 + 1]);
-    }
-}
-
-long long A[MAXN];
diff --git a/Algoritmos/C++/Segment Tree/Lazy Propagation Assigment on ranges.cpp b/Algoritmos/C++/Segment Tree/Lazy Propagation Assigment on ranges.cpp
deleted file mode 100644
index b5022f4..0000000
--- a/Algoritmos/C++/Segment Tree/Lazy Propagation Assigment on ranges.cpp	
+++ /dev/null
@@ -1,50 +0,0 @@
-const int MAXN = 1e5 + 5;
-
-int t[4 * MAXN];
-bool marked[4 * MAXN];
-
-void build(int a[], int v, int tl, int tr) {
-    marked[v] = false;
-
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        build(a, v*2, tl, tm);
-        build(a, v*2+1, tm+1, tr);
-    }
-}
-
-void push(int v) {
-    if (marked[v]) {
-        t[v*2] = t[v*2+1] = t[v];
-        marked[v*2] = marked[v*2+1] = true;
-        marked[v] = false;
-    }
-}
-
-void update(int v, int tl, int tr, int l, int r, int new_val) {
-    if (l > r)
-        return;
-    if (l == tl && tr == r) {
-        t[v] = new_val; 
-        marked[v] = true;
-    } else {
-        push(v);
-        int tm = (tl + tr) / 2;
-        update(v*2, tl, tm, l, min(r, tm), new_val);
-        update(v*2+1, tm+1, tr, max(l, tm+1), r, new_val);
-    }
-}
-
-int get(int v, int tl, int tr, int pos) {
-    if (tl == tr) {
-        return t[v];
-    }
-    push(v);
-    int tm = (tl + tr) / 2;
-    if (pos <= tm)
-        return get(v*2, tl, tm, pos);
-    
-    return get(v*2+1, tm+1, tr, pos);
-}
diff --git a/Algoritmos/C++/Segment Tree/Lazy Propagation for max.cpp b/Algoritmos/C++/Segment Tree/Lazy Propagation for max.cpp
deleted file mode 100644
index ce930bc..0000000
--- a/Algoritmos/C++/Segment Tree/Lazy Propagation for max.cpp	
+++ /dev/null
@@ -1,45 +0,0 @@
-const int MAXN = 1e5 + 5;
-const int INF = 1e9;
-int t[4 * MAXN], lazy[4 * MAXN];
-
-void build(int a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        build(a, v*2, tl, tm);
-        build(a, v*2+1, tm+1, tr);
-        t[v] = max(t[v*2], t[v*2+1]);
-    }
-}
-
-void push(int v) {
-    t[v*2] += lazy[v];
-    lazy[v*2] += lazy[v];
-    t[v*2+1] += lazy[v];
-    lazy[v*2+1] += lazy[v];
-    lazy[v] = 0;
-}
-
-void update(int v, int tl, int tr, int l, int r, int addend) {
-    if (l > r) return;
-    if (l == tl && tr == r) {
-        t[v] += addend;
-        lazy[v] += addend;
-    } else {
-        push(v);
-        int tm = (tl + tr) / 2;
-        update(v*2, tl, tm, l, min(r, tm), addend);
-        update(v*2+1, tm+1, tr, max(l, tm+1), r, addend);
-        t[v] = max(t[v*2], t[v*2+1]);
-    }
-}
-
-int query(int v, int tl, int tr, int l, int r) {
-    if (l > r) return -INF;
-    if (l == tl && tr == r) return t[v];
-    push(v);
-    int tm = (tl + tr) / 2;
-    return max(query(v*2, tl, tm, l, min(r, tm)),
-           query(v*2+1, tm+1, tr, max(l, tm+1), r));
-}
diff --git a/Algoritmos/C++/Segment Tree/MinQuery.cpp b/Algoritmos/C++/Segment Tree/MinQuery.cpp
deleted file mode 100644
index dfa0d4b..0000000
--- a/Algoritmos/C++/Segment Tree/MinQuery.cpp	
+++ /dev/null
@@ -1,59 +0,0 @@
-
-#include <iostream>
-#include <algorithm>
-using namespace std;
-#define ll long long
-class ST {
-private:
-    vector<ll> t;
-    int n;
-
-    void buildST(vector<int>& a, int v, int tl, int tr) {
-        if (tl == tr) {
-            t[v] = a[tl];
-        } else {
-            int tm = (tl + tr) / 2;
-            buildST(a, v * 2, tl, tm);
-            buildST(a, v * 2 + 1, tm + 1, tr);
-            t[v] = min(t[v * 2], t[v * 2 + 1]);
-        }
-    }
-
-    ll sumST(int v, int tl, int tr, int l, int r) {
-        if (l > r)
-            return 1e18;
-        if (l == tl && r == tr)
-            return t[v];
-        int tm = (tl + tr) / 2;
-        return min(sumST(v * 2, tl, tm, l, min(r, tm)),
-                   sumST(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));
-    }
-
-    void updateST(int v, int tl, int tr, int pos, ll new_val) {
-        if (tl == tr) {
-            t[v] = min(new_val,t[v]);
-        } else {
-            int tm = (tl + tr) / 2;
-            if (pos <= tm)
-                updateST(v * 2, tl, tm, pos, new_val);
-            else
-                updateST(v * 2 + 1, tm + 1, tr, pos, new_val);
-            t[v] = min(t[v * 2], t[v * 2 + 1]);
-        }
-    }
-
-public:
-    ST(vector<int>& a) {
-        n = a.size();
-        t.resize(4 * n);
-        buildST(a, 1, 0, n - 1);
-    }
-
-    ll query(int l, int r) {
-        return sumST(1, 0, n - 1, l, r);
-    }
-
-    void update(int pos, int x) {
-        updateST(1, 0, n - 1, pos, x);
-    }
-};
diff --git a/Algoritmos/C++/Segment Tree/NextMax.cpp b/Algoritmos/C++/Segment Tree/NextMax.cpp
deleted file mode 100644
index 6f7fcf5..0000000
--- a/Algoritmos/C++/Segment Tree/NextMax.cpp	
+++ /dev/null
@@ -1,51 +0,0 @@
-//Given an integer 'x', find in the array an integer 'y' which is the less number higher or equal to 'x'
-#include <iostream>
-#include <algorithm>
-using namespace std;
-typedef long long ll;
-ll* t;
-int* t;
-int ans=-1;
-void buildST(int a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        buildST(a, v*2, tl, tm);
-        buildST(a, v*2+1, tm+1, tr);
-        t[v] = max(t[v*2],t[v*2+1]);
-    }
-}
-void build(int a[],int n) {
-    buildST(a,1,0,n-1);
-}
-void get_firstST(int v, int l, int r, int x, int j) {
-    if(t[v]<x)return;
-    if(ans>-1)return;
-    if(l==r) {
-        if(t[v]>=x)
-            ans=l;
-        return;
-    }
-    int m = (l+r)/2;
-    get_firstST(v*2,l,m,x,j);
-    get_firstST(v*2+1,m+1,r,x,j);
-}
-void first(int n,int x, int j) {
-    return get_firstST(1,0,n-1,x,j);
-}
-void updateST(int v, int tl, int tr, int pos, int new_val) {
-    if (tl == tr) {
-        t[v] = new_val;
-    } else {
-        int tm = (tl + tr) / 2;
-        if (pos <= tm)
-            updateST(v*2, tl,   tm, pos, new_val);
-        else
-            updateST(v*2+1, tm+1, tr, pos, new_val);
-        t[v] = max(t[v*2] , t[v*2+1]);
-    }
-}
-void update(int n, int pos, int x) {
-    updateST(1,0,n-1,pos,x);
-}
diff --git a/Algoritmos/C++/Segment Tree/Segment Tree 2D.cpp b/Algoritmos/C++/Segment Tree/Segment Tree 2D.cpp
deleted file mode 100644
index 7005a8b..0000000
--- a/Algoritmos/C++/Segment Tree/Segment Tree 2D.cpp	
+++ /dev/null
@@ -1,73 +0,0 @@
-int t[4 * MAXN][4 * MAXN];
-int a[MAXN][MAXN];
-int n, m;
-
-void build_y(int vx, int lx, int rx, int vy, int ly, int ry) {
-    if (ly == ry) {
-        if (lx == rx)
-            t[vx][vy] = a[lx][ly];
-        else
-            t[vx][vy] = t[vx*2][vy] + t[vx*2+1][vy];
-    } else {
-        int my = (ly + ry) / 2;
-        build_y(vx, lx, rx, vy*2, ly, my);
-        build_y(vx, lx, rx, vy*2+1, my+1, ry);
-        t[vx][vy] = t[vx][vy*2] + t[vx][vy*2+1];
-    }
-}
-
-void build_x(int vx, int lx, int rx) {
-    if (lx != rx) {
-        int mx = (lx + rx) / 2;
-        build_x(vx*2, lx, mx);
-        build_x(vx*2+1, mx+1, rx);
-    }
-    build_y(vx, lx, rx, 1, 0, m-1);
-}
-
-int sum_y(int vx, int vy, int tly, int try_, int ly, int ry) {
-    if (ly > ry)
-        return 0;
-    if (ly == tly && try_ == ry)
-        return t[vx][vy];
-    int tmy = (tly + try_) / 2;
-    return sum_y(vx, vy*2, tly, tmy, ly, min(ry, tmy))
-         + sum_y(vx, vy*2+1, tmy+1, try_, max(ly, tmy+1), ry);
-}
-
-int sum_x(int vx, int tlx, int trx, int lx, int rx, int ly, int ry) {
-    if (lx > rx)
-        return 0;
-    if (lx == tlx && trx == rx)
-        return sum_y(vx, 1, 0, m-1, ly, ry);
-    int tmx = (tlx + trx) / 2;
-    return sum_x(vx*2, tlx, tmx, lx, min(rx, tmx), ly, ry)
-         + sum_x(vx*2+1, tmx+1, trx, max(lx, tmx+1), rx, ly, ry);
-}
-
-void update_y(int vx, int lx, int rx, int vy, int ly, int ry, int x, int y, int new_val) {
-    if (ly == ry) {
-        if (lx == rx)
-            t[vx][vy] = new_val;
-        else
-            t[vx][vy] = t[vx*2][vy] + t[vx*2+1][vy];
-    } else {
-        int my = (ly + ry) / 2;
-        if (y <= my)
-            update_y(vx, lx, rx, vy*2, ly, my, x, y, new_val);
-        else
-            update_y(vx, lx, rx, vy*2+1, my+1, ry, x, y, new_val);
-        t[vx][vy] = t[vx][vy*2] + t[vx][vy*2+1];
-    }
-}
-
-void update_x(int vx, int lx, int rx, int x, int y, int new_val) {
-    if (lx != rx) {
-        int mx = (lx + rx) / 2;
-        if (x <= mx)
-            update_x(vx*2, lx, mx, x, y, new_val);
-        else
-            update_x(vx*2+1, mx+1, rx, x, y, new_val);
-    }
-    update_y(vx, lx, rx, 1, 0, m-1, x, y, new_val);
-}
diff --git a/Algoritmos/C++/String/KMP.cpp b/Algoritmos/C++/String/KMP.cpp
deleted file mode 100644
index 01dff48..0000000
--- a/Algoritmos/C++/String/KMP.cpp
+++ /dev/null
@@ -1,22 +0,0 @@
-vector<int> prefix_function(string s) {
-    int n = (int)s.length();
-    vector<int> pi(n);
-    for (int i = 1; i < n; i++) {
-        int j = pi[i-1];
-        while (j > 0 && s[i] != s[j])
-            j = pi[j-1];
-        if (s[i] == s[j])
-            j++;
-        pi[i] = j;
-    }
-    return pi;
-}
-
-//return the frequence of every prefix
-vector<int> ans(n + 1);
-for (int i = 0; i < n; i++)
-    ans[pi[i]]++;
-for (int i = n-1; i > 0; i--)
-    ans[pi[i-1]] += ans[i];
-for (int i = 0; i <= n; i++)
-    ans[i]++;
diff --git a/Algoritmos/C++/String/LCS Number.cpp b/Algoritmos/C++/String/LCS Number.cpp
deleted file mode 100644
index 853f544..0000000
--- a/Algoritmos/C++/String/LCS Number.cpp	
+++ /dev/null
@@ -1,15 +0,0 @@
-//return de size of the LCS
-int lcs(string pat, string alph) {
-    int m = pat.length();
-    int n = alph.length();
-    vector<vector<int>> lcs(m+1,vector<int>(n+1,0));
-    for (int i = 1; i <= m; i++) {
-        for (int j = 1; j <= n; j++) {
-            if (pat[i - 1] == alph[j - 1])
-                lcs[i][j] = 1 + lcs[i - 1][j - 1];
-            else
-                lcs[i][j] = max(lcs[i - 1][j], lcs[i][j - 1]);
-        }
-    }
-    return lcs[m][n];
-}
diff --git a/Algoritmos/C++/String/LCS String.cpp b/Algoritmos/C++/String/LCS String.cpp
deleted file mode 100644
index 6c2d955..0000000
--- a/Algoritmos/C++/String/LCS String.cpp	
+++ /dev/null
@@ -1,30 +0,0 @@
-//return de LCS
-string LCS(string s1, string s2) {
-        int m = s1.length();
-        int k = s2.length();
-        vector<vector<int>> dp(m+1,vector<int>(k+1,0));
-        for (int i = 1; i <= m; i++) {
-            for (int j = 1; j <= k; j++) {
-                if (s1[i-1]==s2[j-1]) {
-                    dp[i][j] = dp[i - 1][j - 1] + 1;
-                } else {
-                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
-                }
-            }
-        }
-        int index = dp[m][k];
-        string lcs(index,'#');
-        int i = m, j = k;
-        while (i > 0 && j > 0) {
-            if (s1[i-1]==s2[j-1])  {
-                lcs[--index] = s1[i-1];
-                i--;
-                j--;
-            } else if (dp[i - 1][j] > dp[i][j - 1]) {
-                i--;
-            } else {
-                j--;
-            }
-        }
-        return lcs;
-    }
diff --git a/Algoritmos/C++/String/Suffix Array.cpp b/Algoritmos/C++/String/Suffix Array.cpp
deleted file mode 100644
index fdbf73e..0000000
--- a/Algoritmos/C++/String/Suffix Array.cpp	
+++ /dev/null
@@ -1,76 +0,0 @@
-#include <iostream>
-#include <algorithm>
-#include <cstring>
-using namespace std;
-const int N=500010;
-struct SA {
-#define REP(i,n) for(int i=0;i<int(n);i++)
-#define REP1(i,a,b) for(int i=a;i<=int(b);i++)
-    bool _t[N*2];
-    int _s[N*2], _sa[N*2], _c[N*2], x[N], _p[N], _q[N*2], r[N], hei[N];
-    int operator [] (int i) {return _sa[i];}
-    void build(int* s, int n, int m) {
-        memcpy(_s, s, sizeof(int) * n);
-        sais(_s,_sa,_p,_q,_t,_c,n,m);
-        mkhei(n);
-    }
-    void mkhei(int n) {
-        REP(i,n) r[_sa[i]]=i;
-        hei[0]=0;
-        REP(i,n) if(r[i]) {
-            int ans = i>0 ? max(hei[r[i-1]]-1,0):0;
-            while (_s[i+ans]==_s[_sa[r[i]-1]+ans])ans++;
-            hei[r[i]]=ans;
-        }
-    }
-    void sais(int *s, int *sa, int *p, int *q, bool *t, int *c, int n, int z) {
-        bool uniq = t[n-1] = true, neq;
-        int nn = 0, nmxz = -1, *nsa = sa + n, *ns = s + n, lst = -1;
-#define MS0(x,n) memset((x),0,n*sizeof(*(x)))
-#define MAGIC(XD) MS0(sa, n); \
-        memcpy(x,c,sizeof(int) * z); \
-        XD; \
-        memcpy(x+1,c,sizeof(int) * (z-1));\
-        REP(i,n) if(sa[i] && !t[sa[i]-1]) sa[x[s[sa[i]-1]]++] =sa[i]-1;\
-        memcpy(x,c,sizeof(int) * z); \
-        for(int i =n-1; i>=0;i--)if(sa[i] && t[sa[i]-1]) sa[--x[s[sa[i]-1]]]=sa[i]-1;
-        MS0(c,z);
-        REP(i,n) uniq&= ++c[s[i]]<2;
-        REP(i,z-1) c[i+1] +=c[i];
-        if(uniq) {REP(i,n) sa[--c[s[i]]]=i;return;}
-        for (int i =n-2;i>=0;i--) t[i]=s[i]==s[i+1] ? t[i+1] : s[i]<s[i+1];
-        MAGIC(REP1(i,1,n-1) if(t[i] && !t[i-1]) sa[--x[s[i]]]=p[q[i]=nn++]=i);
-        REP(i,n) if (sa[i] && t[sa[i]] && !t[sa[i]-1]) {
-            neq=lst<0||memcmp(s+sa[i],s+lst,(p[q[sa[i]]+1]-sa[i])*sizeof(int));
-            ns[q[lst=sa[i]]]=nmxz+=neq;
-        }
-        sais(ns, nsa, p+nn, q+n,t+n, c+z, nn, nmxz +1);
-        MAGIC(for (int i = nn-1; i>=0;i--) sa[--x[s[p[nsa[i]]]]]=p[nsa[i]]);
-    }
-}sa;
-int lcp[N], p[N];
-
-void suffix_array(int* ip, int len) {
-    ip[len++] = 0;
-    sa.build(ip, len, 128);
-    for (int i = 0; i < len; i++) {
-        lcp[i] = sa.hei[i + 1];
-        p[i] = sa._sa[i + 1];
-    }
-}
-int arr[N];
-//How to use it. Example
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    string s;
-    cin >> s;
-    s+="$";
-    for (int i = 0; i < s.length(); i++) arr[i]=s[i];
-    suffix_array(arr, s.size());
-    for (int i = 0; i < s.size(); i++)
-        cout<<lcp[i]<<" ";
-    cout << endl;
-    
-    return 0;
-}
diff --git a/Algoritmos/C++/Trie/Trie XOR.cpp b/Algoritmos/C++/Trie/Trie XOR.cpp
deleted file mode 100644
index f12c602..0000000
--- a/Algoritmos/C++/Trie/Trie XOR.cpp	
+++ /dev/null
@@ -1,54 +0,0 @@
-struct trieNode {
-    ll value;
-    trieNode *arr[2];
-};
-
-trieNode *newNode() {
-    trieNode *temp = new trieNode;
-    temp->value = 0;
-    temp->arr[0] = NULL;
-    temp->arr[1] = NULL;
-    return temp;
-}
-
-void insert(trieNode *root, ll pre_xor, ll max_bits) {
-    trieNode *temp = root;
-
-    bool val;
-    for (ll i = max_bits; i >= 0; i--) {
-        val = pre_xor & (1 << i);
-
-        if (temp->arr[val] == NULL) temp->arr[val] = newNode();
-        temp = temp->arr[val];
-    }
-    temp->value = pre_xor;
-}
-
-ll query(trieNode *root, ll pre_xor, ll max_bits) {
-    trieNode *temp = root;
-    bool val;
-    for (ll i = max_bits; i >= 0; i--) {
-        val = pre_xor & (1 << i);
-
-        if (temp->arr[!val] != NULL) temp = temp->arr[!val];
-        else if (temp->arr[val] != NULL) temp = temp->arr[val];
-    }
-    return pre_xor ^ (temp->value);
-}
-
-ll maxSubarrayXOR(vector<ll> &arr, ll n = -1, ll max_val = LONG_MIN) {
-    if (n == -1) n = arr.size();
-    if (max_val == LONG_MIN) max_val = *max_element(arr.begin(), arr.end());
-    ll max_bits = 64 - __builtin_clzll(max_val | 1);
-
-    trieNode *root = newNode();
-    insert(root, 0, max_bits);
-    ll res = 0, pre_xor = 0;
-
-    for (ll i = 0; i <n; i++) {
-        pre_xor = pre_xor ^arr[i];
-        insert(root, pre_xor, max_bits);
-        res = max(res, query(root, pre_xor, max_bits));
-    }
-    return res;
-}
diff --git a/Algoritmos/Java/Grafos/Articulation Points.java b/Algoritmos/Java/Grafos/Articulation Points.java
deleted file mode 100644
index 0f75792..0000000
--- a/Algoritmos/Java/Grafos/Articulation Points.java	
+++ /dev/null
@@ -1,32 +0,0 @@
-static int n;
-static ArrayList<Integer>[] adj;
-static int[] d, low;
-static int time;
-static boolean[] ap;
-static void dfs(int u, int par) {
-    d[u] = time++;
-    low[u] = d[u];
-    int children = 0;
-    for(int v : adj[u]) {
-        if (v == par) continue;
-        else if (d[v] > 0)
-            low[u] = Math.min(low[u], d[v]);
-        else {
-            children++;
-            dfs(v, u);
-            low[u] = Math.min(low[u], low[v]);
-            if (par != -1 && low[v] >= d[u]) ap[u] = true;
-        }
-    }
-    if (par == -1 && children > 1) ap[u] = true;
-}
-
-static void get_articulation_points() {
-    d = new int[n];
-    low = new int[n];
-    time = 1;
-    ap = new boolean[n];
-    Arrays.fill(ap, false);
-    for (int i = 0; i < n; i++)
-        if (d[i] == 0) dfs(i, -1);
-}
diff --git a/Algoritmos/Java/Grafos/BFS.java b/Algoritmos/Java/Grafos/BFS.java
deleted file mode 100644
index 140c195..0000000
--- a/Algoritmos/Java/Grafos/BFS.java
+++ /dev/null
@@ -1,22 +0,0 @@
-static ArrayList<Integer>[] adj;
-static boolean[] state;
-static int[] d;
-static int[] pi;
-static void bfs(int s){
-    pi[s]=-1;
-    d[s]=0;
-    state[s]=true;
-    Queue<Integer> q=new LinkedList<>();
-    q.add(s);
-    while(!q.isEmpty()){
-        int u=q.poll();
-        for(int v:adj[u]){
-            if(!state[v]){
-                pi[v]=u;
-                d[v]=d[u]+1;
-                state[v]=true;
-                q.add(v);
-            }
-        }
-    }
-}
diff --git a/Algoritmos/Java/Grafos/Bellmand Ford.java b/Algoritmos/Java/Grafos/Bellmand Ford.java
deleted file mode 100644
index 8504d56..0000000
--- a/Algoritmos/Java/Grafos/Bellmand Ford.java	
+++ /dev/null
@@ -1,41 +0,0 @@
-static Edge[] edges;
-static int[] d;
-static int n;
-public static void bellmanFord() {
-      Arrays.fill(d, Integer.MAX_VALUE);
-      d[0] = 0;
-      boolean hayCambios = true;
-      while (hayCambios) {
-          hayCambios = false;
-          for (Edge e : edges) {
-              if(d[e.u]<30000)
-                  if(d[e.v]>d[e.u]+e.w){
-                      d[e.v]=d[e.u]+e.w;
-                      hayCambios = true;
-                  }
-          }
-      }
-
-  }
-  private static class Edge implements Comparable<Edge> {
-      int u;
-      int v;
-      int w;
-      Edge(int uu,int vv, int ww) {
-          u=uu;
-          v = vv;
-          w = ww;
-      }
-      public boolean equals(Object o) {
-          if (o instanceof Edge)
-              return (v==((Edge)o).v && w==((Edge)o).w);
-          return false;
-      }
-      public int compareTo(Edge o) {
-          if (w < o.w) return -1;
-          if (w > o.w) return 1;
-          if (v < o.v) return -1;
-          if (v > o.v) return 1;
-          return 0;
-      }
-  }
diff --git a/Algoritmos/Java/Grafos/Bipartite Check.java b/Algoritmos/Java/Grafos/Bipartite Check.java
deleted file mode 100644
index a6d46c0..0000000
--- a/Algoritmos/Java/Grafos/Bipartite Check.java	
+++ /dev/null
@@ -1,24 +0,0 @@
-static Boolean[] color;
-static ArrayList<Integer>[] adj;
-static boolean[] state;
-static boolean bfs(int s) {
-color[s] = true;
-Queue<Integer> Q = new LinkedList<>();
-Q.add(s);
-while (!Q.isEmpty()) {
-    int u = Q.poll();
-    if (!state[u]) {
-        state[u] = true;
-        for (int v : adj[u]) {
-            if (!state[v]) {
-                if (color[v]==null)
-                    color[v] = !color[u];
-                if (color[v] == color[u])
-                    return false;
-                Q.add(v);
-            }
-        }
-    }
-}
-return true;
-}
diff --git a/Algoritmos/Java/Grafos/Bridges.java b/Algoritmos/Java/Grafos/Bridges.java
deleted file mode 100644
index 6c8b15b..0000000
--- a/Algoritmos/Java/Grafos/Bridges.java
+++ /dev/null
@@ -1,27 +0,0 @@
-static int N;
-static ArrayList<Integer>[] adj;
-static int[] d, f, low;
-static int time;
-static ArrayList<int[]> bridg;
-
-static void dfs(int u, int par) {
-    d[u] = time++;
-    low[u] = d[u];
-    for(int v:adj[u]) {
-        if (v==par) continue;
-        else if (d[v]>0) 
-            low[u] = Math.min(low[u], d[v]);
-        else {
-            dfs(v, u); 
-            low[u] = Math.min(low[u], low[v]);
-            if (low[v]>d[u]) bridg.add(new int[]{u, v});
-        }
-    }
-}
-static void get_bridges() {
-    d = new int[N];
-    low = new int[N];        
-    time = 1;
-    bridg = new ArrayList<int[]>();
-    dfs(0, -1);
-}
diff --git a/Algoritmos/Java/Grafos/CycleTestForDirectedAndUndirectedGraphs.java b/Algoritmos/Java/Grafos/CycleTestForDirectedAndUndirectedGraphs.java
deleted file mode 100644
index 4b99ec1..0000000
--- a/Algoritmos/Java/Grafos/CycleTestForDirectedAndUndirectedGraphs.java
+++ /dev/null
@@ -1,32 +0,0 @@
-import java.util.*;
-
-public class Main {
-	static ArrayList<Integer>[] adj;
-	static int n;
-
-	// Directed Graph
-	static boolean dfs(int u, int[] state) {
-		if (state[u] == 1)
-			return true;
-		if (state[u] == 2)
-			return false;
-		state[u] = 1;
-		boolean ans = false;
-		for (int v : adj[u])
-			ans = ans || dfs(v, state);
-		state[u] = 2;
-		return ans;
-	}
-
-	// Undirected Graph
-	static boolean dfs(int u, int par, boolean[] visited) {
-		if (visited[u])
-			return true;
-		visited[u] = true;
-		boolean ans = false;
-		for (int v : adj[u])
-			if (v != par)
-				ans = ans || dfs(v, u, visited);
-		return ans;
-	}
-}
diff --git a/Algoritmos/Java/Grafos/Cycles Directed Graph.java b/Algoritmos/Java/Grafos/Cycles Directed Graph.java
deleted file mode 100644
index a6f917b..0000000
--- a/Algoritmos/Java/Grafos/Cycles Directed Graph.java	
+++ /dev/null
@@ -1,37 +0,0 @@
-static int n;
-static ArrayList<Integer>[] adj;
-static int[] state;
-static int[] pi;
-static int cycleStart, cycleEnd;
-static boolean dfs(int u) {
-    state[u] = 1;
-    for (int v : adj[u]) {
-        if (state[v] == 0) {
-            pi[v] = u;
-            if (dfs(v)) return true;
-        }else if (state[v] == 1) {
-            cycleStart = v;
-            cycleEnd = u;
-            return true;
-        }
-    }
-    state[u] = 2;
-    return false;
-}
-static LinkedList<Integer> cycle() {
-    LinkedList<Integer> ans = new LinkedList<>();
-    state = new int[n];
-    pi = new int[n];
-    Arrays.fill(pi, -1);
-    cycleStart = -1;
-    for (int u = 0; u < n; u++)
-        if (state[u] == 0 && dfs(u))
-            break;
-    if (cycleStart == -1)
-        return null;
-    ans.add(cycleStart);
-    for (int u = cycleEnd; u != cycleStart; u = pi[u])
-        ans.add(u);
-    ans.add(cycleStart);
-    return ans;
-}
diff --git a/Algoritmos/Java/Grafos/Cycles Undirected Graph.java b/Algoritmos/Java/Grafos/Cycles Undirected Graph.java
deleted file mode 100644
index 4ba2863..0000000
--- a/Algoritmos/Java/Grafos/Cycles Undirected Graph.java	
+++ /dev/null
@@ -1,38 +0,0 @@
-static int n;
-static ArrayList<Integer>[] adj;
-static boolean[] state;
-static int[] pi;
-static int cycleStart, cycleEnd;
-static boolean dfs(int u, int par) {
-    state[u] = true;
-    for (int v : adj[u]) {
-        if (v == par) continue;
-        if (state[v]) {
-            cycleStart = v;
-            cycleEnd = u;
-            return true;
-        }
-        pi[v] = u;
-        if (dfs(v, u)) return true;
-    }
-    return false;
-}
-
-static LinkedList<Integer> cycle() {
-    LinkedList<Integer> ans = new LinkedList<>();
-    state = new boolean[n];
-    pi = new int[n];
-    Arrays.fill(pi, -1);
-    cycleStart = -1;
-    for (int u = 0; u < n; u++)
-        if (!state[u] && dfs(u, pi[u]))
-            break;
-    if (cycleStart == -1)
-        return null;
-    ans.add(cycleStart);
-    for (int u = cycleEnd; u != cycleStart; u = pi[u])
-        ans.add(u);
-    ans.add(cycleStart);
-    return ans;
-
-}
diff --git a/Algoritmos/Java/Grafos/Dijkstra.java b/Algoritmos/Java/Grafos/Dijkstra.java
deleted file mode 100644
index a990e66..0000000
--- a/Algoritmos/Java/Grafos/Dijkstra.java
+++ /dev/null
@@ -1,37 +0,0 @@
-static boolean[] state;
-static ArrayList<Edge>[] adj;
-static int[] d,pi;
-static int INF =Integer.MAX_VALUE;
-static void dijkstra(int s) {
-    Arrays.fill(d, INF);
-    d[s] = 0;
-    TreeSet<Edge> Q = new TreeSet<>();
-    Q.add(new Edge(s, d[s]));
-    while (!Q.isEmpty()) {
-        Edge e = Q.pollFirst();
-        int u = e.vertex;
-        if (!state[u]) {
-            state[u] = true;
-            for (Edge ee : adj[u]) {
-                int v = ee.vertex,w = ee.weight;
-                if (!state[v])
-                    if (d[u] + w < d[v]) {
-                        d[v] = d[u] + w;
-                        pi[v]=u;
-                        Q.add(new Edge(v, d[v]));
-                    }
-            }
-        }
-    }
-}
-static class Edge implements Comparable<Edge> {
-    int vertex,weight;
-    public Edge(int v, int w) {
-        this.vertex = v;
-        this.weight = w;
-    }
-    public int compareTo(Edge o) {
-        if(weight!=o.weight)return Integer.compare(weight,o.weight);
-        return Integer.compare(vertex,o.vertex);
-    }
-}
diff --git a/Algoritmos/Java/Grafos/Flows Edmond-Karp.java b/Algoritmos/Java/Grafos/Flows Edmond-Karp.java
deleted file mode 100644
index 5dd8db9..0000000
--- a/Algoritmos/Java/Grafos/Flows Edmond-Karp.java	
+++ /dev/null
@@ -1,43 +0,0 @@
-static int INF = Integer.MAX_VALUE;
-static int n;
-static int[][] capacity;
-static ArrayList<Integer>[] adj;
-static boolean bfs(int s, int t, int[] parent){
-    boolean[] visited=new boolean[n];
-    Queue<Integer> q=new LinkedList<>();
-    q.add(s);
-    parent[s]=-1;
-    visited[s]=true;
-    while (!q.isEmpty()){
-        int cur=q.poll();
-        for(int n:adj[cur]){
-            if(!visited[n]&&capacity[cur][n]>0){
-                parent[n]=cur;
-                visited[n]=true;
-                q.add(n);
-                if(n==t)
-                    return true;
-            }
-        }
-    }
-    return false;
-}
-static int maxflow(int s, int t){
-    int[] pi=new int[n];
-    int maxflow=0;
-    while (bfs(s,t,pi)){
-        int flow=INF;
-        for(int cur=t;cur!=s;cur=pi[cur]){
-            int p=pi[cur];
-            flow=Math.min(flow,capacity[p][cur]);
-        }
-        for (int cur = t; cur != s; cur = pi[cur]) {
-            int p = pi[cur];
-            capacity[p][cur] -= flow;
-            capacity[cur][p] += flow;
-        }
-
-        maxflow += flow;
-    }
-    return maxflow;
-}
diff --git a/Algoritmos/Java/Grafos/FloydWarshall.java b/Algoritmos/Java/Grafos/FloydWarshall.java
deleted file mode 100644
index 9e92646..0000000
--- a/Algoritmos/Java/Grafos/FloydWarshall.java
+++ /dev/null
@@ -1,23 +0,0 @@
-public class FloydWarshall {
-		static int n;
-		static int[][] adj;
-
-		static void initializeGraph() {
-			adj = new int[n][n];
-			for (int[] i : adj)
-				Arrays.fill(i, Integer.MAX_VALUE);
-		}
-
-		static void addEdge(int source, int destination, int cost) {
-			adj[source][destination] = cost;
-		}
-
-		static void floydWarshall() {
-			for (int k = 0; k < n; k++)
-				for (int i = 0; i < n; i++)
-					for (int j = 0; j < n; j++)
-						if (adj[i][k] < Integer.MAX_VALUE && adj[k][j] < Integer.MAX_VALUE)
-							adj[i][j] = Math.min(adj[i][j], adj[i][k] + adj[k][j]);
-
-		}
-	}
diff --git a/Algoritmos/Java/Grafos/Kahn'sAlgorithm for TopologicalSort.java b/Algoritmos/Java/Grafos/Kahn'sAlgorithm for TopologicalSort.java
deleted file mode 100644
index 2f3571b..0000000
--- a/Algoritmos/Java/Grafos/Kahn'sAlgorithm for TopologicalSort.java	
+++ /dev/null
@@ -1,38 +0,0 @@
-import java.util.*;
-static ArrayList<Integer>[] adj;
-static int[] in_deg;
-static int n;
-@SuppressWarnings("unchecked")
-static int[] findOrder(int V, int[][] E) {
-	n = V;
-	adj = new ArrayList[n];
-	in_deg = new int[n];
-	for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
-	for (int i = 0; i < E.length; i++) {
-		int a = E[i][1];
-		int b = E[i][0];
-		adj[a].add(b);
-		in_deg[b]++;
-	}
-	return kahn();
-}
-static int[] kahn() {
-	Queue<Integer> Q = new LinkedList<>();
-	for (int u = 0; u < n; u++)
-		if (in_deg[u] == 0)
-			Q.add(u);
-	int index = 0;
-	int[] toposort = new int[n];
-	while (!Q.isEmpty()) {
-		int u = Q.poll();
-		toposort[index++] = u;
-		for (int v : adj[u]) {
-			in_deg[v]--;
-			if (in_deg[v] == 0)
-				Q.add(v);
-		}
-	}
-	if (index != n)
-		return new int[] {};
-	return toposort;
-}
diff --git a/Algoritmos/Java/Grafos/Matching Kuhn.java b/Algoritmos/Java/Grafos/Matching Kuhn.java
deleted file mode 100644
index cd1eb3a..0000000
--- a/Algoritmos/Java/Grafos/Matching Kuhn.java	
+++ /dev/null
@@ -1,11 +0,0 @@
-static boolean tryKuhn(int u){
-    if(state[u])
-        return false;
-    state[u]=true;
-    for (int v:adj[u])
-        if(mt[v]==-1||tryKuhn(mt[v])){
-            mt[v]=u;
-            return true;
-        }
-    return false;
-}
diff --git a/Algoritmos/Java/Grafos/minCost Flow.java b/Algoritmos/Java/Grafos/minCost Flow.java
deleted file mode 100644
index 9c2ec80..0000000
--- a/Algoritmos/Java/Grafos/minCost Flow.java	
+++ /dev/null
@@ -1,67 +0,0 @@
-import java.io.*;
-import java.util.*;
-static ArrayList<Integer>[] adj;
-static int[] d, pi;
-static int INF = 1 << 30;
-static ArrayList<edge> Edges=new ArrayList<>();
-static void shortest_path(int n, int s) {
-    boolean[] state = new boolean[n];
-    Arrays.fill(pi, -1);
-    Arrays.fill(d, INF);
-    d[s] = 0;
-    Queue<Integer> q = new LinkedList<>();
-    q.add(s);
-    while (!q.isEmpty()) {
-        int u = q.poll();
-        state[u] = false;
-        for (int i = 0; i < adj[u].size(); i++) {
-            int id = adj[u].get(i);
-            int v = Edges.get(id).to;
-            if (Edges.get(id).flow > 0 && d[v] > d[u] + Edges.get(id).cost) {
-                pi[v] = id;
-                d[v] = d[u] + Edges.get(id).cost;
-                if (!state[v]) {
-                    state[v] = true;
-                    q.add(v);
-                }
-            }
-        }
-    }
-}
-static int min_cost_flow(int n, int k, int s, int t) {
-    int flow = 0, ret = 0;
-    while (flow < k) {
-        shortest_path(n, s);
-        if (d[t] == INF) return -1;
-        int f = k - flow, cur = t;
-        while (cur != s) {
-            f = Math.min(f, Edges.get(pi[cur]).flow);
-            cur = Edges.get(pi[cur]).from;
-        }
-        flow += f;
-        ret += f * d[t];
-        cur = t;
-        while (cur != s) {
-            Edges.get(pi[cur]).flow -= f;
-            Edges.get(pi[cur] ^ 1).flow += f;
-            cur = Edges.get(pi[cur]).from;
-        }
-    }
-    return flow<k?-1:ret;
-}
-static void addEdge(int u, int v, int f, int c) {
-    adj[u].add(Edges.size());
-    Edges.add(new edge(u, v, f, c));
-    adj[v].add(Edges.size());
-    Edges.add(new edge(v, u, 0, -c));
-
-}
-static class edge {
-    int from, to, flow, cost;
-    public edge(int from, int to, int flow, int cost) {
-        this.from = from;
-        this.to = to;
-        this.flow = flow;
-        this.cost = cost;
-    }
-}
diff --git a/Algoritmos/Java/String/KMP.java b/Algoritmos/Java/String/KMP.java
deleted file mode 100644
index 419e651..0000000
--- a/Algoritmos/Java/String/KMP.java
+++ /dev/null
@@ -1,54 +0,0 @@
-static int[] table(String pattern){
-    int size=pattern.length();
-    int APL=0;
-    int[] table=new int[size];
-    if(size==1)
-        return table;
-    for(int i=1;i<size;i++){
-        while(APL>0 && pattern.charAt(APL)!= pattern.charAt(i))
-            APL=table[APL-1];
-        if(pattern.charAt(APL)==pattern.charAt(i))
-            APL++;
-        table[i]=APL;
-    }
-    return table;
-}
-static LinkedList<Integer> KMP(String text, String pattern){
-  int[] table=table(pattern);
-  LinkedList<Integer> res=new LinkedList<>();
-  int textSize=text.length();
-  int patternSize= pattern.length();
-  int index=0;
-  int strIndex=0;
-  int patIndex=0;
-  while((textSize-index)>patternSize){
-      while(patIndex<patternSize && text.charAt(strIndex)==pattern.charAt(patIndex)){
-          strIndex++;
-          patIndex++;
-      }
-      if(patIndex>=patternSize)
-          res.add(index);
-
-      if(patIndex>0&&table[patIndex-1]>0){
-          index=strIndex-table[patIndex-1];
-          patIndex=table[patIndex-1];
-      }
-      else{
-          if(strIndex==index)
-              strIndex++;
-          index=strIndex;
-          if(patIndex>0)
-              patIndex=table[patIndex-1];
-      }
-
-  }
-  index=textSize-patternSize;
-  int c=0;
-  for (int i = 0; i < patternSize; i++) {
-      if(text.charAt(index+i)==pattern.charAt(i))
-          c++;
-  }
-  if(c==patternSize)
-      res.add(index);
-  return  res;
-}
diff --git a/Algoritmos/Java/String/LCS Number.java b/Algoritmos/Java/String/LCS Number.java
deleted file mode 100644
index 4ce98c2..0000000
--- a/Algoritmos/Java/String/LCS Number.java	
+++ /dev/null
@@ -1,14 +0,0 @@
-public static int nlcs(String pat, String alph) {
-    int m = pat.length();
-    int n = alph.length();
-    int[][] lcs = new int[m+1][n+1];
-    for (int i = 1; i <= m; i++) {
-        for (int j = 1; j <= n; j++) {
-            if (pat.charAt(i-1) == alph.charAt(j-1))
-                lcs[i][j] = 1 + lcs[i-1][j-1];
-            else
-                lcs[i][j] = Math.max(lcs[i-1][j], lcs[i][j-1]);
-        }
-    }
-    return lcs[m][n];
-}
diff --git a/Algoritmos/Java/String/LCS String.java b/Algoritmos/Java/String/LCS String.java
deleted file mode 100644
index ced5f5b..0000000
--- a/Algoritmos/Java/String/LCS String.java	
+++ /dev/null
@@ -1,31 +0,0 @@
-public static String findLCS(String s1, String s2) {
-        int m = s1.length();
-        int k = s2.length();
-        int[][] dp = new int[m + 1][k + 1];
-        for (int i = 1; i <= m; i++) {
-            for (int j = 1; j <= k; j++) {
-                if (s1.charAt(i-1)==s2.charAt(j-1)) {
-                    dp[i][j] = dp[i - 1][j - 1] + 1;
-                } else {
-                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
-                }
-            }
-        }
-        int index = dp[m][k];
-        char[] lcs = new char[index];
-        int i = m, j = k;
-
-        while (i > 0 && j > 0) {
-            if (s1.charAt(i-1)==s2.charAt(j-1))  {
-                lcs[--index] = s1.charAt(i-1);
-                i--;
-                j--;
-            } else if (dp[i - 1][j] > dp[i][j - 1]) {
-                i--;
-            } else {
-                j--;
-            }
-        }
-
-        return new String(lcs);
-    }
diff --git a/Algoritmos/Java/String/Suffix Array.java b/Algoritmos/Java/String/Suffix Array.java
deleted file mode 100644
index be24ba0..0000000
--- a/Algoritmos/Java/String/Suffix Array.java	
+++ /dev/null
@@ -1,87 +0,0 @@
-static int[] suffix_array_construction(String s) {
-    s += "$";
-    int[] sorted_shifts = sortCyclicShifts(s);
-    return Arrays.copyOfRange(sorted_shifts, 1, sorted_shifts.length);
-}
-public static int[] lcpConstruction(String s, int[] p) {
-    int n = s.length();
-    int[] rank = new int[n];
-    for (int i = 0; i < n; i++) {
-        rank[p[i]] = i;
-    }
-    int k = 0;
-    int[] lcp = new int[n - 1];
-    for (int i = 0; i < n; i++) {
-        if (rank[i] == n - 1) {
-            k = 0;
-            continue;
-        }
-        int j = p[rank[i] + 1];
-        while (i + k < n && j + k < n && s.charAt(i + k) == s.charAt(j + k)) {
-            k++;
-        }
-        lcp[rank[i]] = k;
-        if (k > 0) {
-            k--;
-        }
-    }
-    return lcp;
-}
-
-public static int[] sortCyclicShifts(String s) {
-    int n = s.length();
-    int alphabet = 256;
-    int[] p = new int[n];
-    int[] c = new int[n];
-    int[] cnt = new int[Math.max(alphabet, n)];
-    for (int i = 0; i < n; i++)
-        cnt[s.charAt(i)]++;
-    for (int i = 1; i < alphabet; i++)
-        cnt[i] += cnt[i - 1];
-    for (int i = 0; i < n; i++)
-        p[--cnt[s.charAt(i)]] = i;
-    int classes = 1;
-    for (int i = 1; i < n; i++) {
-        if (s.charAt(p[i]) != s.charAt(p[i - 1])) {
-            classes++;
-        }
-        c[p[i]] = classes - 1;
-    }
-
-    int[] pn = new int[n];
-    int[] cn = new int[n];
-    for (int h = 0; (1 << h) < n; h++) {
-        for (int i = 0; i < n; i++) {
-            pn[i] = p[i] - (1 << h);
-            if (pn[i] < 0) {
-                pn[i] += n;
-            }
-        }
-        Arrays.fill(cnt, 0, classes, 0);
-        for (int i = 0; i < n; i++) {
-            cnt[c[pn[i]]]++;
-        }
-        for (int i = 1; i < classes; i++) {
-            cnt[i] += cnt[i - 1];
-        }
-        for (int i = n - 1; i >= 0; i--) {
-            p[--cnt[c[pn[i]]]] = pn[i];
-        }
-        cn[p[0]] = 0;
-        classes = 1;
-        for (int i = 1; i < n; i++) {
-            int cur1 = c[p[i]];
-            int cur2 = c[(p[i] + (1 << h)) % n];
-            int prev1 = c[p[i - 1]];
-            int prev2 = c[(p[i - 1] + (1 << h)) % n];
-            if (cur1 != prev1 || cur2 != prev2) {
-                classes++;
-            }
-            cn[p[i]] = classes - 1;
-        }
-        int[] temp = c;
-        c = cn;
-        cn = temp;
-    }
-    return p;
-}
diff --git a/Problemas/AdvancedDataStructures/FenwickTree/RangeXorQueries.java b/Problemas/AdvancedDataStructures/FenwickTree/RangeXorQueries.java
deleted file mode 100644
index 033b1ff..0000000
--- a/Problemas/AdvancedDataStructures/FenwickTree/RangeXorQueries.java
+++ /dev/null
@@ -1,137 +0,0 @@
-import java.util.*;
-import java.io.*;
-
-public class RangeXorQueries {
-
-	public static void main(String[] args) throws Exception {
-		Input in = new Input(System.in);
-		PrintWriter out = new PrintWriter(System.out);
-		int n = in.nextInt();
-		int q = in.nextInt();
-		FenwickTree ft = new FenwickTree(n);
-		for (int i = 0; i < n; i++)
-			ft.update(i, in.nextLong());
-		for (int i = 0; i < q; i++)
-			out.println(ft.query(in.nextInt() - 1, in.nextInt() - 1));
-		out.flush();
-		in.close();
-	}
-
-	static class FenwickTree {
-		long[] t;
-		int n;
-		int passive = 0;
-
-		FenwickTree(int n) {
-			this.n = n;
-			t = new long[n];
-		}
-
-		void set(int i, int v) {
-			long old = query(i, i);
-			revUpdate(i, old);
-			update(i, v);
-		}
-
-		void update(int i, long v) {
-			while (i < n) {
-				t[i] = op(t[i], v);
-				i = goUp(i);
-			}
-		}
-
-		void revUpdate(int i, long v) {
-			while (i < n) {
-				t[i] = rev(t[i], v);
-				i = goUp(i);
-			}
-		}
-
-		long query(int l, int r) {
-			return rev(query(r), query(l - 1));
-		}
-
-		long rev(long a, long b) {
-			return a ^ b;
-		}
-
-		long query(int r) {
-			long res = passive;
-			while (r >= 0) {
-				res = op(res, t[r]);
-				r = goDown(r);
-			}
-			return res;
-		}
-
-		long op(long a, long b) {
-			return a ^ b;
-		}
-
-		int goUp(int x) {
-			return x | (x + 1);
-		}
-
-		int goDown(int x) {
-			return (x & (x + 1)) - 1;
-		}
-
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/Lazy Propagation/Circular RMQ.cpp b/Problemas/AdvancedDataStructures/SegmentTree/Lazy Propagation/Circular RMQ.cpp
deleted file mode 100644
index aeac1ec..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/Lazy Propagation/Circular RMQ.cpp	
+++ /dev/null
@@ -1,106 +0,0 @@
-//https://codeforces.com/problemset/problem/52/C
-#include <iostream>
-#include <vector>
-using namespace std;
-typedef long long ll;
-const ll INF=214745077900;
-ll *t, *lazy;
-void build(ll a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        build(a, v * 2, tl, tm);
-        build(a, v * 2 + 1, tm + 1, tr);
-        t[v] = min(t[v * 2] , t[v * 2 + 1]);
-    }
-}
-
-void push(int v, int tl, int tr) {
-    if (lazy[v] != 0) {
-        t[v * 2] += lazy[v] ;
-        lazy[v * 2] += lazy[v];
-        t[v * 2 + 1] += lazy[v];
-        lazy[v * 2 + 1] += lazy[v];
-        lazy[v] = 0;
-    }
-}
-
-void update(int v, int tl, int tr, int l, int r, ll addend) {
-    if (l > r) return;
-    if (l == tl && tr == r) {
-        t[v] += addend;
-        lazy[v] += addend;
-    } else {
-        push(v, tl, tr);
-        int tm = (tl + tr) / 2;
-        update(v * 2, tl, tm, l, min(r, tm), addend);
-        update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, addend);
-        t[v] = min(t[v * 2] , t[v * 2 + 1]);
-    }
-}
-
-ll query(int v, int tl, int tr, int l, int r) {
-    if (l > r) return INF;
-    if (l == tl && tr == r) {
-        return t[v];
-    }
-    push(v, tl, tr);
-    int tm = (tl + tr) / 2;
-    return min(query(v * 2, tl, tm, l, min(r, tm)) ,
-           query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));
-}
-vector<string> tokenize(string s, string del = " "){
-    int start, end = -1*del.size();
-    vector<string> ans(0);
-    do {
-        start = end + del.size();
-        end = s.find(del, start);
-        ans.push_back(s.substr(start, end - start));
-    } while (end != -1);
-    return ans;
-}
-
-int main() {
-    ios::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int n, q;
-    cin >> n;
-    ll* a = new ll[n]();
-    for(int i =0; i < n; i++)
-        cin>>a[i];
-    t = new ll[4 * n]();
-    lazy = new ll[4 * n]();
-    build(a, 1, 0, n - 1);
-    cin>>q;
-    cin.ignore();
-    string line;
-    for (int i = 0; i < q; i++) {
-        getline(cin,line);
-        vector<string> tokens = tokenize(line, " ");
-        if(tokens.size() == 3) {
-            int l = stoi(tokens[0]);
-            int r = stoi(tokens[1]);
-            ll x = stoi(tokens[2]);
-            if(l<=r)
-                update(1,0,n-1,l,r,x);
-            else {
-                update(1,0,n-1,l,n-1,x);
-                update(1,0,n-1,0,r,x);
-            }
-        }
-        else {
-            int l = stoi(tokens[0]);
-            int r = stoi(tokens[1]);
-            if(l<=r)
-                cout<<query(1,0,n-1,l,r)<<"\n";
-            else
-                cout<<min(query(1,0,n-1,l,n-1),query(1,0,n-1,0,r))<<"\n";
-        }
-    }
-    delete[] a;
-    delete[] t;
-    delete[] lazy;
-
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/Lazy Propagation/Horrible Queries.cpp b/Problemas/AdvancedDataStructures/SegmentTree/Lazy Propagation/Horrible Queries.cpp
deleted file mode 100644
index 23ee896..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/Lazy Propagation/Horrible Queries.cpp	
+++ /dev/null
@@ -1,86 +0,0 @@
-//https://vjudge.net/problem/SPOJ-HORRIBLE
-#include <iostream>
-#include <vector>
-using namespace std;
-typedef long long ll;
-ll *t, *lazy;
-void build(ll a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        build(a, v * 2, tl, tm);
-        build(a, v * 2 + 1, tm + 1, tr);
-        t[v] = t[v * 2] + t[v * 2 + 1];
-    }
-}
-
-void push(int v, int tl, int tr) {
-    if (lazy[v] != 0) {
-        int tm = (tl + tr) / 2;
-        t[v * 2] += lazy[v] * (tm - tl + 1);
-        lazy[v * 2] += lazy[v];
-        t[v * 2 + 1] += lazy[v] * (tr - tm);
-        lazy[v * 2 + 1] += lazy[v];
-        lazy[v] = 0;
-    }
-}
-
-void update(int v, int tl, int tr, int l, int r, ll addend) {
-    if (l > r) return;
-    if (l == tl && tr == r) {
-        t[v] += addend * (tr - tl + 1);
-        lazy[v] += addend;
-    } else {
-        push(v, tl, tr);
-        int tm = (tl + tr) / 2;
-        update(v * 2, tl, tm, l, min(r, tm), addend);
-        update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, addend);
-        t[v] = t[v * 2] + t[v * 2 + 1];
-    }
-}
-
-ll query(int v, int tl, int tr, int l, int r) {
-    if (l > r) return 0;
-    if (l == tl && tr == r) {
-        return t[v];
-    }
-    push(v, tl, tr);
-    int tm = (tl + tr) / 2;
-    return query(v * 2, tl, tm, l, min(r, tm)) +
-           query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);
-}
-
-int main() {
-    ios::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int ti;
-    cin >> ti;
-    while (ti--) {
-        int n, q;
-        cin >> n >> q;
-        ll* a = new ll[n]();
-        t = new ll[4 * n]();
-        lazy = new ll[4 * n]();
-        build(a, 1, 0, n - 1);
-        for (int i = 0; i < q; i++) {
-            int k;
-            cin >> k;
-            if (k == 1) {
-                int l, r;
-                cin >> l >> r;
-                cout << query(1, 0, n - 1, l - 1, r - 1) << " ";
-            } else {
-                int l, r;
-                ll x;
-                cin >> l >> r >> x;
-                update(1, 0, n - 1, l - 1, r - 1, x);
-            }
-        }
-        cout << "\n";
-        delete[] a;
-        delete[] t;
-        delete[] lazy;
-    }
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/Lazy Propagation/Range Update Queries.cpp b/Problemas/AdvancedDataStructures/SegmentTree/Lazy Propagation/Range Update Queries.cpp
deleted file mode 100644
index 02337a1..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/Lazy Propagation/Range Update Queries.cpp	
+++ /dev/null
@@ -1,87 +0,0 @@
-//https://cses.fi/problemset/result/12078785/
-#include <bits/stdc++.h>
-using namespace std;
-using ll = long long;
-#define MAXN 200001
-int n;
-ll t[4 * MAXN];
-ll lazy[4 * MAXN];
-
-void build(ll a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        build(a, v*2, tl, tm);
-        build(a, v*2+1, tm+1, tr);
-        t[v] = max(t[v*2], t[v*2 + 1]);
-    }
-}
-
-void push(int v, int tl, int tr) {
-    if (lazy[v] != 0) {
-        t[v] += (tr - tl + 1) * lazy[v];
-        if (tl != tr) {
-            lazy[v * 2] += lazy[v];
-            lazy[v * 2 + 1] += lazy[v];
-        }
-        lazy[v] = 0;
-    }
-}
-
-void updateRange(int v, int tl, int tr, int l, int r, ll u) {
-    push(v, tl, tr);
-    if (l > tr || r < tl) return;
-    if (l <= tl && tr <= r) {
-        lazy[v] += u;
-        push(v, tl, tr);
-    } else {
-        int tm = (tl + tr) / 2;
-        updateRange(v * 2, tl, tm, l, r, u);
-        updateRange(v * 2 + 1, tm + 1, tr, l, r, u);
-        t[v] = t[v * 2] + t[v * 2 + 1];
-    }
-}
-
-ll query(int v, int tl, int tr, int pos) {
-    push(v, tl, tr);  
-    if (tl == tr) 
-        return t[v];  
-    int tm = (tl + tr) / 2;
-    if (pos <= tm)
-        return query(v * 2, tl, tm, pos);
-    return query(v * 2 + 1, tm + 1, tr, pos);
-}
-
-void solve() {
-    int q;
-    cin >> n >> q;
-    ll a[n];
-    for (int i = 0; i < n; i++)
-        cin >> a[i];
-    build(a, 1, 0, n-1);
-    while (q--) {
-        int m;
-        cin >> m;
-        if (m == 2) {
-            int k;
-            cin >> k;
-            k--;
-            cout <<query(1, 0, n-1, k) << endl;
-        }
-        else {
-            int l, r;
-            ll u;
-            cin >> l >> r >> u;
-            l--, r--;
-            updateRange (1, 0, n-1, l, r, u);
-        }
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Ada and Behives.cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Ada and Behives.cpp
deleted file mode 100644
index a4aa364..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Ada and Behives.cpp	
+++ /dev/null
@@ -1,111 +0,0 @@
-//https://www.spoj.com/problems/ADABEHIVE/en/
-#include <bits/stdc++.h>
-using namespace std;
-using ll = long long;
-const int MAXN = 2000;
-
-ll t[4 * MAXN][4 * MAXN];
-ll a[MAXN][MAXN];
-int n, m;
-
-void build_y(int vx, int lx, int rx, int vy, int ly, int ry) {
-    if (ly == ry) {
-        if (lx == rx) {
-            t[vx][vy] = a[lx][ly];
-        } else {
-            t[vx][vy] = t[vx * 2][vy] + t[vx * 2 + 1][vy];
-        }
-    } else {
-        int my = (ly + ry) / 2;
-        build_y(vx, lx, rx, vy * 2, ly, my);
-        build_y(vx, lx, rx, vy * 2 + 1, my + 1, ry);
-        t[vx][vy] = t[vx][vy * 2] + t[vx][vy * 2 + 1];
-    }
-}
-
-void build_x(int vx, int lx, int rx) {
-    if (lx != rx) {
-        int mx = (lx + rx) / 2;
-        build_x(vx * 2, lx, mx);
-        build_x(vx * 2 + 1, mx + 1, rx);
-    }
-    build_y(vx, lx, rx, 1, 0, m - 1);
-}
-
-ll sum_y(int vx, int vy, int tly, int try_, int ly, int ry) {
-    if (ly > ry) return 0;
-    if (ly == tly && try_ == ry) return t[vx][vy];
-    int tmy = (tly + try_) / 2;
-    return sum_y(vx, vy * 2, tly, tmy, ly, min(ry, tmy)) +
-           sum_y(vx, vy * 2 + 1, tmy + 1, try_, max(ly, tmy + 1), ry);
-}
-
-ll sum_x(int vx, int tlx, int trx, int lx, int rx, int ly, int ry) {
-    if (lx > rx) return 0;
-    if (lx == tlx && trx == rx) return sum_y(vx, 1, 0, m - 1, ly, ry);
-    int tmx = (tlx + trx) / 2;
-    return sum_x(vx * 2, tlx, tmx, lx, min(rx, tmx), ly, ry) +
-           sum_x(vx * 2 + 1, tmx + 1, trx, max(lx, tmx + 1), rx, ly, ry);
-}
-
-void update_y(int vx, int lx, int rx, int vy, int ly, int ry, int x, int y, ll new_val) {
-    if (ly == ry) {
-        if (lx == rx)
-            t[vx][vy] = t[vx][vy] + new_val;
-        else
-            t[vx][vy] = t[vx * 2][vy] + t[vx * 2 + 1][vy];
-    } else {
-        int my = (ly + ry) / 2;
-        if (y <= my)
-            update_y(vx, lx, rx, vy * 2, ly, my, x, y, new_val);
-        else
-            update_y(vx, lx, rx, vy * 2 + 1, my + 1, ry, x, y, new_val);
-        t[vx][vy] = t[vx][vy * 2] + t[vx][vy * 2 + 1];
-    }
-}
-
-void update_x(int vx, int lx, int rx, int x, int y, ll new_val) {
-    if (lx != rx) {
-        int mx = (lx + rx) / 2;
-        if (x <= mx)
-            update_x(vx * 2, lx, mx, x, y, new_val);
-        else
-            update_x(vx * 2 + 1, mx + 1, rx, x, y, new_val);
-    }
-    update_y(vx, lx, rx, 1, 0, m - 1, x, y, new_val);
-}
-
-void solve() {
-    int q;
-    cin >> n >> m >> q;
-    for (int i = 0; i < n; i++) {
-        for (int j = 0; j < m; j++) {
-            cin >> a[i][j];
-        }
-    }
-    build_x(1, 0, n - 1);
-
-    for (int i = 0; i < q; i++) {
-        int p;
-        cin >> p;
-        if (p == 1) {
-            int x, y, val;
-            cin >> x >> y >> val;
-            x--, y--;
-            update_x(1, 0, n - 1, x, y, val);
-        } else {
-            int x1, y1, x2, y2;
-            cin >> x1 >> y1 >> x2 >> y2;
-            x1--; y1--; x2--; y2--;
-            ll res = sum_x(1, 0, n - 1, x1, x2, y1, y2);
-            cout << res << endl;
-        }
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Ant colony.cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Ant colony.cpp
deleted file mode 100644
index 520bc73..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Ant colony.cpp	
+++ /dev/null
@@ -1,99 +0,0 @@
-//https://codeforces.com/contest/474/problem/F
-#include <bits/stdc++.h>
-using namespace std;
-#define ll long long
-const int MOD = 1e9 + 7;
-const int MAXN = 1e5 + 5;
-
-ll n, t_gcd[4*MAXN], t_min[4*MAXN];
-ll a[MAXN];
-map<int, vector<int>> pos;
-
-void build_gcd(ll a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t_gcd[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        build_gcd(a, v*2, tl, tm);
-        build_gcd(a, v*2+1, tm+1, tr);
-        t_gcd[v] = __gcd(t_gcd[v*2], t_gcd[v*2+1]);
-    }
-}
-
-void build_min(ll a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t_min[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        build_min(a, v*2, tl, tm);
-        build_min(a, v*2+1, tm+1, tr);
-        t_min[v] = min(t_min[v*2], t_min[v*2+1]);
-    }
-}
-
-ll query_gcd(int v, int tl, int tr, int l, int r) {
-    if (l > r)
-        return 0;
-    if (l == tl && r == tr) {
-        return t_gcd[v];
-    }
-    int tm = (tl + tr) / 2;
-    ll p1 = query_gcd(v*2, tl, tm, l, min(r, tm));
-    ll p2 = query_gcd(v*2+1, tm+1, tr, max(l, tm+1), r);
-    return __gcd(p1, p2);
-}
-
-ll query_min(int v, int tl, int tr, int l, int r) {
-    if (l > r)
-        return LLONG_MAX;
-    if (l == tl && r == tr) {
-        return t_min[v];
-    }
-    int tm = (tl + tr) / 2;
-    ll p1 = query_min(v*2, tl, tm, l, min(r, tm));
-    ll p2 = query_min(v*2+1, tm+1, tr, max(l, tm+1), r);
-    return min(p1, p2);
-}
-
-int count_values(int val, int l, int r) {
-    if (!pos.count(val)) return 0;
-    const vector<int>& vec = pos[val];
-    auto it1 = lower_bound(vec.begin(), vec.end(), l);
-    auto it2 = upper_bound(vec.begin(), vec.end(), r);
-    return it2 - it1;
-}
-
-void solve() {
-    cin >> n;
-    for (int i = 0; i < n; i++) {
-        cin >> a[i];
-        pos[a[i]].push_back(i);
-    }
-    build_gcd(a, 1, 0, n-1);
-    build_min(a, 1, 0, n-1);
-
-    int t;
-    cin >> t;
-    while (t--) {
-        int l, r;
-        cin >> l >> r;
-        l--, r--;
-
-        ll gcd_val = query_gcd(1, 0, n-1, l, r);
-        ll min_val = query_min(1, 0, n-1, l, r);
-
-        if (gcd_val == min_val) {
-            int count = count_values(gcd_val, l, r);
-            cout << (r - l + 1 - count) << '\n';
-        } else {
-            cout << (r - l + 1) << '\n';
-        }
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Catapult The Ball.cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Catapult The Ball.cpp
deleted file mode 100644
index 6a18993..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Catapult The Ball.cpp	
+++ /dev/null
@@ -1,53 +0,0 @@
-//https://www.spoj.com/problems/THRBL/cstart=10
-#include <iostream>
-#include <algorithm>
-using namespace std;
-typedef long long ll;
-int t[50001*4];
-void buildST(int a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        buildST(a, v*2, tl, tm);
-        buildST(a, v*2+1, tm+1, tr);
-        t[v] = max(t[v*2] , t[v*2+1]);
-    }
-}
-void build(int a[],int n) {
-    buildST(a,1,0,n-1);
-}
-int sumST(int v, int tl, int tr, int l, int r) {
-    if (l > r)
-        return 0;
-    if (l == tl && r == tr) {
-        return t[v];
-    }
-    int tm = (tl + tr) / 2;
-    return max(sumST(v*2, tl, tm, l, min(r, tm))
-           , sumST(v*2+1, tm+1, tr, max(l, tm+1), r));
-}
-int sum(int n, int l, int r) {
-    return sumST(1,0,n-1,l,r);
-}
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    int arr[50001];
-    int n,m;
-    cin>>n>>m;
-    for(int i=0;i<n;i++)
-        cin>>arr[i];
-    build(arr,n);
-    int c=0;
-    while(m--) {
-        int l,r;
-        cin>>l>>r;
-        l--;r--;
-        if(arr[l]>=sum(n,l+1,r-1))
-            c++;
-    }
-    cout<<c<<"\n";
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/CumulativeSumQuery.java b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/CumulativeSumQuery.java
deleted file mode 100644
index c38719a..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/CumulativeSumQuery.java
+++ /dev/null
@@ -1,154 +0,0 @@
-//https://www.spoj.com/problems/CSUMQ/
-import java.util.*;
-import java.io.*;
-
-public class CumulativeSumQuery {
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		int n = in.nextInt();
-		long[] arr = new long[n];
-		for (int i = 0; i < n; i++)
-			arr[i] = in.nextLong();
-		SegmentTree st = new SegmentTree(arr);
-		int q = in.nextInt();
-		for (int i = 0; i < q; i++) {
-			int l = in.nextInt();
-			int r = in.nextInt();
-		System.out.println(st.getValor(l, r+1));
-		}
-
-	}
-
-	static class SegmentTree {
-		private long[] valores;
-		private int izq[], der[], cotas[][], c;
-		private int[] cuentas;
-		private int N;
-		private long[] valoresIniciales;
-
-		public SegmentTree(long[] valoresIniciales) {
-			this.valoresIniciales = valoresIniciales;
-			N = valoresIniciales.length;
-			int n = N * 2;
-			valores = new long[n];
-			c = 0;
-			cotas = new int[n][2];
-			izq = new int[n];
-			der = new int[n];
-			cuentas = new int[N + 1];
-			initTree(0, N);
-		}
-
-		private int initTree(int desde, int hasta) {
-			int C = c++;
-			cotas[C][0] = desde;
-			cotas[C][1] = hasta;
-			if (hasta - desde > 1) {
-				int p = (hasta + desde) / 2;
-				izq[C] = initTree(desde, p);
-				der[C] = initTree(p, hasta);
-				valores[C] = valores[izq[C]] + valores[der[C]];
-			} else
-				valores[C] = valoresIniciales[desde];
-			return C;
-		}
-
-		// Acepta 0 indexado y funciona como un array
-		public void setValor(int index, long val) {
-			int C = 0, i = 0;
-			cuentas[C++] = i;
-			for (; cotas[i][1] - cotas[i][0] > 1;)
-				if (cotas[izq[i]][0] <= index && cotas[izq[i]][1] > index)
-					cuentas[C++] = (i = izq[i]);
-				else
-					cuentas[C++] = (i = der[i]);
-			valores[i] = val;
-			for (C = C - 2; C >= 0; C--) {
-				i = cuentas[C];
-				long l = valores[izq[i]], r = valores[der[i]];
-				valores[i] = l + r;
-			}
-		}
-
-		// [desde,hasta)
-		// Si desde==hasta se yuquea
-		public long getValor(int desde, int hasta) {
-			return getValor(0, desde, hasta);
-		}
-
-		private long getValor(int i, int desde, int hasta) {
-			if (cotas[i][0] == desde && cotas[i][1] == hasta)
-				return valores[i];
-			if (desde >= cotas[izq[i]][0] && hasta <= cotas[izq[i]][1])
-				return getValor(izq[i], desde, hasta);
-			if (desde >= cotas[der[i]][0] && hasta <= cotas[der[i]][1])
-				return getValor(der[i], desde, hasta);
-			return getValor(izq[i], desde, cotas[izq[i]][1]) + getValor(der[i], cotas[der[i]][0], hasta);
-		}
-
-		public String toString() {
-			String res = "";
-			for (int i = 0; i < cotas.length; i++)
-				res += Arrays.toString(cotas[i]) + ":" + valores[i] + " ,  ";
-			return res;
-		}
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/D-query.cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/D-query.cpp
deleted file mode 100644
index 6b0e978..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/D-query.cpp
+++ /dev/null
@@ -1,101 +0,0 @@
-//https://www.spoj.com/problems/DQUERY/
-using namespace std;
-#include <bits/stdc++.h>
-#include <iostream>
-#include <vector>
-#include <algorithm>
-#include <climits>
-#include <iomanip>
-#include <utility>
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define MAXN 300001
-
-int n, t[4 * MAXN];
-void build(int a[], int v = 1, int tl = 0, int tr = n - 1)
-{
-    if (tl == tr)
-        t[v] = a[tl];
-    else
-    {
-        int tm = (tl + tr) / 2;
-        build(a, v * 2, tl, tm);
-        build(a, v * 2 + 1, tm + 1, tr);
-        t[v] = t[v * 2] + t[v * 2 + 1];
-    }
-}
-
-int query(int v, int tl, int tr, int l, int r)
-{
-    if (l > r)
-        return 0;
-    if (l == tl && r == tr)
-        return t[v];
-    int tm = (tl + tr) / 2;
-    return query(v * 2, tl, tm, l, min(r, tm)) + query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);
-}
-
-void update(int v, int tl, int tr, int pos, int new_val)
-{
-    if (tl == tr)
-        t[v] = new_val;
-    else
-    {
-        int tm = (tl + tr) / 2;
-        if (pos <= tm)
-            update(v * 2, tl, tm, pos, new_val);
-        else
-            update(v * 2 + 1, tm + 1, tr, pos, new_val);
-        t[v] = t[v * 2] + t[v * 2 + 1];
-    }
-}
-
-
-int A[MAXN];
-int last[1000005];
-void solve()
-{
-    cin >> n;
-    vector<int> arr(n);
-    fori(i, 0, n)
-            cin >>arr[i];
-    fill(A, A + n, 1);
-    fill(last, last + 1000005, -1);
-    build(A);
-    int q;
-    cin >> q;
-    vector<pair<pair<int, int>, int>> queries(q);
-    fori(i, 0, q)
-    {
-        cin >> queries[i].first.second >> queries[i].first.first;
-        queries[i].second = i;
-    }
-    vector<int> ans(q);
-    sort(queries.begin(), queries.end());
-    int c = 0;
-    fori(i, 0, n)
-    {
-        int val = arr[i];
-        if (last[val] == -1)
-            last[val] = i;
-        else
-        {
-            update(1, 0, n - 1, last[val], 0);
-            last[val] = i;
-        }
-        while (queries[c].first.first == i + 1)
-        {
-            ans[queries[c].second] = query(1, 0, n - 1, queries[c].first.second - 1, i);
-            c++;
-        }
-    }
-    for (const auto &i : ans)
-        cout << i << ln;
-}
-int main()
-{
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    solve();
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Distinct Characters Queries.cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Distinct Characters Queries.cpp
deleted file mode 100644
index e15b477..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Distinct Characters Queries.cpp	
+++ /dev/null
@@ -1,79 +0,0 @@
-//https://codeforces.com/problemset/problem/1234/D
-#include <bits/stdc++.h>
-using namespace std;
-const int MAXN = 1e5 + 5;
-
-int n, t[4*MAXN];
-
-void build(const string& s, int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = 1 << (s[tl] - 'a');
-        return;
-    }
-    int tm = (tl + tr) / 2;
-    build(s, v * 2, tl, tm);
-    build(s, v * 2 + 1, tm + 1, tr);
-    t[v] = t[v * 2] | t[v * 2 + 1];
-}
-
-int query(int v, int tl, int tr, int l, int r) {
-    if (l > r)
-        return 0;
-    if (l == tl && r == tr) {
-        return t[v];
-    }
-    int tm = (tl + tr) / 2;
-    return query(v * 2, tl, tm, l, min(r, tm)) |
-           query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);
-}
-
-void update(int v, int tl, int tr, int pos, char new_char) {
-    if (tl == tr) {
-        t[v] = 1 << (new_char - 'a');
-        return;
-    }
-    int tm = (tl + tr) / 2;
-    if (pos <= tm)
-        update(v * 2, tl, tm, pos, new_char);
-    else
-        update(v * 2 + 1, tm + 1, tr, pos, new_char);
-    t[v] = t[v * 2] | t[v * 2 + 1];
-}
-
-int countBits(int mask) {
-    return __builtin_popcount(mask);
-}
-
-void solve() {
-    string s;
-    cin >> s;
-    n = s.size();
-    int q;
-    cin >> q;
-    build(s, 1, 0, n - 1);
-    for (int i = 0; i < q; i++) {
-        int type;
-        cin >> type;
-        if (type == 1) {
-            int pos;
-            char c;
-            cin >> pos >> c;
-            pos--;
-            update(1, 0, n - 1, pos, c);
-        }
-        else {
-            int l, r;
-            cin >> l >> r;
-            l--, r--;
-            int mask = query(1, 0, n - 1, l, r);
-            cout << countBits(mask) << endl;
-        }
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Dynamic Range Minimum Queries.cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Dynamic Range Minimum Queries.cpp
deleted file mode 100644
index 7c53e9f..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Dynamic Range Minimum Queries.cpp	
+++ /dev/null
@@ -1,75 +0,0 @@
-//https://vjudge.net/problem/CSES-1649
-#include <iostream>
-#include <algorithm>
-#include <exception>
-using namespace std;
-typedef long long ll;
-int* t;
-void buildST(int a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        buildST(a, v*2, tl, tm);
-        buildST(a, v*2+1, tm+1, tr);
-        t[v] = min(t[v*2] ,t[v*2+1]);
-    }
-}
-void build(int a[], int n) {
-    buildST(a,1,0,n-1);
-}
-int sumQ(int v, int tl, int tr, int l, int r) {
-    if (l > r)
-        return 2140000000;
-    if (l == tl && r == tr) {
-        return t[v];
-    }
-    int tm = (tl + tr) / 2;
-    return min(sumQ(v*2, tl, tm, l, min(r, tm))
-           , sumQ(v*2+1, tm+1, tr, max(l, tm+1), r));
-}
-int sum(int n,int l, int r) {
-    return sumQ(1,0,n-1,l,r);
-}
-void updateQ(int v, int tl, int tr, int pos, int new_val) {
-    if (tl == tr) {
-        t[v]= new_val;
-    } else {
-        int tm = (tl + tr) / 2;
-        if (pos <= tm)
-            updateQ(v*2, tl, tm, pos, new_val);
-        else
-            updateQ(v*2+1, tm+1, tr, pos, new_val);
-        t[v] = min(t[v*2] , t[v*2+1]);
-    }
-}
-void update(int n, int pos, int x) {
-    updateQ(1,0,n-1,pos,x);
-}
-int main() {
-    int n,q;
-    cin>>n>>q;
-    int* a=new int[n];
-    t=new int [4*n];
-    for (int i = 0; i < n; i++)
-        cin>>a[i];
-    build(a,n);
-    for (int i = 0; i < q; i++) {
-        int type;
-        cin>>type;
-        if (type == 1) {
-            int j,x;
-            cin>>j>>x;
-            update(n,j-1,x);
-        }
-        else {
-            int l,r;
-            cin>>l>>r;
-            cout<<sum(n,l-1,r-1)<<endl;
-        }
-    }
-    delete[] a;
-    delete[] t;
-    return 0;
-
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Dynamic Range Sum Queries.cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Dynamic Range Sum Queries.cpp
deleted file mode 100644
index 60fb3f0..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Dynamic Range Sum Queries.cpp	
+++ /dev/null
@@ -1,76 +0,0 @@
-//https://cses.fi/problemset/result/12087918/
-#include <bits/stdc++.h>
-using namespace std;
-using ll = long long;
-
-const int MAXN = 200000;
-
-ll t[4 * MAXN];
-
-void build(ll a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        build(a, v*2, tl, tm);
-        build(a, v*2+1, tm+1, tr);
-        t[v] = t[v*2] + t[v*2+1];
-    }
-}
-
-ll sum(int v, int tl, int tr, int l, int r) {
-    if (l > r)
-        return 0;
-    if (l == tl && r == tr) {
-        return t[v];
-    }
-    int tm = (tl + tr) / 2;
-    return sum(v*2, tl, tm, l, min(r, tm))
-           + sum(v*2+1, tm+1, tr, max(l, tm+1), r);
-}
-
-void update(int v, int tl, int tr, int pos, ll new_val) {
-    if (tl == tr) {
-        t[v] = new_val;
-    } else {
-        int tm = (tl + tr) / 2;
-        if (pos <= tm)
-            update(v*2, tl, tm, pos, new_val);
-        else
-            update(v*2+1, tm+1, tr, pos, new_val);
-        t[v] = t[v*2] + t[v*2+1];
-    }
-}
-void solve() {
-    int n, q;
-    cin >> n >> q;
-    ll a[n];
-    for (int i = 0; i < n; i++)
-        cin >> a[i];
-    build(a, 1, 0, n-1);
-    while (q--) {
-        int x;
-        cin >> x;
-        if (x == 1) {
-            int k;
-            ll u;
-            cin >> k >> u;
-            k--;
-            update(1, 0, n-1, k, u);
-        }
-        else {
-            int l, r;
-            cin >> l >> r;
-            l--, r--;
-            cout << sum(1, 0, n-1, l, r) << endl;
-        }
-    }
-
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Flowers.cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Flowers.cpp
deleted file mode 100644
index 3a3c06b..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Flowers.cpp
+++ /dev/null
@@ -1,75 +0,0 @@
-//https://atcoder.jp/contests/dp/tasks/dp_q
-
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(),A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define MAXN 200001
-
-int n;
-long long A[MAXN], t[4 * MAXN];;
-
-void build(long long a[], int v = 1, int tl = 0, int tr = n ) {
-    if (tl == tr)
-        t[v] = a[tl];
-    else {
-        int tm = (tl + tr) >> 1;
-        build(a, v << 1, tl, tm);
-        build(a, (v << 1) + 1, tm + 1, tr);
-        t[v] = max(t[v << 1], t[(v << 1) + 1]);
-    }
-}
-
-long long query(int v, int tl, int tr, int l, int r) {
-    if (l > r)
-        return -1;
-    if (l == tl && r == tr)
-        return t[v];
-    int tm = (tl + tr) >> 1;
-    return max(query(v << 1, tl, tm, l, min(r, tm)), query((v << 1) + 1, tm + 1, tr, max(l, tm + 1), r));
-}
-
-void update(int v, int tl, int tr, int pos, long long new_val) {
-    if (tl == tr)
-        t[v] = new_val;
-    else {
-        int tm = (tl + tr) >> 1;
-        if (pos <= tm)
-            update(v << 1, tl, tm, pos, new_val);
-        else
-            update((v << 1) + 1, tm + 1, tr, pos, new_val);
-        t[v] = max(t[v << 1], t[(v << 1) + 1]);
-    }
-}
-
-
-void solve() {
-    cin >> n;
-    vector<int> H(n);
-    vector<int> V(n);
-    fori(i, 0, n)
-        cin >> H[i];
-    fori(i, 0, n)
-        cin >> V[i];
-
-    memset(A, 0, sizeof(A));
-    A[H[n - 1]] = V[n - 1];
-    build(A);
-    for (int i = n - 2; i >= 0; i--) {
-        int val = H[i];
-        long long  q = query(1, 0, n, val, n);
-        update(1, 0, n , val, V[i] + q);
-    }
-    cout << t[1] << ln;
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t = 1;
-    while (t--)
-        solve();
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Forest Queries.cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Forest Queries.cpp
deleted file mode 100644
index e534146..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Forest Queries.cpp	
+++ /dev/null
@@ -1,78 +0,0 @@
-//https://cses.fi/problemset/task/1652/
-#include <bits/stdc++.h>
-using namespace std;
-using ll = long long;
-const int MAXN = 1000;
-
-int t[4 * MAXN][4 * MAXN];
-int a[MAXN][MAXN];
-int n, m;
-
-void build_y(int vx, int lx, int rx, int vy, int ly, int ry) {
-    if (ly == ry) {
-        if (lx == rx) {
-            t[vx][vy] = a[lx][ly];
-        } else {
-            t[vx][vy] = t[vx * 2][vy] + t[vx * 2 + 1][vy];
-        }
-    } else {
-        int my = (ly + ry) / 2;
-        build_y(vx, lx, rx, vy * 2, ly, my);
-        build_y(vx, lx, rx, vy * 2 + 1, my + 1, ry);
-        t[vx][vy] = t[vx][vy * 2] + t[vx][vy * 2 + 1];
-    }
-}
-
-void build_x(int vx, int lx, int rx) {
-    if (lx != rx) {
-        int mx = (lx + rx) / 2;
-        build_x(vx * 2, lx, mx);
-        build_x(vx * 2 + 1, mx + 1, rx);
-    }
-    build_y(vx, lx, rx, 1, 0, m - 1);
-}
-
-int sum_y(int vx, int vy, int tly, int try_, int ly, int ry) {
-    if (ly > ry) return 0;
-    if (ly == tly && try_ == ry) return t[vx][vy];
-    int tmy = (tly + try_) / 2;
-    return sum_y(vx, vy * 2, tly, tmy, ly, min(ry, tmy)) +
-           sum_y(vx, vy * 2 + 1, tmy + 1, try_, max(ly, tmy + 1), ry);
-}
-
-int sum_x(int vx, int tlx, int trx, int lx, int rx, int ly, int ry) {
-    if (lx > rx) return 0;
-    if (lx == tlx && trx == rx) return sum_y(vx, 1, 0, m - 1, ly, ry);
-    int tmx = (tlx + trx) / 2;
-    return sum_x(vx * 2, tlx, tmx, lx, min(rx, tmx), ly, ry) +
-           sum_x(vx * 2 + 1, tmx + 1, trx, max(lx, tmx + 1), rx, ly, ry);
-}
-
-void solve() {
-    int q;
-    cin >> n >> q;
-    m = n;
-    for (int i = 0; i < n; i++) {
-        for (int j = 0; j < m; j++) {
-            char c;
-            cin >> c;
-            a[i][j] = (c == '.' ? 0 : 1);
-        }
-    }
-    build_x(1, 0, n - 1);
-
-    for (int i = 0; i < q; i++) {
-        int y1, x1, y2, x2;
-        cin >> y1 >> x1 >> y2 >> x2;
-        y1--; y2--; x1--; x2--;
-        int res = sum_x(1, 0, n - 1, y1, y2, x1, x2);
-        cout << res << endl;
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Hotel Queries .cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Hotel Queries .cpp
deleted file mode 100644
index 918852f..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Hotel Queries .cpp	
+++ /dev/null
@@ -1,66 +0,0 @@
-//https://vjudge.net/problem/CSES-1143
-#include <iostream>
-#include <algorithm>
-#define samuel ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0)
-using namespace std;
-typedef long long ll;
-ll* t;
-void buildST(int a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        buildST(a, v*2, tl, tm);
-        buildST(a, v*2+1, tm+1, tr);
-        t[v] = max(t[v*2],t[v*2+1]);
-    }
-}
-void build(int a[],int n) {
-    buildST(a,1,0,n-1);
-}
-int get_firstST(int v, int l, int r, int x) {
-    if(x>t[v]) return -1;
-    if(l==r && x<=t[v]) return l;
-    int mid = (l+r)/2;
-    int left=t[2*v];
-    if(x<=left) return get_firstST(2*v,l,mid,x);
-    return get_firstST(2*v+1,mid+1,r,x);
-}
-int first(int n,int x) {
-    return get_firstST(1,0,n-1,x);
-}
-void updateST(int v, int tl, int tr, int pos, ll new_val) {
-    if (tl == tr) {
-        t[v] -= new_val;
-    } else {
-        int tm = (tl + tr) / 2;
-        if (pos <= tm)
-            updateST(v*2, tl,   tm, pos, new_val);
-        else
-            updateST(v*2+1, tm+1, tr, pos, new_val);
-        t[v] = max(t[v*2] , t[v*2+1]);
-    }
-}
-void update(int n, int pos, int x) {
-    updateST(1,0,n-1,pos,x);
-}
-int main() {
-    samuel;
-    int n,q;
-    cin>>n>>q;
-    auto a=new int[n];
-    t=new ll[4*n];
-    for(int i=0;i<n;i++)
-        cin>>a[i];
-    build(a,n);
-    for(int i=0;i<q;i++) {
-        int val;
-        cin>>val;
-        int j=first(n,val);
-        cout<<j+1<<" ";
-        if(j!=-1) update(n,j,val);
-    }
-    delete[] a;
-    delete[] t;
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/K-query.cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/K-query.cpp
deleted file mode 100644
index 0ee7b1f..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/K-query.cpp
+++ /dev/null
@@ -1,55 +0,0 @@
-//https://vjudge.net/problem/SPOJ-KQUERY
-#include <bits/stdc++.h>
-using namespace std;
-using ll = long long;
-const int MAXN = 30005;
-const int MOD = 1000000007;
-
-vector<int> t[4*MAXN];
-
-void build(int a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = vector<int>(1, a[tl]);
-    } else {
-        int tm = (tl + tr) / 2;
-        build(a, v*2, tl, tm);
-        build(a, v*2+1, tm+1, tr);
-        merge(t[v*2].begin(), t[v*2].end(), t[v*2+1].begin(), t[v*2+1].end(),
-              back_inserter(t[v]));
-    }
-}
-
-int query(int v, int tl, int tr, int l, int r, int k) {
-    if (l > r)
-        return 0;
-    if (l == tl && r == tr) {
-        return t[v].end() - upper_bound(t[v].begin(), t[v].end(), k);
-    }
-    int tm = (tl + tr) / 2;
-    return query(v*2, tl, tm, l, min(r, tm), k) +
-           query(v*2+1, tm+1, tr, max(l, tm+1), r, k);
-}
-
-void solve() {
-    int n;
-    cin >> n;
-    int a[n];
-    for (int i = 0; i < n; i++)
-        cin >> a[i];
-    build(a, 1, 0, n-1);
-    int q;
-    cin >> q;
-    while (q--) {
-        int l, r, k;
-        cin >> l >> r >> k;
-        l--, r--;
-        cout << query(1, 0, n - 1, l, r, k) << "\n";
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Potentiometers.java b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Potentiometers.java
deleted file mode 100644
index d2682c0..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Potentiometers.java
+++ /dev/null
@@ -1,173 +0,0 @@
-import java.util.*;
-import java.io.*;
-
-public class Potentiometers {
-
-	public static void main(String[] args) throws IOException {
-		Input in = new Input(System.in);
-		PrintWriter out = new PrintWriter(System.out);
-		int caso = 1;
-		while (true) {
-			int n = in.nextInt();
-			if (n == 0)
-				break;
-			if (caso > 1)
-				out.println();
-			out.println("Case " + caso + ":");
-			long[] arr = new long[n];
-			for (int i = 0; i < n; i++)
-				arr[i] = in.nextLong();
-			SegmentTree st = new SegmentTree(arr);
-			while (true) {
-				String line = in.next();
-				if (line.equals("END"))
-					break;
-				if (line.equals("M")) {
-					int r = in.nextInt();
-					int l = in.nextInt();
-					out.println(st.getValor(r - 1, l));
-				} else {
-					int pos = in.nextInt();
-					int val = in.nextInt();
-					st.setValor(pos - 1, val);
-				}
-
-			}
-			caso++;
-		}
-		out.flush();
-		in.close();
-	}
-
-	static class SegmentTree {
-		private long[] valores;
-		private int izq[], der[], cotas[][], c;
-		private int[] cuentas;
-		private int N;
-		private long[] valoresIniciales;
-
-		public SegmentTree(long[] valoresIniciales) {
-			this.valoresIniciales = valoresIniciales;
-			N = valoresIniciales.length;
-			int n = N * 2;
-			valores = new long[n];
-			c = 0;
-			cotas = new int[n][2];
-			izq = new int[n];
-			der = new int[n];
-			cuentas = new int[N + 1];
-			initTree(0, N);
-		}
-
-		private int initTree(int desde, int hasta) {
-			int C = c++;
-			cotas[C][0] = desde;
-			cotas[C][1] = hasta;
-			if (hasta - desde > 1) {
-				int p = (hasta + desde) / 2;
-				izq[C] = initTree(desde, p);
-				der[C] = initTree(p, hasta);
-				valores[C] = valores[izq[C]] + valores[der[C]];
-			} else
-				valores[C] = valoresIniciales[desde];
-			return C;
-		}
-
-		// Acepta 0 indexado y funciona como un array
-		public void setValor(int index, long val) {
-			int C = 0, i = 0;
-			cuentas[C++] = i;
-			for (; cotas[i][1] - cotas[i][0] > 1;)
-				if (cotas[izq[i]][0] <= index && cotas[izq[i]][1] > index)
-					cuentas[C++] = (i = izq[i]);
-				else
-					cuentas[C++] = (i = der[i]);
-			valores[i] = val;
-			for (C = C - 2; C >= 0; C--) {
-				i = cuentas[C];
-				long l = valores[izq[i]], r = valores[der[i]];
-				valores[i] = l + r;
-			}
-		}
-
-		// [desde,hasta)
-		// Si desde==hasta se yuquea
-		public long getValor(int desde, int hasta) {
-			return getValor(0, desde, hasta);
-		}
-
-		private long getValor(int i, int desde, int hasta) {
-			if (cotas[i][0] == desde && cotas[i][1] == hasta)
-				return valores[i];
-			if (desde >= cotas[izq[i]][0] && hasta <= cotas[izq[i]][1])
-				return getValor(izq[i], desde, hasta);
-			if (desde >= cotas[der[i]][0] && hasta <= cotas[der[i]][1])
-				return getValor(der[i], desde, hasta);
-			return getValor(izq[i], desde, cotas[izq[i]][1]) + getValor(der[i], cotas[der[i]][0], hasta);
-		}
-
-		public String toString() {
-			String res = "";
-			for (int i = 0; i < cotas.length; i++)
-				res += Arrays.toString(cotas[i]) + ":" + valores[i] + " ,  ";
-			return res;
-		}
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Range Xor Queries .cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Range Xor Queries .cpp
deleted file mode 100644
index de81269..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Range Xor Queries .cpp	
+++ /dev/null
@@ -1,62 +0,0 @@
-//https://vjudge.net/problem/CSES-1650
-#include <iostream>
-#include <algorithm>
-using namespace std;
-typedef long long ll;
-ll* t;
-void buildST(int a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        buildST(a, v*2, tl, tm);
-        buildST(a, v*2+1, tm+1, tr);
-        t[v] = t[v*2]^t[v*2+1];
-    }
-}
-void build(int a[],int n) {
-    buildST(a,1,0,n-1);
-}
-ll sumST(int v, int tl, int tr, int l, int r) {
-    if (l > r)
-        return 0;
-    if (l == tl && r == tr) {
-        return t[v];
-    }
-    int tm = (tl + tr) / 2;
-    return sumST(v*2, tl, tm, l, min(r, tm))^sumST(v*2+1, tm+1, tr, max(l, tm+1), r);
-}
-ll sum(int n, int l, int r) {
-    return sumST(1,0,n-1,l,r);
-}
-void updateST(int v, int tl, int tr, int pos, ll new_val) {
-    if (tl == tr) {
-        t[v] = new_val;
-    } else {
-        int tm = (tl + tr) / 2;
-        if (pos <= tm)
-            updateST(v*2, tl, tm, pos, new_val);
-        else
-            updateST(v*2+1, tm+1, tr, pos, new_val);
-        t[v] = t[v*2] ^ t[v*2+1];
-    }
-}
-void update(int n, int pos, int x) {
-    updateST(1,0,n-1,pos,x);
-}
-int main() {
-    int n,q;
-    cin>>n>>q;
-    auto a=new int[n];
-    t=new ll[4*n];
-    for(int i=0;i<n;i++)
-        cin>>a[i];
-    build(a,n);
-    for(int i=0;i<q;i++) {
-        int l,r;
-        cin>>l>>r;
-        cout<<sum(n,l-1,r-1)<<endl;
-    }
-    //asdad
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Range sum query.cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Range sum query.cpp
deleted file mode 100644
index 6423778..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Range sum query.cpp	
+++ /dev/null
@@ -1,63 +0,0 @@
-//https://vjudge.net/problem/Gym-379719B
-#include <iostream>
-#include <algorithm>
-using namespace std;
-typedef long long ll;
-ll* t;
-void buildST(int a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        buildST(a, v*2, tl, tm);
-        buildST(a, v*2+1, tm+1, tr);
-        t[v] = t[v*2] + t[v*2+1];
-    }
-}
-void build(int a[],int n) {
-    buildST(a,1,0,n-1);
-}
-ll sumST(int v, int tl, int tr, int l, int r) {
-    if (l > r)
-        return 0;
-    if (l == tl && r == tr) {
-        return t[v];
-    }
-    int tm = (tl + tr) / 2;
-    return sumST(v*2, tl, tm, l, min(r, tm))
-           + sumST(v*2+1, tm+1, tr, max(l, tm+1), r);
-}
-ll sum(int n, int l, int r) {
-    return sumST(1,0,n-1,l,r);
-}
-void updateST(int v, int tl, int tr, int pos, ll new_val) {
-    if (tl == tr) {
-        t[v] = new_val;
-    } else {
-        int tm = (tl + tr) / 2;
-        if (pos <= tm)
-            updateST(v*2, tl, tm, pos, new_val);
-        else
-            updateST(v*2+1, tm+1, tr, pos, new_val);
-        t[v] = t[v*2] + t[v*2+1];
-    }
-}
-void update(int n, int pos, int x) {
-    updateST(1,0,n-1,pos,x);
-}
-int main() {
-    int n,q;
-    cin>>n>>q;
-    auto a=new int[n];
-    t=new ll[4*n];
-    for(int i=0;i<n;i++)
-        cin>>a[i];
-    build(a,n);
-    for(int i=0;i<q;i++) {
-        int l,r;
-        cin>>l>>r;
-        cout<<sum(n,l-1,r-1)<<endl;
-    }
-    //asdad
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Static Range Minimum Queries.cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Static Range Minimum Queries.cpp
deleted file mode 100644
index 06dccd4..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Static Range Minimum Queries.cpp	
+++ /dev/null
@@ -1,57 +0,0 @@
-//https://cses.fi/problemset/result/12087849/
-#include <bits/stdc++.h>
-using namespace std;
-using ll = long long;
-
-const int MAXN = 200000;
-
-int t[4 * MAXN];
-
-void build(int a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        build(a, v * 2, tl, tm);
-        build(a, v * 2 + 1, tm + 1, tr);
-        t[v] = min(t[v * 2], t[v * 2 + 1]);
-    }
-}
-
-int get_min(int v, int tl, int tr, int l, int r) {
-    if (l > r) {
-        return INT_MAX;
-    }
-    if (l == tl && r == tr) {
-        return t[v];
-    }
-    int tm = (tl + tr) / 2;
-    return min(
-        get_min(v * 2, tl, tm, l, min(r, tm)),
-        get_min(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r)
-    );
-}
-
-void solve() {
-    int n, q;
-    cin >> n >> q;
-    int a[n];
-    for (int i = 0; i < n; i++) {
-        cin >> a[i];
-    }
-    build(a, 1, 0, n - 1);
-    while (q--) {
-        int l, r;
-        cin >> l >> r;
-        l--, r--;
-        int res = get_min(1, 0, n - 1, l, r);
-        cout << res << endl;
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Supercomputer.cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Supercomputer.cpp
deleted file mode 100644
index 4489955..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/Supercomputer.cpp
+++ /dev/null
@@ -1,73 +0,0 @@
-//https://open.kattis.com/submissions/15482226
-#include <bits/stdc++.h>
-using namespace std;
-using ll = long long;
-const int MAXN = 1e6 + 5;
-const int MOD = 1e9 + 7;
-
-int n, t[4 * MAXN];
-
-void build(int a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        build(a, v*2, tl, tm);
-        build(a, v*2+1, tm+1, tr);
-        t[v] = t[v*2] + t[v*2+1];
-    }
-}
-
-int query(int v, int tl, int tr, int l, int r) {
-    if (l > r)
-        return 0;
-    if (l == tl && r == tr) {
-        return t[v];
-    }
-    int tm = (tl + tr) / 2;
-    return query(v*2, tl, tm, l, min(r, tm))
-           + query(v*2+1, tm+1, tr, max(l, tm+1), r);
-}
-
-void update(int v, int tl, int tr, int pos) {
-    if (tl == tr) {
-        t[v] ^= 1;
-    } else {
-        int tm = (tl + tr) / 2;
-        if (pos <= tm)
-            update(v*2, tl, tm, pos);
-        else
-            update(v*2+1, tm+1, tr, pos);
-        t[v] = t[v*2] + t[v*2+1];
-    }
-}
-
-void solve() {
-    int q;
-    cin >> n >> q;
-    int a[n] = {0};
-    build (a, 1, 0, n-1);
-    for (int i = 0; i < q; i++) {
-        char c;
-        cin >> c;
-        if (c == 'C') {
-           int l, r;
-            cin >> l >> r;
-            l--, r--;
-            cout << query(1, 0, n-1, l, r) << endl;
-        }
-        else {
-            int idx;
-            cin >> idx;
-            idx--;
-            update(1, 0, n-1, idx);
-        }
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/XeniaAndBitOperations.cpp b/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/XeniaAndBitOperations.cpp
deleted file mode 100644
index bc60c9a..0000000
--- a/Problemas/AdvancedDataStructures/SegmentTree/SegmentTreeSimple/XeniaAndBitOperations.cpp
+++ /dev/null
@@ -1,76 +0,0 @@
-//https://codeforces.com/contest/339/problem/D
-#include <bits/stdc++.h>
-using namespace std;
-using ll = long long;
-#define MAXN (1 << 17)
-
-int n;
-ll t[4 * MAXN];
-
-bool isOrLevel(int level) {
-    return level % 2 == 1;
-}
-
-void build(ll a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-        return;
-    }
-
-    int tm = (tl + tr) / 2;
-    build(a, v * 2, tl, tm);
-    build(a, v * 2 + 1, tm + 1, tr);
-
-    int height = 31 - __builtin_clz(tr - tl + 1); // altura donde esta el numero ubicado en el arbol 
-    if (isOrLevel(height)) {
-        t[v] = t[v * 2] | t[v * 2 + 1];
-    } else {
-        t[v] = t[v * 2] ^ t[v * 2 + 1];
-    }
-}
-
-void update(int v, int tl, int tr, int pos, ll new_val) {
-    if (tl == tr) {
-        t[v] = new_val;
-        return;
-    }
-
-    int tm = (tl + tr) / 2;
-    if (pos <= tm)
-        update(v * 2, tl, tm, pos, new_val);
-    else
-        update(v * 2 + 1, tm + 1, tr, pos, new_val);
-
-    int height = 31 - __builtin_clz(tr - tl + 1);
-    if (isOrLevel(height)) {
-        t[v] = t[v * 2] | t[v * 2 + 1];
-    } else {
-        t[v] = t[v * 2] ^ t[v * 2 + 1];
-    }
-}
-
-void solve() {
-    int m;
-    cin >> n >> m;
-    ll a[1<<n];
-    for (int i = 0; i < (1 << n); i++) {
-        cin >> a[i];
-    }
-
-    build(a, 1, 0, (1 << n) - 1);
-
-    for (int i = 0; i < m; i++) {
-        int p;
-        ll b;
-        cin >> p >> b;
-        update(1, 0, (1 << n) - 1, p - 1, b);
-        cout << t[1] << '\n';
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/UnionFind/HedgeMazes.cpp b/Problemas/AdvancedDataStructures/UnionFind/HedgeMazes.cpp
deleted file mode 100644
index c33f7e9..0000000
--- a/Problemas/AdvancedDataStructures/UnionFind/HedgeMazes.cpp
+++ /dev/null
@@ -1,97 +0,0 @@
-//https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3785
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(),A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-
-
-int n, tiempo;
-vector<vector<int> > adj;
-vector<int> d, low, pi, Size;
-
-int Find(int u) {
-    int aux = u;
-    while (u != pi[u])
-        u = pi[u];
-    while (aux != pi[aux]) {
-        aux = pi[aux];
-        pi[aux] = u;
-    }
-    return u;
-}
-
-void Union(int u, int v) {
-    int x = Find(u);
-    int y = Find(v);
-    if (x == y)
-        return;
-    if (Size[x] < Size[y]) {
-        pi[x] = y;
-        Size[y] += Size[x];
-    } else {
-        pi[y] = x;
-        Size[x] += Size[y];
-    }
-}
-
-
-void dfs(int u, int par) {
-    d[u] = low[u] = tiempo++;
-    for (const auto &v: adj[u]) {
-        if (v == par)
-            continue;
-        if (d[v] > 0)
-            low[u] = min(low[u], d[v]);
-        else {
-            dfs(v, u);
-            low[u] = min(low[u], low[v]);
-            if (low[v] > d[u])
-                Union(v, u);
-        }
-    }
-}
-
-
-void solve() {
-    while (true) {
-        int m, q;
-        cin >> n >> m >> q;
-        if (n == 0 && m == 0 && q == 0)break;
-        adj.assign(n, vector<int>());
-        fori(i, 0, m) {
-            int a, b;
-            cin >> a >> b;
-            a--;
-            b--;
-            adj[a].push_back(b);
-            adj[b].push_back(a);
-        }
-        d.assign(n, 0);
-        low.assign(n, 0);
-        pi.assign(n, 0);
-        Size.assign(n, 1);
-        tiempo = 1;
-        fori(i, 0, n)
-            pi[i] = i;
-        dfs(0, -1);
-        fori(i, 0, q) {
-            int a, b;
-            cin >> a >> b;
-            a--;
-            b--;
-            cout << (Find(a) == Find(b) ? "Y" : "N") << ln;
-        }
-        cout << "-" << ln;
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t = 1;
-    while (t--)
-        solve();
-    return 0;
-}
diff --git a/Problemas/AdvancedDataStructures/UnionFind/Nature.java b/Problemas/AdvancedDataStructures/UnionFind/Nature.java
deleted file mode 100644
index 6edb924..0000000
--- a/Problemas/AdvancedDataStructures/UnionFind/Nature.java
+++ /dev/null
@@ -1,97 +0,0 @@
-//https://vjudge.net/problem/UVA-10685
-import java.util.*;
-import java.io.*;
-public class Main {
-    static int[] pi;
-    static int[] size;
-    public static void main(String[] args) {
-        Scanner sc = new Scanner();
-        PrintWriter pw = new PrintWriter(System.out);
-        while (true){
-            int n=sc.nextInt();
-            int m=sc.nextInt();
-            pi=new int[n];
-            size=new int[n];
-            if(n==0)break;
-            HashMap<String,Integer> map=new HashMap<>();
-            for(int i =0;i<n;i++) {
-                map.put(sc.next(), i);
-                pi[i]=i;
-                size[i]=1;
-            }
-            for (int i = 0; i < m; i++)
-                union(map.get(sc.next()),map.get(sc.next()));
-            int ans=0;
-            for (int i = 0; i < n; i++)
-                ans=Math.max(ans,size[i]);
-            System.out.println(ans);
-        }
-    }
-    static int find(int x){
-        int y=x;
-        while(x!=pi[x])
-            x=pi[x];
-        while (y!=pi[y]){
-            y=pi[y];
-            pi[y]=x;
-        }
-        return x;
-    }
-    static void union(int a, int b){
-        int x=find(a),y=find(b);
-        if (x==y)
-            return;
-        if(size[x]<size[y]){
-            pi[x]=y;
-            size[y]+=size[x];
-        }
-        else {
-            pi[y]=x;
-            size[x]+=size[y];
-        }
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char Char() throws IOException {
-            return (char) br.read();
-        }
-
-        char nextChar() {
-            return next().charAt(0);
-        }
-
-    }
-}
diff --git a/Problemas/AdvancedDataStructures/UnionFind/Union-Find.java b/Problemas/AdvancedDataStructures/UnionFind/Union-Find.java
deleted file mode 100644
index 3ed61ba..0000000
--- a/Problemas/AdvancedDataStructures/UnionFind/Union-Find.java
+++ /dev/null
@@ -1,126 +0,0 @@
-import java.io.*;
-import java.util.*;
-
-public class Union_FindKattis {
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		PrintWriter out = new PrintWriter(System.out);
-		int n = in.nextInt();
-		int q = in.nextInt();
-		UnionFind uf = new UnionFind(n);
-		for (int i = 0; i < q; i++) {
-			String op = in.next();
-			if (op.equals("=")) {
-				int a = in.nextInt();
-				int b = in.nextInt();
-				uf.unionSet(a, b);
-			} else {
-				int a = in.nextInt();
-				int b = in.nextInt();
-				out.println(uf.isSameSet(a, b) ? "yes" : "no");
-			}
-
-		}
-		out.flush();
-	}
-
-	static class UnionFind {
-		int[] parents;
-		int[] treeSizes;
-
-		UnionFind(int size) {
-			parents = new int[size];
-			treeSizes = new int[size];
-			for (int i = 0; i < size; i++) {
-				parents[i] = i;
-				treeSizes[i] = 1;
-			}
-		}
-
-		void unionSet(int i, int j) {
-			int rootI = find(i);
-			int rootJ = find(j);
-			if (rootI == rootJ)
-				return;
-			if (treeSizes[rootI] < treeSizes[rootJ])
-				subdue(rootI, rootJ);
-			else
-				subdue(rootJ, rootI);
-		}
-
-		boolean isSameSet(int i, int j) {
-			return find(i) == find(j);
-		}
-
-		int find(int i) {
-			int root = i;
-			while (root != parents[root])
-				root = parents[root];
-			return root;
-		}
-
-		private void subdue(int slave, int master) {
-			parents[slave] = master;
-			treeSizes[master] += treeSizes[slave];
-		}
-
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-
-}
diff --git a/Problemas/BinarySearch/Aggressive cows.cpp b/Problemas/BinarySearch/Aggressive cows.cpp
deleted file mode 100644
index 75354c2..0000000
--- a/Problemas/BinarySearch/Aggressive cows.cpp	
+++ /dev/null
@@ -1,50 +0,0 @@
-//https://vjudge.net/problem/SPOJ-AGGRCOW
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(),A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-
-
-void solve() {
-    int n, c;
-    cin >> n >> c;
-    vector<int> A(n);
-    fori(i, 0, n)
-        cin >> A[i];
-    sort(all(A));
-    int l = 0;
-    int r = INT_MAX;
-    int ans = -1;
-    while (l <= r) {
-        int mid = (l + r) >> 1;
-        int low = 0;
-        int high = 1;
-        int cont = 0;
-        while (high < n && cont != c - 1) {
-            int dist = abs(A[low] - A[high]);
-            if (dist >= mid) {
-                cont++;
-                low = high;
-            }
-            high++;
-        }
-        if (cont >= c - 1) {
-            l = mid + 1;
-            ans = mid;
-        } else
-            r = mid - 1;
-    }
-    cout << ans << ln;
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t;
-    cin >> t;
-    while (t--)
-        solve();
-    return 0;
-}
diff --git a/Problemas/BinarySearch/ArrayDivision.cpp b/Problemas/BinarySearch/ArrayDivision.cpp
deleted file mode 100644
index 704c65b..0000000
--- a/Problemas/BinarySearch/ArrayDivision.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-//https://cses.fi/problemset/task/1085/
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(),A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define ll long long
-#define ull unsigned long long
-
-int n, k;
-vector<ll> A;
-
-bool valid(ll x) {
-    ll cum = 0;
-    int cnt = 1;
-    fori(i, 0, n) {
-        if (A[i] > x)
-            return false;
-        if (cum + A[i] > x) {
-            cnt++;
-            cum = A[i];
-        } else
-            cum += A[i];
-    }
-    return cnt <= k;
-}
-
-ll bs() {
-    ll l = 0;
-    ll r = 1e18;
-    ll ans = -1;
-    while (l <= r) {
-        ll mid = (l + r) >> 1;
-        if (valid(mid)) {
-            ans = mid;
-            r = mid - 1;
-        } else
-            l = mid + 1;
-    }
-    return ans;
-}
-
-void solve() {
-    cin >> n >> k;
-    A.resize(n);
-    fori(i, 0, n)
-        cin >> A[i];
-    cout << bs() << ln;
-}
-
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t = 1;
-    while (t--)
-        solve();
-    return 0;
-}
diff --git a/Problemas/BinarySearch/Counting Haybales.cpp b/Problemas/BinarySearch/Counting Haybales.cpp
deleted file mode 100644
index ab271f2..0000000
--- a/Problemas/BinarySearch/Counting Haybales.cpp	
+++ /dev/null
@@ -1,73 +0,0 @@
-//https://vjudge.net/problem/USACO-666
-using namespace std;
-#include <bits/stdc++.h>
-
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-
-vector<int> A;
-int n;
-
-int menor_igual(int x) {
-    int l = 0;
-    int r = n - 1;
-    int ans = INT_MIN;
-    while (l <= r) {
-        int mid = (l + r) >> 1;
-        if (A[mid] == x)
-            return mid;
-        if (A[mid] < x) {
-            ans = max(ans, mid);
-            l = mid + 1;
-        } else
-            r = mid - 1;
-    }
-    return ans;
-}
-
-int mayor_igual(int x) {
-    int l = 0;
-    int r = n - 1;
-    int ans = INT_MAX;
-    while (l <= r) {
-        int mid = (l + r) >> 1;
-        if (A[mid] == x)
-            return mid;
-        if (A[mid] < x)
-            l = mid + 1;
-        else {
-            ans = min(ans, mid);
-            r = mid - 1;
-        }
-    }
-    return ans;
-}
-
-void solve() {
-    int q;
-    cin >> n >> q;
-    A.assign(n, 0);
-    fori(i, 0, n)
-        cin >> A[i];
-    sort(A.begin(), A.end());
-    while (q--) {
-        int l, r;
-        cin >> l >> r;
-        int ans1 = menor_igual(r);
-        int ans2 = mayor_igual(l);
-        if (ans1 == INT_MIN || ans2 == INT_MAX)
-            cout << 0 << ln;
-        else
-            cout << ans1 - ans2 + 1 << ln;
-        
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    freopen("haybales.in", "r", stdin);
-    freopen("haybales.out", "w", stdout);
-    solve();
-    return 0;
-}
diff --git a/Problemas/BinarySearch/Distributing Ballot Boxes.cpp b/Problemas/BinarySearch/Distributing Ballot Boxes.cpp
deleted file mode 100644
index d3e7307..0000000
--- a/Problemas/BinarySearch/Distributing Ballot Boxes.cpp	
+++ /dev/null
@@ -1,39 +0,0 @@
-//https://vjudge.net/problem/SPOJ-BALLOT
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(),A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-
-
-void solve() {
-    int n, b;
-    while (cin >> n >> b && n != -1) {
-        vector<int> A(n);
-        fori(i, 0, n)
-            cin >> A[i];
-        int l = 0;
-        int r = INT_MAX;
-        int ans;
-        while (l <= r) {
-            int mid = (l + r) >> 1;
-            int cont = 0;
-            for (const auto &i: A)
-                cont += (i + mid - 1) / mid;
-            if (cont <= b) {
-                ans = mid;
-                r = mid - 1;
-            } else
-                l = mid + 1;
-        }
-        cout << ans << ln;
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git a/Problemas/BinarySearch/Factory Machines.cpp b/Problemas/BinarySearch/Factory Machines.cpp
deleted file mode 100644
index 6efe625..0000000
--- a/Problemas/BinarySearch/Factory Machines.cpp	
+++ /dev/null
@@ -1,44 +0,0 @@
-//https://cses.fi/problemset/task/1620/
-using namespace std;
-#include <bits/stdc++.h>
-
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-
-vector<int> A;
-
-long long binarySearch(int t) {
-    long long l = 0;
-    long long r = LLONG_MAX;
-    long long ans = LLONG_MAX;
-    while (l <= r) {
-        long long mid = l + ((r - l) >> 1); //Better than (l+r)/2, avoid overflow
-        unsigned long long cur = 0;
-        for (const auto &i: A)
-            cur += mid / i;
-        if (cur >= t) {
-            ans = min(ans, mid);
-            r = mid - 1;
-        } else
-            l = mid + 1;
-    }
-    return ans;
-}
-
-void solve() {
-    int n, t;
-    cin >> n >> t;
-    A.assign(n, 0);
-    fori(i, 0, n)
-        cin >> A[i];
-    cout << binarySearch(t) << ln;
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    //freopen("file.in", "r", stdin);
-    //freopen("file.out", "w", stdout);
-    solve();
-    return 0;
-}
diff --git a/Problemas/BinarySearch/Limited Repainting.cpp b/Problemas/BinarySearch/Limited Repainting.cpp
deleted file mode 100644
index 5e57cfd..0000000
--- a/Problemas/BinarySearch/Limited Repainting.cpp	
+++ /dev/null
@@ -1,60 +0,0 @@
-//https://codeforces.com/contest/2070/problem/C
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(),A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define ll long long
-#define ull unsigned long long
-
-int n, k;
-string s;
-vector<ll> A;
-
-bool valid(ll x) {
-    char last = '*';
-    int cnt = 0;
-    fori(i, 0, n) {
-        if (A[i] <= x)
-            continue;
-        if (s[i] == 'B' && last != 'B')
-            cnt++;
-        last = s[i];
-    }
-    return cnt <= k;
-}
-
-ll bs() {
-    ll l = 0;
-    ll r = 1e18;
-    ll ans = -1;
-    while (l <= r) {
-        ll mid = (l + r) >> 1;
-        if (valid(mid)) {
-            ans = mid;
-            r = mid - 1;
-        } else
-            l = mid + 1;
-    }
-    return ans;
-}
-
-void solve() {
-    cin >> n >> k >> s;
-    A.resize(n);
-    fori(i, 0, n)
-        cin >> A[i];
-    cout << bs() << ln;
-}
-
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t;
-    cin >> t;
-    while (t--)
-        solve();
-    return 0;
-}
diff --git a/Problemas/BinarySearch/Max Median.cpp b/Problemas/BinarySearch/Max Median.cpp
deleted file mode 100644
index 97f19f9..0000000
--- a/Problemas/BinarySearch/Max Median.cpp	
+++ /dev/null
@@ -1,51 +0,0 @@
-//https://codeforces.com/problemset/problem/1486/D
-using namespace std;
-#include <bits/stdc++.h>
-#include <iostream>
-#include <algorithm>
-#include <climits>
-#include <cmath>
-#include <iomanip>
-#include <string>
-#define ll long long
-#define Pair pair<int,int>
-int nums[200005];
-int b[200005];
-int pf[200005];
-int n,k;
-bool help(int x) {
-    for(int i=0;i<n;i++)
-        b[i]=nums[i]>=x?1:-1;
-    pf[0]=0;
-    for(int i=0;i<n;i++)
-        pf[i+1]=pf[i]+b[i];
-    set<int> st;
-    for(int i=k;i<=n;i++) {
-        st.insert(pf[i-k]);
-        if(*st.begin()<pf[i])
-            return true;
-    }
-    return false;
-}
-int main() {
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    //freopen("socdist.in", "r",stdin);
-    //freopen("socdist.out", "w", stdout);
-    cin>>n>>k;
-    for(int i=0;i<n;i++)
-        cin>>nums[i];
-    int l=1,r=n;
-    int ans=0;
-    while(l<=r) {
-        int mid=(l+r)>>1;
-        if(help(mid)) {
-            ans=mid;
-            l=mid+1;
-        }
-        else
-            r=mid-1;
-    }
-    cout<<ans<<endl;
-    return 0;
-}
diff --git a/Problemas/BinarySearch/Maximun Average Segment.cpp b/Problemas/BinarySearch/Maximun Average Segment.cpp
deleted file mode 100644
index 131b318..0000000
--- a/Problemas/BinarySearch/Maximun Average Segment.cpp	
+++ /dev/null
@@ -1,55 +0,0 @@
-//https://codeforces.com/edu/course/2/lesson/6/4/practice/contest/285069/problem/A
-//https://codeforces.com/edu/courses
-using namespace std;
-#include <bits/stdc++.h>
-#include <iostream>
-#include <algorithm>
-#include <climits>
-#include <cmath>
-#include <iomanip>
-#include <string>
-#define ll long long
-double nums[100005];
-double b[100005];
-double pf[100005];
-int n,k;
-pair<int,int> help(double x) {
-    for(int i=0;i<n;i++)
-        b[i]=nums[i]-x;
-    pf[0]=0;
-    for(int i=0;i<n;i++)
-        pf[i+1]=pf[i]+b[i];
-    map<double,int> st;
-    for(int i=k;i<=n;i++) {
-
-        st.insert({pf[i-k],i-k});
-        const auto aux=st.begin();
-        if(aux->first<=pf[i])
-            return make_pair(aux->second+1,i);
-    }
-    return make_pair(-1,-1);
-}
-int main() {
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    //freopen("socdist.in", "r",stdin);
-    //freopen("socdist.out", "w", stdout);
-
-    cin>>n>>k;
-    for(int i=0;i<n;i++)
-        cin>>nums[i];
-    double l=0,r=110;
-    pair<int,int> ans={1,n};
-    while(r-l>1e-9) {
-        double mid=(l+r)/2;
-        pair<int,int> p=help(mid);
-        if(p.first>-1) {
-            ans=p;
-            l=mid;
-        }
-        else
-            r=mid;
-    }
-    cout<<ans.first<<" "<<ans.second<<endl;
-    return 0;
-}
diff --git a/Problemas/BinarySearch/Minimum maximum on the Path.cpp b/Problemas/BinarySearch/Minimum maximum on the Path.cpp
deleted file mode 100644
index 78f3253..0000000
--- a/Problemas/BinarySearch/Minimum maximum on the Path.cpp	
+++ /dev/null
@@ -1,77 +0,0 @@
-//https://codeforces.com/edu/course/2/lesson/6/3/practice/contest/285083/problem/D
-//https://codeforces.com/edu/courses
-using namespace std;
-#include <bits/stdc++.h>
-#include <iostream>
-#include <algorithm>
-#include <climits>
-#include <cmath>
-#include <iomanip>
-#include <string>
-#define ll long long
-int n,m,k;
-typedef pair<int, int> Pair;
-int INF=numeric_limits<int>::max();
-vector<vector<Pair>> adj;
-vector<int> bfs(int x) {
-    vector<bool> state(n, false);
-    vector<int> d(n,INF);
-    vector<int> pi(n,-1);
-    queue<int> q;
-    q.push(1);
-    d[1] = 0;
-    state[1] = true;
-    while (!q.empty()) {
-        int u=q.front();
-        q.pop();
-        for (Pair p : adj[u]) {
-            int v=p.second;
-            int w=p.first;
-            if(!state[v]&&w<=x&&d[u]<k) {
-                state[v]=true;
-                q.push(v);
-                d[v]=d[u]+1;
-                pi[v]=u;
-            }
-        }
-    }
-    return pi;
-}
-int main() {
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    //freopen("socdist.in", "r",stdin);
-    //freopen("socdist.out", "w", stdout);
-    cin>>n>>m>>k;
-    n++;
-    adj.assign(n, vector<Pair>());
-    for(int i=0;i<m;i++) {
-        int u,v,w;
-        cin>>u>>v>>w;
-        adj[u].emplace_back(w,v);
-    }
-    int l=0,r=1e9;
-    vector<int> pi(n,-1);
-    while(l<=r) {
-        int mid=l+(r-l)/2;
-        vector<int> act=bfs(mid);
-        if(act[n-1]>-1) {
-            pi=act;
-            r=mid-1;
-        }
-        else
-            l=mid+1;
-    }
-    if(pi[n-1]==-1) {
-        cout<<"-1"<<endl;
-        return 0;
-    }
-    vector<int> ans;
-    ans.push_back(n-1);
-    for(int u=pi[n-1];u>-1;u=pi[u])
-        ans.push_back(u);
-    cout<<ans.size()-1<<endl;
-    for(int i=ans.size()-1;i>=0;i--)
-        cout<<ans[i]<<" ";
-    return 0;
-}
diff --git a/Problemas/BinarySearch/QueriesAboutLessOrEqualElements.cpp b/Problemas/BinarySearch/QueriesAboutLessOrEqualElements.cpp
deleted file mode 100644
index c2116fe..0000000
--- a/Problemas/BinarySearch/QueriesAboutLessOrEqualElements.cpp
+++ /dev/null
@@ -1,48 +0,0 @@
-//https://codeforces.com/contest/600/problem/B
-using namespace std;
-#include <bits/stdc++.h>
-
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-
-vector<int> A;
-int n;
-
-int binarySearch(int x) {
-    int l = 0;
-    int r = n - 1;
-    int ans = INT_MIN;
-    while (l <= r) {
-        int mid = (l + r) >> 1;
-        if (A[mid] <= x) {
-            ans = max(ans, mid);
-            l = mid + 1;
-        } else
-            r = mid - 1;
-    }
-    return ans == INT_MIN ? 0 : ans+1;
-}
-
-void solve() {
-    int m;
-    cin >> n >> m;
-    A.assign(n, 0);
-    fori(i, 0, n)
-        cin >> A[i];
-    sort(A.begin(), A.end());
-    while (m--) {
-        int x;
-        cin >> x;
-        cout << binarySearch(x) << " ";
-    }
-    cout << ln;
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    //freopen("file.in", "r", stdin);
-    //freopen("file.out", "w", stdout);
-    solve();
-    return 0;
-}
diff --git a/Problemas/BinarySearch/Set.cpp b/Problemas/BinarySearch/Set.cpp
deleted file mode 100644
index 1207d9a..0000000
--- a/Problemas/BinarySearch/Set.cpp
+++ /dev/null
@@ -1,48 +0,0 @@
-//https://codeforces.com/contest/2029/problem/A
-using namespace std;
-#include <bits/stdc++.h>
-
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-
-long long f(long long l, long long r, long long k) {
-    long long ans = LLONG_MAX;
-    long long R = r;
-    long long L = l;
-    if (r - l == 1)
-        return l * k <= r;
-    while (l < r - 1) {
-        long long mid = (l + r) >> 1;
-        if (mid * k > R) {
-            ans = min(ans, mid);
-            r = mid;
-        } else
-            l = mid;
-    }
-    return ans - L;
-}
-
-void solve() {
-    int t;
-    cin >> t;
-    while (t--) {
-        long long l, r, k;
-        cin >> l >> r >> k;
-        if (k == 1)
-            cout << r - l + 1 << ln;
-        else if (l * k > r)
-            cout << 0 << ln;
-        else
-            cout << f(l, r, k) << ln;
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    // freopen("file.in", "r", stdin);
-    // freopen("file.out", "w", stdout);
-    solve();
-    return 0;
-}
-//It can be solved in O(1) using math
diff --git a/Problemas/BinarySearch/SkibidusAndFanumTax (hard version).cpp b/Problemas/BinarySearch/SkibidusAndFanumTax (hard version).cpp
deleted file mode 100644
index 49a2b1b..0000000
--- a/Problemas/BinarySearch/SkibidusAndFanumTax (hard version).cpp	
+++ /dev/null
@@ -1,80 +0,0 @@
-//https://codeforces.com/contest/2065/problem/C2
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(),A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-
-int m;
-vector<int> B;
-
-
-int binarySearch(int x) {
-    int l = 0;
-    int r = m - 1;
-    int ans = -1;
-    while (l <= r) {
-        int mid = (l + r) >> 1;
-        if (B[mid] >= x) {
-            ans = mid;
-            r = mid - 1;
-        } else
-            l = mid + 1;
-    }
-    return ans;
-}
-
-
-void solve() {
-    int n;
-    cin >> n >> m;
-    vector<int> A(n);
-    fori(i, 0, n)
-        cin >> A[i];
-    B.assign(m, 0);
-    fori(i, 0, m)
-        cin >> B[i];
-    sort(all(B));
-    int first = A[0];
-    fori(i, 0, m)
-        first = min(first, B[i] - A[0]);
-    A[0] = first;
-    fori(i, 1, n) {
-        int cur = A[i];
-        int prev = A[i - 1];
-        int x = binarySearch(cur + prev);
-        if (x >= 0) {
-            int copy = B[x] - A[i];
-            if (cur < copy) {
-                if (cur < A[i - 1]) {
-                    if (copy < A[i - 1]) {
-                        cout << "NO" << ln;
-                        return;
-                    }
-                    A[i] = copy;
-                }
-            } else {
-                if (copy >= A[i - 1])
-                    A[i] = copy;
-            }
-        }
-    }
-    fori(i, 0, n-1)
-        if (A[i] > A[i + 1]) {
-            cout << "NO" << ln;
-            return;
-        }
-    cout << "YES" << ln;
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t;
-    cin >> t;
-    while (t--)
-        solve();
-    return 0;
-}
-//This code also works for easy version
diff --git a/Problemas/BinarySearch/SocialDistancing.cpp b/Problemas/BinarySearch/SocialDistancing.cpp
deleted file mode 100644
index 3f777ce..0000000
--- a/Problemas/BinarySearch/SocialDistancing.cpp
+++ /dev/null
@@ -1,59 +0,0 @@
-//https://vjudge.net/problem/USACO-1038
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(),A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define ll long long
-#define ull unsigned long long
-
-int n, m;
-vector<pair<ll,ll> > A;
-
-ll bs() {
-    ll l = 0;
-    ll r = INT_MAX;
-    ll ans = -1;
-    while (l <= r) {
-        ll mid = (l + r) >> 1;
-        int i = 0;
-        int cnt = 1;
-        ll cur = A[i].first;
-        while (i < m && cnt < n) {
-            if (cur + mid <= A[i].second) {
-                cur = max(cur + mid, A[i].first);
-                cnt++;
-            } else
-                i++;
-        }
-        if (cnt >= n) {
-            ans = mid;
-            l = mid + 1;
-        } else
-            r = mid - 1;
-    }
-    return ans;
-}
-
-
-void solve() {
-    cin >> n >> m;
-    A.assign(m, {});
-    fori(i, 0, m)
-        cin >> A[i].first >> A[i].second;
-    sort(all(A));
-    cout << bs() << ln;
-}
-
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    freopen("socdist.in", "r",stdin);
-    freopen("socdist.out", "w",stdout);
-    int t = 1;
-    while (t--)
-        solve();
-    return 0;
-}
diff --git a/Problemas/Bitmask/And Then There Where K.cpp b/Problemas/Bitmask/And Then There Where K.cpp
deleted file mode 100644
index e3e4911..0000000
--- a/Problemas/Bitmask/And Then There Where K.cpp	
+++ /dev/null
@@ -1,28 +0,0 @@
-//https://codeforces.com/problemset/problem/1527/A
-#include <iostream>
-using namespace std;
-int countSetBits(int n){
-    int count = 0;
-    while (n){
-        n = n & (n - 1);
-        count++;
-    }
-    return count;
-}
-
-int main() {
-    int t;
-    cin >>t;
-    for(int times=0;times<t;times++){
-        int n;
-        cin>>n;
-        int aux=n;
-        int c=0;
-        while(n){
-            aux=n-1;
-            n&=n-1;
-            c++;
-        }
-        cout<<(aux)<<endl;
-    }
-}
diff --git a/Problemas/Bitmask/And_Then_There_Were_K.py b/Problemas/Bitmask/And_Then_There_Were_K.py
deleted file mode 100644
index 8191f1d..0000000
--- a/Problemas/Bitmask/And_Then_There_Were_K.py
+++ /dev/null
@@ -1,7 +0,0 @@
-#https://codeforces.com/problemset/problem/1527/A
-import math
-
-t = int(input())
-for i in range(t):
-    n = int(input())
-    print((1 << int(math.log(n, 2))) - 1)
diff --git a/Problemas/Bitmask/Bitwise Operators.java b/Problemas/Bitmask/Bitwise Operators.java
deleted file mode 100644
index 161bd24..0000000
--- a/Problemas/Bitmask/Bitwise Operators.java	
+++ /dev/null
@@ -1,90 +0,0 @@
-//https://vjudge.net/problem/CodeChef-NXS2
-import java.io.*;
-import java.util.*;
-public class Main {
-    public static void main(String[] args) throws IOException {
-        Scanner sc = new Scanner();
-        PrintWriter out = new PrintWriter(System.out);
-        int tim = sc.nextInt();
-        for (int times = 0; times < tim; times++) {
-            int n=sc.nextInt();
-            int aux=n;
-            if(n%2!=0)
-                System.out.println(1+" "+(n-1));
-            else{
-                int i=0;
-                while (true){
-                    n=n>>1;
-                    i++;
-                    if(n%2==1)
-                        break;
-                }
-                if(1<<i==aux)
-                    System.out.println(-1);
-                else
-                    System.out.println((1<<i)+" "+((n>>1)<<i+1));
-            }
-
-
-        }
-
-
-    }
-
-    public static int llcs(String pat, String alph) {
-        int m = pat.length();
-        int n = alph.length();
-        int[][] lcs = new int[m + 1][n + 1];
-        for (int i = 1; i <= m; i++) {
-            for (int j = 1; j <= n; j++) {
-                if (pat.charAt(i - 1) == alph.charAt(j - 1))
-                    lcs[i][j] = 1 + lcs[i - 1][j - 1];
-                else
-                    lcs[i][j] = Math.max(lcs[i - 1][j], lcs[i][j - 1]);
-            }
-        }
-        return lcs[m][n];
-    }
-
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    return "";
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char nextChar() {
-            return next().charAt(0);
-        }
-
-    }
-}
diff --git a/Problemas/Bitmask/Fedor and New Game.cpp b/Problemas/Bitmask/Fedor and New Game.cpp
deleted file mode 100644
index 4631a7a..0000000
--- a/Problemas/Bitmask/Fedor and New Game.cpp	
+++ /dev/null
@@ -1,29 +0,0 @@
-//https://codeforces.com/problemset/problem/467/B
-#include <iostream>
-using namespace std;
-int countSetBits(int n){
-    int count = 0;
-    while (n)
-    {
-        n = n & (n - 1);
-        count++;
-    }
-    return count;
-}
-
-int main() {
-    int n,m,k;
-    cin >> n>>m>>k;
-    int arr[m+1];
-    for(int i=0 ; i<m+1;i++){
-        cin>>arr[i];
-    }
-    int c=0;
-    for(int i=0;i<m;i++){
-        int a=(arr[i]^arr[m]);
-        if(countSetBits(a)<=k){
-            c++;
-        }
-    }
-    cout<<c;
-}
diff --git a/Problemas/Bitmask/Fun Game.cpp b/Problemas/Bitmask/Fun Game.cpp
deleted file mode 100644
index b52db8f..0000000
--- a/Problemas/Bitmask/Fun Game.cpp	
+++ /dev/null
@@ -1,31 +0,0 @@
-//https://codeforces.com/problemset/problem/1994/B
-#include <iostream>
-using namespace std;
-
-int main() {
-    int t;
-    cin >>t;
-    for(int times=0;times<t;times++){
-        int n;
-        string s,t;
-        cin>>n;
-        cin>>s;
-        cin>>t;
-        bool c=true;
-        for(int i=0;i<n;i++){
-            if(s[i]=='1'){
-                cout<<"YES"<<endl;
-                c=false;
-                break;
-            }
-            if(t[i]=='1'){
-                cout<<"NO"<<endl;
-                c=false;
-                break;
-            }
-        }
-        if(c){
-            cout<<"YES"<<endl;
-        }
-    }
-}
diff --git a/Problemas/Bitmask/Gray_Code.py b/Problemas/Bitmask/Gray_Code.py
deleted file mode 100644
index fb3b7ef..0000000
--- a/Problemas/Bitmask/Gray_Code.py
+++ /dev/null
@@ -1,6 +0,0 @@
-#https://cses.fi/problemset/result/11850216/
-n = int(input())
-for i in range(1 << n):
- 
-    binary = bin(i ^ i >> 1)[2:].zfill(n) #zfill rellena de zeros a la izquierda n veces, si no tiene nada, si no lo omite.
-    print(binary)
diff --git a/Problemas/Bitmask/PowersOfTwo.cpp b/Problemas/Bitmask/PowersOfTwo.cpp
deleted file mode 100644
index f9f91d6..0000000
--- a/Problemas/Bitmask/PowersOfTwo.cpp
+++ /dev/null
@@ -1,37 +0,0 @@
-//https://codeforces.com/contest/702/problem/B
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(),A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-
-void solve() {
-    int n;
-    cin >> n;
-    vector<int> A(n);
-    unordered_map<int, int> freq;
-    fori(i, 0, n) {
-        cin >> A[i];
-        freq[A[i]]++;
-    }
-    long long c = 0;
-    fori(i, 0, n) {
-        freq[A[i]]--;
-        fori(j, 1, 31) {
-            int need = (1 << j) - A[i];
-            if (freq.find(need) != freq.end())
-                c += freq[need];
-        }
-    }
-    cout << c << ln;
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t = 1;
-    while (t--)
-        solve();
-    return 0;
-}
diff --git a/Problemas/Bitmask/Raising Bacteria.cpp b/Problemas/Bitmask/Raising Bacteria.cpp
deleted file mode 100644
index 9fece5f..0000000
--- a/Problemas/Bitmask/Raising Bacteria.cpp	
+++ /dev/null
@@ -1,16 +0,0 @@
-//https://codeforces.com/contest/579/problem/A
-#include <iostream>
-using namespace std;
-int countSetBits(int n){
-    int count = 0;
-    while (n){
-        n = n & (n - 1);
-        count++;
-    }
-    return count;
-}
-int main() {
-    int n;
-    cin >> n;
-    cout<<countSetBits(n);
-}
diff --git a/Problemas/Bitmask/RaisingBacteria.java b/Problemas/Bitmask/RaisingBacteria.java
deleted file mode 100644
index f4c603f..0000000
--- a/Problemas/Bitmask/RaisingBacteria.java
+++ /dev/null
@@ -1,10 +0,0 @@
-import java.io.*;
-
-public class RaisingBacteria {
-
-	public static void main(String[] args) throws Exception {
-		System.out.println(
-				Integer.bitCount(Integer.parseInt(new BufferedReader(new InputStreamReader(System.in)).readLine())));
-	}
-
-}
diff --git a/Problemas/DP/CoinChange.py b/Problemas/DP/CoinChange.py
deleted file mode 100644
index 2a296eb..0000000
--- a/Problemas/DP/CoinChange.py
+++ /dev/null
@@ -1,13 +0,0 @@
-import math
-def f(coins, amount):
-    maxi = math.inf
-    memo = [0]*(amount+1)
-    for i in range(1, amount+1):
-      val = maxi
-      for j in coins:
-          if i-j<0:
-              val = min(val,self.maxi)
-          else:
-              val = min(val, memo[i-j]+1)
-      memo[i] = val
-    return memo[amount]
diff --git a/Problemas/DP/CoinChange2.cpp b/Problemas/DP/CoinChange2.cpp
deleted file mode 100644
index b7629fc..0000000
--- a/Problemas/DP/CoinChange2.cpp
+++ /dev/null
@@ -1,21 +0,0 @@
-//https://leetcode.com/problems/coin-change-ii/description/?envType=problem-list-v2&envId=dynamic-programming
-
-#include <iostream>
-#include <vector>
-using namespace std;
-class Solution {
-public:
-    unsigned long long change(int amount, vector<int>& coins) {
-        
-        vector<unsigned long long> dp(amount + 1, 0);
-        dp[0] = 1;
-
-        for (int coin : coins) {
-            for (int i = coin; i <= amount; i++) {
-                dp[i] += dp[i - coin]; 
-            }
-        }
-
-        return dp[amount];
-    }
-};
diff --git a/Problemas/DP/Coins.java b/Problemas/DP/Coins.java
deleted file mode 100644
index c942582..0000000
--- a/Problemas/DP/Coins.java
+++ /dev/null
@@ -1,62 +0,0 @@
-// https://vjudge.net/problem/AtCoder-dp_i
-import java.io.*;
-import java.util.*;
-public class Main{
-    static double[][] dp;
-    static double[] p;
-    public static void main(String[] args) throws IOException {
-        Scanner sc = new Scanner();
-        int n=sc.nextInt();
-        p=new double[n+1];
-        for (int i = 1; i <= n; i++)
-            p[i]=sc.nextDouble();
-        //System.out.println("popote");
-        dp=new double[n+1][n+1];
-        dp[0][0]=1;
-        for (int i = 1; i <= n; i++) {
-            for (int j = 0; j <=i ; j++) {
-                if(j==0)
-                    dp[i][j]=dp[i-1][j]*(1-p[i]);
-                else
-                    dp[i][j]=dp[i-1][j-1]*p[i]+dp[i-1][j]*(1-p[i]);
-            }
-        }
-        double c=0;
-        for (int i = n; i >n/2 ; i--)
-            c+=dp[n][i];
-        System.out.println(c);
-    }
-static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar(){
-            return next().charAt(0);
-        }
-
-    }
-}
diff --git a/Problemas/DP/CountPathInAMatrix2.java b/Problemas/DP/CountPathInAMatrix2.java
deleted file mode 100644
index 17d4122..0000000
--- a/Problemas/DP/CountPathInAMatrix2.java
+++ /dev/null
@@ -1,19 +0,0 @@
-def solve(i,j,matrix,dp):
-    if i+1>len(matrix) or j+1>len(matrix[0]):
-        return 0
-    if matrix[i][j]==1:
-        return 0
-    if i==len(matrix)-1 and j==len(matrix[0])-1:
-        return 1
-    if dp[i][j]!=-1:
-        return dp[i][j]
-    dp[i][j] = solve(i+1,j,matrix,dp)+solve(i,j+1,matrix,dp)
-    return dp[i][j]
-
-n = int(input())
-m = int(input())
-m = []
-for i in range(n):
-    m.append([int(j) for j in input().split()])
-dp = [[-1]*len(m[0]) for _ in range(len(m))]
-print(solve(0,0,m,dp))
diff --git a/Problemas/DP/CountPathsMatrix.py b/Problemas/DP/CountPathsMatrix.py
deleted file mode 100644
index 7271afd..0000000
--- a/Problemas/DP/CountPathsMatrix.py
+++ /dev/null
@@ -1,13 +0,0 @@
-def solve(n,m):
-    dp = [[0]*m for _ in range(n)]
-    for i in range(n):
-        for j in range(m):
-            if i==0 or j==0:
-                dp[i][j] = 1
-            else:
-                dp[i][j] = dp[i-1][j] + dp[i][j-1]
-
-    return dp[n-1][m-1]
-                
-[n,m] = [int(i) for i in input().split()]
-print(solve(n, m))
diff --git a/Problemas/DP/Dice Combinations.java b/Problemas/DP/Dice Combinations.java
deleted file mode 100644
index 762e798..0000000
--- a/Problemas/DP/Dice Combinations.java	
+++ /dev/null
@@ -1,81 +0,0 @@
-//https://vjudge.net/problem/CSES-1633
-import java.io.*;
-import java.util.*;
-public class Main {
-    static final int mod=1000000007;
-    static int[] dp;
-    public static void main(String[] args) throws Exception {
-        Scanner sc = new Scanner();
-        int n=sc.nextInt();
-        dp=new int[n+1];
-        dp[0]=1;
-        for (int i=1;i<=n;i++)
-            for (int j=1;j<=6;j++)
-                if(i-j>=0) {
-                    dp[i] += dp[i - j];
-                    dp[i]%=mod;
-                }
-        System.out.println(dp[n]);
-
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public void close() throws IOException {
-            br.close();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-    }
-
-}
diff --git a/Problemas/DP/FastPolynomialMultiplication.java b/Problemas/DP/FastPolynomialMultiplication.java
deleted file mode 100644
index dabfc92..0000000
--- a/Problemas/DP/FastPolynomialMultiplication.java
+++ /dev/null
@@ -1,127 +0,0 @@
-//Multiply two polynomials in time O(nlogn) using Fast Fourier TransForm
-import java.util.*;
-import java.io.*;
-
-public class FFT {
-
-	static int grado;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		int t = Integer.parseInt(in.readLine());
-		StringTokenizer st;
-		for (int cases = 0; cases < t; cases++) {
-			int n1 = Integer.parseInt(in.readLine()) + 1;
-			ComplexNumber[] p1 = new ComplexNumber[n1];
-			st = new StringTokenizer(in.readLine());
-			for (int i = 0; i < n1; i++)
-				p1[i] = new ComplexNumber(Double.parseDouble(st.nextToken()), 0);
-			int n2 = Integer.parseInt(in.readLine()) + 1;
-			ComplexNumber[] p2 = new ComplexNumber[n2];
-			st = new StringTokenizer(in.readLine());
-			for (int i = 0; i < n2; i++)
-				p2[i] = new ComplexNumber(Double.parseDouble(st.nextToken()), 0);
-			long[] p3 = polyMult(p1, p2);
-			System.out.println(grado - 1);
-			p3 = Arrays.copyOfRange(p3, 0, grado);
-			System.out.println(String.join(" ", Arrays.stream(p3).mapToObj(x -> String.valueOf(x)).toList()));
-
-		}
-	}
-
-	static long[] polyMult(ComplexNumber[] a, ComplexNumber[] b) {
-		int m = a.length;
-		int n = b.length;
-		int sz = m + n - 1;
-		grado = sz;
-		int szPrima = nextPowerOf2(sz);
-		a = Arrays.copyOf(a, szPrima);
-		b = Arrays.copyOf(b, szPrima);
-		for (int i = m; i < szPrima; i++)
-			a[i] = new ComplexNumber(0, 0);
-		for (int i = n; i < szPrima; i++)
-			b[i] = new ComplexNumber(0, 0);
-		ComplexNumber[] fft1 = fft(a, false);
-		ComplexNumber[] fft2 = fft(b, false);
-		ComplexNumber[] fft3 = new ComplexNumber[szPrima];
-		for (int i = 0; i < fft3.length; i++)
-			fft3[i] = fft1[i].mul(fft2[i]);
-		long[] c = new long[szPrima];
-		ComplexNumber[] inv_fft3 = fft(fft3, true);
-		for (int i = 0; i < c.length; i++)
-			c[i] = Math.round(inv_fft3[i].real);
-		return c;
-
-	}
-
-	static int nextPowerOf2(int n) {
-		int nextPow2 = 1;
-		while (nextPow2 < n)
-			nextPow2 <<= 1;
-		return nextPow2;
-	}
-
-	static ComplexNumber[] fft(ComplexNumber[] seq, boolean inverse) {
-		if (seq.length == 1)
-			return seq;
-		int n = seq.length;
-		ComplexNumber[] seq_even = new ComplexNumber[n / 2];
-		ComplexNumber[] seq_odd = new ComplexNumber[n / 2];
-		for (int i = 0; i < n / 2; i++) {
-			seq_even[i] = seq[i * 2];
-			seq_odd[i] = seq[i * 2 + 1];
-		}
-		ComplexNumber[] s1 = fft(seq_even, inverse);
-		ComplexNumber[] s2 = fft(seq_odd, inverse);
-		ComplexNumber[] fft_ans = new ComplexNumber[n];
-		ComplexNumber w = new ComplexNumber(1, 0);
-		ComplexNumber wn = null;
-		if (inverse)
-			wn = new ComplexNumber(Math.cos(2 * Math.PI / n), -Math.sin(2 * Math.PI / n));
-		else
-			wn = new ComplexNumber(Math.cos(2 * Math.PI / n), Math.sin(2 * Math.PI / n));
-		for (int k = 0; k < n / 2; k++) {
-			fft_ans[k] = s1[k].add(w.mul(s2[k]));
-			fft_ans[k + n / 2] = s1[k].sub(w.mul(s2[k]));
-			w = w.mul(wn);
-		}
-		if (inverse)
-			for (int i = 0; i < fft_ans.length; i++)
-				fft_ans[i] = fft_ans[i].mul(new ComplexNumber(0.5, 0));
-		return fft_ans;
-
-	}
-
-	static class ComplexNumber {
-		double real;
-		double imag;
-
-		ComplexNumber(double r, double i) {
-			real = r;
-			imag = i;
-		}
-
-		ComplexNumber add(ComplexNumber b) {
-			return new ComplexNumber(real + b.real, imag + b.imag);
-		}
-
-		ComplexNumber sub(ComplexNumber b) {
-			return new ComplexNumber(real - b.real, imag - b.imag);
-		}
-
-		ComplexNumber mul(ComplexNumber b) {
-			return new ComplexNumber(real * b.real - imag * b.imag, real * b.imag + imag * b.real);
-		}
-
-		ComplexNumber div(ComplexNumber b) {
-			double denominator = b.real * b.real + b.imag * b.imag;
-			return new ComplexNumber((real * b.real + imag * b.imag) / denominator,
-					(imag * b.real - real * b.imag) / denominator);
-		}
-
-		public String toString() {
-			return "(" + real + ", " + imag + "j)";
-		}
-
-	}
-}
diff --git a/Problemas/DP/Frog1.py b/Problemas/DP/Frog1.py
deleted file mode 100644
index 3029cc9..0000000
--- a/Problemas/DP/Frog1.py
+++ /dev/null
@@ -1,17 +0,0 @@
-# https://vjudge.net/problem/AtCoder-dp_a
-import sys
-sys.setrecursionlimit(1000000)
-def f(i):
-    if memo[i] == -1:
-        if i == N-1:
-            memo[i] = 0
-        elif  i == N-2:
-            memo[i] = abs(arr[i]-arr[i+1])
-        else:
-            memo[i] = min(abs(arr[i]-arr[i+1])+f(i+1),abs(arr[i]-arr[i+2])+f(i+2))
-    return memo[i]
-
-N = int(input())
-memo = [-1]*N
-arr = [int(i) for i in input().split()]
-print(f(0))
diff --git a/Problemas/DP/Frog2.py b/Problemas/DP/Frog2.py
deleted file mode 100644
index a3ad566..0000000
--- a/Problemas/DP/Frog2.py
+++ /dev/null
@@ -1,22 +0,0 @@
-# https://vjudge.net/problem/AtCoder-dp_b
-import sys
-sys.setrecursionlimit(1000000)
-def f(i):
-    if memo[i] == -1:
-        if i == N-1:
-            memo[i] = 0
-        elif  i == N-2:
-            memo[i] = abs(arr[i]-arr[i+1])
-        else:
-            ans = float("inf")
-            for j in range(1,K+1):
-                if i+j>=N:
-                    continue
-                ans = min(ans, abs(arr[i]-arr[i+j])+f(i+j))
-            memo[i] = ans
-    return memo[i]
-
-N,K  = [int(i) for i in input().split()]
-memo = [-1]*N
-arr = [int(i) for i in input().split()]
-print(f(0))
diff --git a/Problemas/DP/GolfBot.java b/Problemas/DP/GolfBot.java
deleted file mode 100644
index 7456f0d..0000000
--- a/Problemas/DP/GolfBot.java
+++ /dev/null
@@ -1,130 +0,0 @@
-import java.io.*;
-import java.util.*;
-
-public class GolfBot {
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		while (true) {
-			int n;
-			try {
-				n = Integer.parseInt(in.readLine());
-			} catch (NumberFormatException e) {
-				break;
-			}
-			int[] arr = new int[n];
-			int max = 0;
-			for (int i = 0; i < n; i++) {
-				int val = Integer.parseInt(in.readLine());
-				arr[i] = val;
-				max = Math.max(max, val);
-			}
-			max++;
-			ComplexNumber[] poli1 = new ComplexNumber[max];
-			Arrays.fill(poli1, new ComplexNumber(0, 0));
-			poli1[0] = new ComplexNumber(1, 0);
-			for (int i : arr) {
-				poli1[i] = new ComplexNumber(1, 0);
-			}
-			int ans = 0;
-			long[] poly3 = polyMult(poli1);
-			int m = Integer.parseInt(in.readLine());
-			for (int i = 0; i < m; i++) {
-				int val = Integer.parseInt(in.readLine());
-				if (val < poly3.length && poly3[val] > 0)
-					ans++;
-			}
-			System.out.println(ans);
-
-		}
-
-	}
-
-	static long[] polyMult(ComplexNumber[] a) {
-		int m = a.length;
-		int sz = m + m - 1;
-		int szPrima = nextPowerOf2(sz);
-		a = Arrays.copyOf(a, szPrima);
-		Arrays.fill(a, m, szPrima, new ComplexNumber(0, 0));
-		fft(a, 1);
-		for (int i = 0; i < a.length; i++)
-			a[i] = a[i].mul(a[i]);
-		long[] c = new long[sz];
-		fft(a, -1);
-		for (int i = 0; i < c.length; i++)
-			c[i] = Math.round(a[i].real);
-		return c;
-
-	}
-
-	static int nextPowerOf2(int n) {
-		int ans = 1;
-		while (ans < n)
-			ans *= 2;
-		return ans;
-	}
-
-	static void fft(ComplexNumber[] seq, int inv) {
-		int n = seq.length;
-		int shift = 32 - Integer.numberOfTrailingZeros(n);
-		for (int i = 1; i < n; i++) {
-			int j = Integer.reverse(i << shift);
-			if (i < j) {
-				ComplexNumber aux = seq[i];
-				seq[i] = seq[j];
-				seq[j] = aux;
-			}
-		}
-		for (int len = 2; len <= n; len <<= 1) {
-			double angle = 2 * Math.PI / len;
-			ComplexNumber wn = new ComplexNumber(Math.cos(angle), Math.sin(angle) * inv);
-			for (int i = 0; i < n; i += len) {
-				ComplexNumber w = new ComplexNumber(1, 0);
-				for (int j = 0; j < len / 2; j++) {
-					ComplexNumber u = seq[i + j];
-					ComplexNumber v = seq[i + j + len / 2].mul(w);
-					seq[i + j] = u.add(v);
-					seq[i + j + len / 2] = u.sub(v);
-					w = w.mul(wn);
-				}
-			}
-		}
-		if (inv == -1)
-			for (int i = 0; i < seq.length; i++)
-				seq[i] = seq[i].mul(new ComplexNumber((double) 1 / n, 0));
-	}
-
-	static class ComplexNumber {
-		double real;
-		double imag;
-
-		ComplexNumber(double r, double i) {
-			real = r;
-			imag = i;
-		}
-
-		ComplexNumber add(ComplexNumber b) {
-			return new ComplexNumber(real + b.real, imag + b.imag);
-		}
-
-		ComplexNumber sub(ComplexNumber b) {
-			return new ComplexNumber(real - b.real, imag - b.imag);
-		}
-
-		ComplexNumber mul(ComplexNumber b) {
-			return new ComplexNumber(real * b.real - imag * b.imag, real * b.imag + imag * b.real);
-		}
-
-		ComplexNumber div(ComplexNumber b) {
-			double denominator = b.real * b.real + b.imag * b.imag;
-			return new ComplexNumber((real * b.real + imag * b.imag) / denominator,
-					(imag * b.real - real * b.imag) / denominator);
-		}
-
-		public String toString() {
-			return "(" + real + ", " + imag + "j)";
-		}
-
-	}
-
-}
diff --git a/Problemas/DP/HouseRobber.java b/Problemas/DP/HouseRobber.java
deleted file mode 100644
index 2795bc6..0000000
--- a/Problemas/DP/HouseRobber.java
+++ /dev/null
@@ -1,45 +0,0 @@
-//https://leetcode.com/problems/house-robber/
-//Iterative Solution
-class Solution {
-    public int rob(int[] nums) {
-        int n = nums.length;
-        if (n == 1) return nums[0];
-        if (n == 2) return Math.max(nums[0], nums[1]);
-
-        int[] dp = new int[n];
-        dp[0] = nums[0];
-        dp[1] = Math.max(nums[0], nums[1]);
-
-        for(int i = 2; i < n; i++){
-            dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
-        }
-        
-        return dp[n-1];
-    }
-}
-
-//Recursive Solution
-import java.util.*;
-class Solution {
-    private HashMap<Integer, Integer> memo;
-    public int rob(int[] nums) {
-        int n = nums.length;
-        if (n == 1) return nums[0];
-        if (n == 2) return Math.max(nums[0], nums[1]);
-
-        memo = new HashMap<>();
-        memo.put(0, nums[0]);
-        memo.put(1, Math.max(nums[0], nums[1]));
-
-        return solve(n-1, nums);
-    }
-
-    private int solve(int i, int[] nums){
-        if (memo.containsKey(i)) return memo.get(i);
-        else{
-            int result = Math.max(solve(i-2, nums) + nums[i], solve(i-1, nums));
-            memo.put(i, result);
-            return result;
-        }
-    }
-}
diff --git a/Problemas/DP/Igor and Mountain.cpp b/Problemas/DP/Igor and Mountain.cpp
deleted file mode 100644
index 2cc232a..0000000
--- a/Problemas/DP/Igor and Mountain.cpp	
+++ /dev/null
@@ -1,74 +0,0 @@
-//https://codeforces.com/contest/2091/problem/F
-#include <bits/stdc++.h>
-using namespace std;
-#define dll double long
-#define ll long long
-#define Pair pair<int,int>
-#define eb emplace_back
-#define pb push_back
-#define all(x) (x).begin(), (x).end()
-#define ln "\n"
-#define mk(x,y) make_pair(x,y)
-#define For(i, a, b) for(int i = a; i < b; i++)
-#define Rfor(i, a, b) for(int i = a; i >= b; i--)
-const ll inf = 1e18;
-const int MOD = 998244353;
-vector<vector<vector<ll> > > dp;
-vector<string> a;
-int n, m, d;
-vector<vector<vector<ll> > > pref;
-ll sum(int i, int j1, int j2, int f) {
-    ll val = pref[i][j2][f];
-    if (j1 > 0)
-        val -= pref[i][j1 - 1][f];
-    return val % MOD;
-}
-
-ll get(int i, int j, int f) {
-    if (a[i][j] == '#')return 0;
-    ll res = 0;
-    if (i == n - 1)
-        res++;
-    if (!f) {
-        res += sum(i, max(j - d, 0), min(m - 1, j + d), 1);
-        res -= dp[i][j][1];
-    }
-    if (i < n - 1) {
-        res += sum(i + 1, max(0, j - d + 1), min(m - 1, j + d - 1), 0);
-    }
-    return res % MOD;
-}
-
-void solve() {
-    cin >> n >> m >> d;
-    a.resize(n);
-    For(i, 0, n)
-        cin >> a[i];
-    dp.assign(n, vector<vector<ll> >(m, vector<ll>(2, 0)));
-    pref.assign(n, vector<vector<ll> >(m, vector<ll>(2, 0)));
-    Rfor(i, n-1, 0)
-        Rfor(f, 1, 0) {
-            For(j, 0, m)
-                pref[i][j][f] = dp[i][j][f] = get(i, j, f);
-            For(j, 1, m)
-                pref[i][j][f] += pref[i][j - 1][f];
-        }
-    ll ans = 0;
-    For(i, 0, m)
-        ans += dp[0][i][0];
-    cout << ans%MOD << ln;
-}
-
-int main() {
-    ios::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int ti;
-    cin >> ti;
-    while (ti--) {
-        solve();
-    }
-    return 0;
-}
-
-//freopen("socdist.in", "r",stdin);
-//fr    eopen("socdist.out", "w", stdout)
diff --git a/Problemas/DP/IndependentSet.cpp b/Problemas/DP/IndependentSet.cpp
deleted file mode 100644
index 2564376..0000000
--- a/Problemas/DP/IndependentSet.cpp
+++ /dev/null
@@ -1,63 +0,0 @@
-//https://atcoder.jp/contests/dp/tasks/dp_p
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(),A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-
-const int MOD = 1e9 + 7;
-
-int n;
-vector<vector<int> > adj;
-vector<pair<int, int> > dp;
-
-
-int dfs(int u, int par, int col) {
-    if (adj[u].size() == 1 && u != 0)
-        return 1;
-    if (col == 0 && dp[u].first != -1)
-        return dp[u].first;
-    if (col == 1 && dp[u].second != -1)
-        return dp[u].second;
-    long long c = 1;
-    for (const auto &v: adj[u]) {
-        if (v == par)continue;
-        int val = dfs(v, u, 0);
-        if (col != 1) {
-            val += dfs(v, u, 1);
-            val %= MOD;
-        }
-        c *= val;
-        c %= MOD;
-    }
-    if (col == 0)
-        return dp[u].first = c;
-    return dp[u].second = c;
-}
-
-void solve() {
-    cin >> n;
-    adj.assign(n, vector<int>());
-    fori(i, 0, n-1) {
-        int a, b;
-        cin >> a >> b;
-        a--;
-        b--;
-        adj[a].push_back(b);
-        adj[b].push_back(a);
-    }
-    dp.assign(n, {-1, -1});
-    dfs(0, -1, 0);
-    dfs(0, -1, 1);
-    cout << (dp[0].first + dp[0].second) % MOD << ln;
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t = 1;
-    while (t--)
-        solve();
-    return 0;
-}
diff --git a/Problemas/DP/JumpGame5.java b/Problemas/DP/JumpGame5.java
deleted file mode 100644
index ebc60b3..0000000
--- a/Problemas/DP/JumpGame5.java
+++ /dev/null
@@ -1,47 +0,0 @@
-//https://leetcode.com/problems/jump-game-v/description/
-import java.util.*;
-
-public class Main {
-	static int solve(int[] A, int d) {
-		int n = A.length;
-		Jump[] arr = new Jump[n];
-		for (int i = 0; i < n; i++)
-			arr[i] = new Jump(A[i], i);
-		Arrays.sort(arr, (j1, j2) -> {
-			if (j1.val < j2.val)
-				return -1;
-			if (j1.val > j2.val)
-				return 1;
-			return j1.index - j2.index;
-		});
-		int[] dp = new int[n];
-		int ans = -1;
-		for (int u = 0; u < n; u++) {
-			int index = arr[u].index;
-			int max = 0;
-			for (int i = index - 1; i >= index - d; i--) {
-				if (i < 0 || i >= n || A[i] >= A[index])
-					break;
-				max = Math.max(dp[i], max);
-			}
-			for (int i = index + 1; i <= index + d; i++) {
-				if (i < 0 || i >= n || A[i] >= A[index])
-					break;
-				max = Math.max(dp[i], max);
-			}
-			dp[index] = 1 + max;
-			ans = Math.max(dp[index], ans);
-		}
-		return ans;
-	}
-
-	static class Jump {
-		int val, index;
-
-		Jump(int v, int i) {
-			this.val = v;
-			this.index = i;
-		}
-
-	}
-}
diff --git a/Problemas/DP/Knapsack.py b/Problemas/DP/Knapsack.py
deleted file mode 100644
index d2d7f1a..0000000
--- a/Problemas/DP/Knapsack.py
+++ /dev/null
@@ -1,31 +0,0 @@
-# https://vjudge.net/problem/AtCoder-dp_d
-def f(n,w):
-    if dp[n][w]==-1:
-        if n==-1:
-            dp[n][w] = 0
-        elif w<weights[n]:
-            dp[n][w] = f(n-1,w)
-        else:
-            dp[n][w] = max(f(n-1,w),values[n]+f(n-1,w-weights[n]))
-    return dp[n][w]
-
-
-#Iterative
-def f():
-    for i in range(1, N+1):
-        for w in range(1,W+1): 
-            if w<weights[i-1]:
-               dp[i][w] = dp[i-1][w]
-            else:
-               dp[i][w] = max(dp[i-1][w],dp[i-1][w-weights[i-1]]+values[i-1])
-    return dp[N][W]
-
-W, N = [int(i) for i in input().split()]
-weights = []
-values = []
-for _ in range(N):
-    w,v = [int(i) for i in input().split()]
-    weights.append(w)
-    values.append(v)
-dp = [[0]*(W+1)  for _ in range(N+1)]
-print(f())
diff --git a/Problemas/DP/Last Stone Weight 2.cpp b/Problemas/DP/Last Stone Weight 2.cpp
deleted file mode 100644
index 9a64011..0000000
--- a/Problemas/DP/Last Stone Weight 2.cpp	
+++ /dev/null
@@ -1,21 +0,0 @@
-//https://leetcode.com/problems/last-stone-weight-ii/description/
-
-class Solution {
-public:
-    int lastStoneWeightII(vector<int>& stones) {
-    int total = accumulate(stones.begin(), stones.end(), 0);
-    int half = total / 2;
-    vector<bool> dp(half + 1, false);
-    dp[0] = true;
-
-    for (int stone: stones) 
-        for (int i = half; i >= stone; i--) 
-            dp[i] = dp[i] || dp[i - stone];
-
-    for (int i = half; i >= 0; i--)
-        if (dp[i])
-            return total - 2 * i;
-
-    return 0;
-    }
-};
diff --git a/Problemas/DP/Levenshtein Distance.py b/Problemas/DP/Levenshtein Distance.py
deleted file mode 100644
index 901bac4..0000000
--- a/Problemas/DP/Levenshtein Distance.py	
+++ /dev/null
@@ -1,38 +0,0 @@
-#https://vjudge.net/problem/Aizu-DPL_1_E
-import sys
-sys.setrecursionlimit(1000000)
-#Iterative - Bottom up
-def lev_i(a,b,n,m):
-    dp = [[0]*(m+1) for _ in range(n+1)]
-    for i in range(n+1):
-        for j in range(m+1):
-            if min(i,j)==0:
-                dp[i][j] = max(i,j)
-            elif a[i-1]==b[j-1]:
-                dp[i][j] = dp[i-1][j-1]
-            else:
-                dp[i][j] = min(dp[i][j-1],dp[i-1][j-1],dp[i-1][j])+1
-    return dp[n][m]
-
-#Recurisve - Top down
-def lev_r(a,b,i,j):
-    if memo[i][j]==-1:
-        if min(i,j)==0:
-            memo[i][j] = max(i,j)
-        elif a[i-1]==b[j-1]:
-            memo[i][j] =  lev_r(a,b,i-1,j-1)
-        else:
-            memo[i][j] =  min(lev_r(a,b,i,j-1),lev_r(a,b,i-1,j-1),lev_r(a,b,i-1,j))+1
-    return memo[i][j]
-    
-s1 = input()
-s2 = input()
-n = len(s1)
-m = len(s2)
-#Recurisve - Top down
-memo = [[-1]*(m+1) for _ in range(n+1)]
-print(lev_r(s1,s2,n,m))
-
-#Iterative - Bottom up (Faster than recursive)
-print(lev_i(s1,s2,n,m))
-
diff --git a/Problemas/DP/LongestIncreasingSubsequence.py b/Problemas/DP/LongestIncreasingSubsequence.py
deleted file mode 100644
index 38894e9..0000000
--- a/Problemas/DP/LongestIncreasingSubsequence.py
+++ /dev/null
@@ -1,13 +0,0 @@
-#https://leetcode.com/problems/longest-increasing-subsequence/description/
-#Solution time O(n^2)
-def f(A):
-    n = len(A)
-    lis = [1]*n
-    for k in range(n):
-        for i in range(k):
-            if A[i]<A[k]:
-                lis[k] = max(lis[k],lis[i]+1)
-    return max(lis)
-n = int(input())
-arr = [int(i) for i in input().split()]
-print(f(arr))
diff --git a/Problemas/DP/LongestPalindromicSubstring.py b/Problemas/DP/LongestPalindromicSubstring.py
deleted file mode 100644
index b566bfb..0000000
--- a/Problemas/DP/LongestPalindromicSubstring.py
+++ /dev/null
@@ -1,31 +0,0 @@
-# https://leetcode.com/problems/longest-palindromic-substring/description/
-
-class Solution:
-    def longestPalindrome(self, s: str) -> str:
-        n = len(s)
-        if n < 1:
-            return ""
-        
-        start, end = 0, 0
-
-        for i in range(n):
-            odd = self.expandCenter(s, i, i)
-            even = self.expandCenter(s, i, i+1)
-            longest = max(odd, even)
-            
-            if longest > end - start:
-                #Buscamos el ndice que est a la mitad del palndromo. 
-                #Como longest es la longitud del palndromo, restamos 1 para obtener la longitud real 
-                #(ya que los ndices empiezan en 0). Luego, dividimos entre 2 para obtener el ndice del centro.
-                start = i - (longest - 1) // 2 
-                #Aqu tambin calculamos el ndice del final del palndromo. 
-                #Como i es el ndice del centro del palndromo, sumamos longest // 2 para obtener el ndice del final.
-                end = i + longest // 2
-
-        return s[start:end + 1]
-        
-    def expandCenter(self, s: str, l: int, r: int) -> int:
-        while l >= 0 and r < len(s) and s[l] == s[r]:
-            l -= 1
-            r += 1
-        return len(s[l + 1:r])
diff --git a/Problemas/DP/MaximumDifferenceArray b/Problemas/DP/MaximumDifferenceArray
deleted file mode 100644
index 2934c4a..0000000
--- a/Problemas/DP/MaximumDifferenceArray
+++ /dev/null
@@ -1,30 +0,0 @@
-#Given an array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 <= i < j < n and nums[i] < nums[j]
-#Return the maximum difference. If no such i and j exists, return -1
-
-#Solution time O(n^2), brute force approach
-def maximumDifference(nums):
-    ans = -1
-    n = len(nums)
-    for i in range(n):
-        for j in range(i+1,n):
-            if nums[i] < nums[j]:
-                ans = max(ans,nums[j]-nums[i])
-    return ans
-
-#Solution time O(nlogn), divide and conquer approach
-def maximumDifference(nums):
-    n = len(nums)
-    if n==1:
-        return 0
-    if n==2:
-        if nums[1]>nums[0]:
-            return nums[1]-nums[0]
-        return -1
-    I = maximumDifference(nums[:n//2])
-    D = maximumDifference(nums[n//2:n])
-    minI = min(nums[:n//2])
-    maxD = max(nums[n//2:n])
-    ans = max(I,D,maxD-minI)
-    return -1 if ans==0 else ans
-
-#There is a solution with time O(n)
diff --git a/Problemas/DP/MaximumSelfMatching.java b/Problemas/DP/MaximumSelfMatching.java
deleted file mode 100644
index 58855c0..0000000
--- a/Problemas/DP/MaximumSelfMatching.java
+++ /dev/null
@@ -1,136 +0,0 @@
-import java.io.*;
-import java.util.*;
-
-public class MaximumSelfMatching {
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		String s = in.readLine();
-		int n = s.length();
-		ComplexNumber[] a = new ComplexNumber[n];
-		ComplexNumber[] ainv = new ComplexNumber[n];
-		ComplexNumber[] b = new ComplexNumber[n];
-		ComplexNumber[] binv = new ComplexNumber[n];
-		ComplexNumber[] c = new ComplexNumber[n];
-		ComplexNumber[] cinv = new ComplexNumber[n];
-		Arrays.fill(a, new ComplexNumber(0, 0));
-		Arrays.fill(ainv, new ComplexNumber(0, 0));
-		Arrays.fill(b, new ComplexNumber(0, 0));
-		Arrays.fill(binv, new ComplexNumber(0, 0));
-		Arrays.fill(c, new ComplexNumber(0, 0));
-		Arrays.fill(cinv, new ComplexNumber(0, 0));
-		for (int i = 0; i < n; i++)
-			if (s.charAt(i) == 'a') {
-				a[i] = new ComplexNumber(1, 0);
-				ainv[n - 1 - i] = new ComplexNumber(1, 0);
-			} else if (s.charAt(i) == 'b') {
-				b[i] = new ComplexNumber(1, 0);
-				binv[n - 1 - i] = new ComplexNumber(1, 0);
-			} else {
-				c[i] = new ComplexNumber(1, 0);
-				cinv[n - 1 - i] = new ComplexNumber(1, 0);
-			}
-		long max = 0;
-		long[] aans = polyMult(a, ainv);
-		long[] bans = polyMult(b, binv);
-		long[] cans = polyMult(c, cinv);
-		for (int i = n; i < aans.length; i++) {
-			long val = aans[i] + bans[i] + cans[i];
-			max = Math.max(max, val);
-		}
-		StringBuffer out = new StringBuffer();
-		for (int i = n; i < aans.length; i++) {
-			long val = aans[i] + bans[i] + cans[i];
-			if (val == max)
-				out.append((i - n + 1) + " ");
-		}
-		System.out.println(max);
-		System.out.println(out);
-	}
-
-	static long[] polyMult(ComplexNumber[] a, ComplexNumber[] b) {
-		int m = a.length;
-		int n = b.length;
-		int sz = m + n - 1;
-		int szPrima = nextPowerOf2(sz);
-		a = Arrays.copyOf(a, szPrima);
-		b = Arrays.copyOf(b, szPrima);
-		Arrays.fill(a, m, szPrima, new ComplexNumber(0, 0));
-		Arrays.fill(b, n, szPrima, new ComplexNumber(0, 0));
-		fft(a, 1);
-		fft(b, 1);
-		for (int i = 0; i < a.length; i++)
-			a[i] = a[i].mul(b[i]);
-		long[] c = new long[n + m];
-		fft(a, -1);
-		for (int i = 0; i < c.length; i++)
-			c[i] = Math.round(a[i].real);
-		return c;
-
-	}
-
-	static int nextPowerOf2(int n) {
-		int ans = 1;
-		while (ans < n)
-			ans *= 2;
-		return ans;
-	}
-
-	static void fft(ComplexNumber[] seq, int inv) {
-		int n = seq.length;
-		int shift = 32 - Integer.numberOfTrailingZeros(n);
-		for (int i = 1; i < n; i++) {
-			int j = Integer.reverse(i << shift);
-			if (i < j) {
-				ComplexNumber aux = seq[i];
-				seq[i] = seq[j];
-				seq[j] = aux;
-			}
-		}
-		for (int len = 2; len <= n; len <<= 1) {
-			double angle = 2 * Math.PI / len;
-			ComplexNumber wn = new ComplexNumber(Math.cos(angle), Math.sin(angle) * inv);
-			for (int i = 0; i < n; i += len) {
-				ComplexNumber w = new ComplexNumber(1, 0);
-				for (int j = 0; j < len / 2; j++) {
-					ComplexNumber u = seq[i + j];
-					ComplexNumber v = seq[i + j + len / 2].mul(w);
-					seq[i + j] = u.add(v);
-					seq[i + j + len / 2] = u.sub(v);
-					w = w.mul(wn);
-				}
-			}
-		}
-		if (inv == -1)
-			for (int i = 0; i < seq.length; i++)
-				seq[i] = seq[i].mul(new ComplexNumber((double) 1 / n, 0));
-	}
-
-	static class ComplexNumber {
-		double real;
-		double imag;
-
-		ComplexNumber(double r, double i) {
-			real = r;
-			imag = i;
-		}
-
-		ComplexNumber add(ComplexNumber b) {
-			return new ComplexNumber(real + b.real, imag + b.imag);
-		}
-
-		ComplexNumber sub(ComplexNumber b) {
-			return new ComplexNumber(real - b.real, imag - b.imag);
-		}
-
-		ComplexNumber mul(ComplexNumber b) {
-			return new ComplexNumber(real * b.real - imag * b.imag, real * b.imag + imag * b.real);
-		}
-
-		public String toString() {
-			return "(" + real + ", " + imag + "j)";
-		}
-
-	}
-
-}
diff --git a/Problemas/DP/PolynomialMultiplication1.py b/Problemas/DP/PolynomialMultiplication1.py
deleted file mode 100644
index 92cef09..0000000
--- a/Problemas/DP/PolynomialMultiplication1.py
+++ /dev/null
@@ -1,21 +0,0 @@
-#Solution time: O(n^2)
-def polyMultiplication(poli1,poli2):
-    m = len(poli1)
-    n = len(poli2)
-    sz = m+n-1
-    ans = [0]*sz
-    for i in range(m):
-        for j in range(n):
-            ans[i+j]+=poli1[i]*poli2[j]
-    return ans,sz
-t = int(input())
-for _ in range(t):
-    n1 = int(input())
-    poly1 = [int(i) for i in input().split()]
-    n2 = int(input())
-    poly2 = [int(i) for i in input().split()]
-    poly3,grado = polyMultiplication(poly1,poly2)
-    print(grado-1)
-    print(*poly3)
-
-
diff --git a/Problemas/DP/PolynomialMultiplication2.py b/Problemas/DP/PolynomialMultiplication2.py
deleted file mode 100644
index fea67e2..0000000
--- a/Problemas/DP/PolynomialMultiplication2.py
+++ /dev/null
@@ -1,69 +0,0 @@
-#Solution time: O(nlogn)
-import math
-
-def nextPowerOf2(n):
-    ans = 1
-    while ans < n:
-        ans <<= 1
-    return ans
-
-def fft(seq):
-    if len(seq) == 1:
-        return seq
-    else:
-        n = len(seq)
-        seq_even = [seq[2*j] for j in range(n//2)]
-        seq_odd = [seq[2*j+1] for j in range(n//2)] 
-        s1 = fft(seq_even)
-        s2 = fft(seq_odd)
-        fft_ret = [0]*n
-        w = 1
-        wn = (math.cos(2 * math.pi /n) + math.sin(2 * math.pi/n)*1j) 
-        for k in range(n//2):
-            fft_ret[k] = (s1[k] + w * s2[k])
-            fft_ret[k+n//2] = (s1[k] - w * s2[k])
-            w = w * wn
-        return fft_ret
-    
-def inverse_fft(seq):
-    if len(seq) == 1:
-        return seq
-    else:
-        n = len(seq)
-        seq_even = [seq[2*j] for j in range(n//2)]
-        seq_odd = [seq[2*j+1] for j in range(n//2)]
-        s1 = inverse_fft(seq_even)
-        s2 = inverse_fft(seq_odd)
-        fft_ret = [0]*n
-        w = 1
-        wn = math.cos(2 * math.pi /n) - math.sin(2 * math.pi/n)*1j
-        for k in range(n//2):
-            fft_ret[k] = 0.5* (s1[k] + w * s2[k])
-            fft_ret[k+n//2] = 0.5 * (s1[k] - w * s2[k])
-            w = w * wn
-        return fft_ret
-    
-
-
-def polyMultiplication(a,b):
-    m = len(a)
-    n = len(b)
-    sz = m+n-1
-    szPrima = nextPowerOf2(sz)
-    a.extend([0 for i in range(m+1,szPrima+1)])
-    b.extend([0 for i in range(n+1,szPrima+1)])
-    fft1 = fft(a)
-    fft2 = fft(b)
-    fft3 = [i*j for i,j in zip(fft1,fft2)]
-    c = [round(i.real) for i in inverse_fft(fft3)]
-    return c, sz-1
-
-t = int(input())
-for _ in range(t):
-    n1 = int(input())
-    poly1 = [int(i) for i in input().split()]
-    n2 = int(input())
-    poly2 = [int(i) for i in input().split()]
-    poly3,grado = polyMultiplication(poly1,poly2)
-    print(grado)
-    print(*poly3[:grado+1])
diff --git a/Problemas/DP/StoneGame.py b/Problemas/DP/StoneGame.py
deleted file mode 100644
index 863f05a..0000000
--- a/Problemas/DP/StoneGame.py
+++ /dev/null
@@ -1,35 +0,0 @@
-"""To solve this problem we have to compute the nim sum of all the piles.
-To compute the nim sum between two integers, we write them in base two (binary system).
-Then, we apply the xor operator for each pair of digits of the integers in base two representation. (Bitwise).
-For example:
-let n = 2:
-a = 7, the first pile with 7 stones.
-b = 8, the second pile with 8 stones.
-7 written in base two is 111, 8 written in base two is 1000.
-111 hasn't the same number of digits as 1000, so we add a zero at the beginning and it won't change the number.
-0111
-1000
--xor-
-1111.
-1111 in base 10 (decimal system) is equals to 15.
-So, 7 xor 8 = 15.
-
-
--Theorem:
-If the game has n piles with a0, a1, a2, ... an-1 stones respectively.
-Jack will win the game if and only if the nim sum of all the piles is not equal to zero. He will lose otherwise.
-
-Using this theory, this problem can be solved easily in Python using the circumflex(^) operator to compute the xor operation
-between all the piles.
-"""
-
-#Solution: 
-while True:
-    n = int(input())
-    if n==0:
-        break
-    ans = 0
-    for i in [int(i) for i in input().split()]:
-        ans^=i 
-    print("Yes" if ans!=0 else "No")
-
diff --git a/Problemas/DP/TrainSorting.py b/Problemas/DP/TrainSorting.py
deleted file mode 100644
index 0853c77..0000000
--- a/Problemas/DP/TrainSorting.py
+++ /dev/null
@@ -1,28 +0,0 @@
-#Longest Increasing subsequence
-def f(A):
-    n = len(A)
-    lis = [1]*n
-    for i in range(n):
-        for j in range(i):
-            if A[j] < A[i]:
-                lis[i] = max(lis[i],lis[j]+1)
-    return lis
-
-#Longest Decreasing subsequence
-def g(A):
-    n = len(A)
-    lis = [1] * n
-    for i in range(n):
-        for j in range(i):
-            if A[i] < A[j]:
-                lis[i] = max(lis[i],lis[j] + 1) 
-    return lis
-
-n = int(input())
-t = [0]*n
-for i in reversed(range(n)):
-    t[i] = int(input())
-ans = 0
-for i,j in zip(f(t),g(t)):
-    ans = max(ans,i+j-1)
-print(ans)
diff --git a/Problemas/DP/UniquePaths.java b/Problemas/DP/UniquePaths.java
deleted file mode 100644
index 1daea32..0000000
--- a/Problemas/DP/UniquePaths.java
+++ /dev/null
@@ -1,19 +0,0 @@
-// https://leetcode.com/problems/unique-paths/description/
-
-class Solution {
-    public int uniquePaths(int m, int n) {
-        int[][] dp = new int[m][n];
-        for (int i = 0; i < m; i++){
-            dp[i][0] = 1;
-        } 
-        for (int j = 0; j < n; j++){
-            dp[0][j] = 1;
-        }
-        for(int i = 1; i < m; i++){
-            for (int j = 1; j < n; j++){
-                dp[i][j] = dp[i-1][j] + dp[i][j-1];
-            }
-        }
-        return dp[m-1][n-1];  
-    }
-}
diff --git a/Problemas/DP/UniquePathsII.cpp b/Problemas/DP/UniquePathsII.cpp
deleted file mode 100644
index c6b0d38..0000000
--- a/Problemas/DP/UniquePathsII.cpp
+++ /dev/null
@@ -1,49 +0,0 @@
-// https://leetcode.com/problems/unique-paths-ii/
-
-#include <vector>
-using namespace std;
-
-class Solution {
-public:
-    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
-        if (obstacleGrid.empty() || obstacleGrid[0].empty()) {
-            return 0;
-        }
-
-        int m = obstacleGrid.size();
-        int n = obstacleGrid[0].size();
-        vector<vector<int>> dp(m, vector<int>(n, 0));
-
-        if (obstacleGrid[0][0] == 1) {
-            return 0;
-        }
-
-        dp[0][0] = 1;
-
-        for (int i = 1; i < m; i++) {
-            if (obstacleGrid[i][0] == 0) {
-                dp[i][0] = dp[i - 1][0];
-            } else {
-                break;
-            }
-        }
-
-        for (int j = 1; j < n; j++) {
-            if (obstacleGrid[0][j] == 0) {
-                dp[0][j] = dp[0][j - 1];
-            } else {
-                break;
-            }
-        }
-
-        for (int i = 1; i < m; i++) {
-            for (int j = 1; j < n; j++) {
-                if (obstacleGrid[i][j] == 0) {
-                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
-                }
-            }
-        }
-
-        return dp[m - 1][n - 1];
-    }
-};
diff --git a/Problemas/DP/WordBreak.cpp b/Problemas/DP/WordBreak.cpp
deleted file mode 100644
index d3f61b6..0000000
--- a/Problemas/DP/WordBreak.cpp
+++ /dev/null
@@ -1,21 +0,0 @@
-// https://leetcode.com/problems/word-break/
-
-#include <vector>
-#include <string>
-
-class Solution {
-public:
-    bool wordBreak(string s, vector<string>& wordDict) {
-        vector<bool> dp(s.size() + 1, false);
-        dp[s.size()] = true;
-
-        for (int i = s.size()-1; i >= 0; --i){
-            for (const auto& w : wordDict){
-                if (i + w.size() <= s.size() && s.substr(i, w.size()) == w)
-                    dp[i] = dp[i + w.size()];
-                if (dp[i]) break;
-            }
-        }
-        return dp[0];
-    }
-};
diff --git "a/Problemas/Geometr\303\255a Computacional/AbstractArt.java" "b/Problemas/Geometr\303\255a Computacional/AbstractArt.java"
deleted file mode 100644
index 0c7c849..0000000
--- "a/Problemas/Geometr\303\255a Computacional/AbstractArt.java"	
+++ /dev/null
@@ -1,82 +0,0 @@
-import java.awt.*;
-import java.awt.geom.*;
-import java.io.*;
-import java.util.*;
-
-public class AbstractArt {
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		int n = in.nextInt();
-		Polygon[] poligonos = new Polygon[n];
-		for (int i = 0; i < n; i++) {
-			int m = in.nextInt();
-			int[] x = new int[m];
-			int[] y = new int[m];
-			for (int j = 0; j < m; j++) {
-				x[j] = in.nextInt();
-				y[j] = in.nextInt();
-			}
-			poligonos[i] = new Polygon(x, y, m);
-		}
-		double ans = 0;
-		Area a = new Area();
-		for (Polygon p : poligonos) {
-			Area aux = new Area(p);
-			ans += Area(aux);
-			a.add(aux);
-		}
-		System.out.print(ans);
-		System.out.println(" " + Area(a));
-
-	}
-
-	static double Area(Area a) {
-		double ans = 0;
-		PathIterator it = a.getPathIterator(null);
-		double[] coords = new double[6];
-		double[] first = new double[2];
-		double[] last = new double[2];
-		while (!it.isDone()) {
-			int val = it.currentSegment(coords);
-			if (val == 0) {
-				first[0] = coords[0];
-				first[1] = coords[1];
-				last[0] = coords[0];
-				last[1] = coords[1];
-			} else if (val == 1) {
-				ans += (last[0] * coords[1] - last[1] * coords[0]);
-				last[0] = coords[0];
-				last[1] = coords[1];
-			} else if (val == 4)
-				ans += (last[0] * first[1] - last[1] * first[0]);
-
-			it.next();
-		}
-		return Math.abs(ans) / 2;
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens())
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-	}
-
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/BeeHousePerimeter.java" "b/Problemas/Geometr\303\255a Computacional/BeeHousePerimeter.java"
deleted file mode 100644
index 2e18531..0000000
--- "a/Problemas/Geometr\303\255a Computacional/BeeHousePerimeter.java"	
+++ /dev/null
@@ -1,267 +0,0 @@
-import java.io.*;
-import java.util.*;
-
-public class BeeHousePerimeter {
-	static int[][] matrix;
-	static int r;
-	static int n;
-	static HashSet<Integer> casa;
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		r = in.nextInt();
-		int k = in.nextInt();
-		casa = new HashSet<>();
-		for (int i = 0; i < k; i++)
-			casa.add(in.nextInt());
-		buildMatrix();
-		boolean[] visited = new boolean[n];
-		int ans = 0;
-		for (int i = 0; i < matrix[0].length; i++) {
-			int cell = matrix[0][i];
-			if (!visited[cell])
-				ans += bfs(cell, visited);
-		}
-		for (int i = 0; i < matrix[matrix.length - 1].length; i++) {
-			int cell = matrix[matrix.length - 1][i];
-			if (!visited[cell])
-				ans += bfs(cell, visited);
-		}
-		for (int i = 0; i < matrix.length; i++) {
-			int cell = matrix[i][0];
-			if (!visited[cell])
-				ans += bfs(cell, visited);
-		}
-		for (int i = 0; i < matrix.length; i++) {
-			int cell = matrix[i][matrix[i].length - 1];
-			if (!visited[cell])
-				ans += bfs(cell, visited);
-		}
-		System.out.println(ans);
-	}
-
-	static int bfs(int s, boolean[] visited) {
-		if (casa.contains(s)) {
-			visited[s] = true;
-			return 6 - deg(s);
-		}
-		Queue<Integer> Q = new LinkedList<>();
-		Q.add(s);
-		visited[s] = true;
-		int ans = 0;
-		while (!Q.isEmpty()) {
-			int u = Q.poll();
-			for (int v : getVecinos(u))
-				if (casa.contains(v))
-					ans++;
-				else if (!visited[v]) {
-					visited[v] = true;
-					Q.add(v);
-				}
-		}
-		return ans;
-	}
-
-	static int deg(int u) {
-		return getVecinos(u).size();
-	}
-
-	static ArrayList<Integer> getVecinos(int u) {
-		ArrayList<Integer> vecinos = new ArrayList<>();
-		int indiceFila = 0;
-		int indiceColumna = 0;
-		for (int i = 0; i < matrix.length; i++) {
-			int val = Arrays.binarySearch(matrix[i], u);
-			if (val >= 0) {
-				indiceFila = i;
-				indiceColumna = val;
-				break;
-			}
-		}
-		if (indiceColumna == 0) {
-			if (indiceFila == 0) {
-				vecinos.add(matrix[0][1]);
-				vecinos.add(matrix[1][0]);
-				vecinos.add(matrix[1][1]);
-				return vecinos;
-			}
-			if (indiceFila == (r - 1)) {
-				vecinos.add(matrix[r - 2][0]);
-				vecinos.add(matrix[r - 1][1]);
-				vecinos.add(matrix[r][0]);
-				return vecinos;
-			}
-			if (indiceFila == matrix.length - 1) {
-				vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-				vecinos.add(matrix[indiceFila - 1][indiceColumna + 1]);
-				vecinos.add(matrix[indiceFila][indiceColumna + 1]);
-				return vecinos;
-			} else {
-				if (indiceFila < (r - 1)) {
-					vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-					vecinos.add(matrix[indiceFila][indiceColumna + 1]);
-					vecinos.add(matrix[indiceFila + 1][indiceColumna]);
-					vecinos.add(matrix[indiceFila + 1][indiceColumna + 1]);
-					return vecinos;
-				} else {
-					vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-					vecinos.add(matrix[indiceFila][indiceColumna + 1]);
-					vecinos.add(matrix[indiceFila + 1][indiceColumna]);
-					vecinos.add(matrix[indiceFila - 1][indiceColumna + 1]);
-					return vecinos;
-				}
-			}
-		}
-		if (indiceColumna == matrix[indiceFila].length - 1) {
-			if (indiceFila == 0) {
-				vecinos.add(matrix[0][matrix[indiceFila].length - 2]);
-				vecinos.add(matrix[1][matrix[indiceFila].length - 1]);
-				vecinos.add(matrix[1][matrix[indiceFila].length]);
-				return vecinos;
-			}
-			if (indiceFila == (r - 1)) {
-				vecinos.add(matrix[r - 2][matrix[indiceFila].length - 2]);
-				vecinos.add(matrix[r - 1][matrix[indiceFila].length - 2]);
-				vecinos.add(matrix[r][matrix[indiceFila].length - 2]);
-				return vecinos;
-			}
-			if (indiceFila == matrix.length - 1) {
-				vecinos.add(matrix[matrix.length - 2][indiceColumna]);
-				vecinos.add(matrix[matrix.length - 2][indiceColumna + 1]);
-				vecinos.add(matrix[matrix.length - 1][indiceColumna - 1]);
-				return vecinos;
-			} else {
-				if (indiceFila < r - 1) {
-					vecinos.add(matrix[indiceFila - 1][indiceColumna - 1]);
-					vecinos.add(matrix[indiceFila][indiceColumna - 1]);
-					vecinos.add(matrix[indiceFila + 1][indiceColumna]);
-					vecinos.add(matrix[indiceFila + 1][indiceColumna + 1]);
-					return vecinos;
-				} else {
-					vecinos.add(matrix[indiceFila - 1][indiceColumna + 1]);
-					vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-					vecinos.add(matrix[indiceFila][indiceColumna - 1]);
-					vecinos.add(matrix[indiceFila + 1][indiceColumna - 1]);
-					return vecinos;
-				}
-			}
-		}
-		if (indiceFila == 0) {
-			vecinos.add(matrix[indiceFila][indiceColumna - 1]);
-			vecinos.add(matrix[indiceFila][indiceColumna + 1]);
-			vecinos.add(matrix[indiceFila + 1][indiceColumna]);
-			vecinos.add(matrix[indiceFila + 1][indiceColumna + 1]);
-			return vecinos;
-		}
-		if (indiceFila == matrix.length - 1) {
-			vecinos.add(matrix[indiceFila][indiceColumna - 1]);
-			vecinos.add(matrix[indiceFila][indiceColumna + 1]);
-			vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-			vecinos.add(matrix[indiceFila - 1][indiceColumna + 1]);
-			return vecinos;
-		} else {
-			vecinos.add(matrix[indiceFila][indiceColumna - 1]);
-			vecinos.add(matrix[indiceFila][indiceColumna + 1]);
-			if (indiceFila < (r - 1)) {
-				vecinos.add(matrix[indiceFila - 1][indiceColumna - 1]);
-				vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-				vecinos.add(matrix[indiceFila + 1][indiceColumna]);
-				vecinos.add(matrix[indiceFila + 1][indiceColumna + 1]);
-			} else if (indiceFila == (r - 1)) {
-				vecinos.add(matrix[indiceFila - 1][indiceColumna - 1]);
-				vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-				vecinos.add(matrix[indiceFila + 1][indiceColumna - 1]);
-				vecinos.add(matrix[indiceFila + 1][indiceColumna]);
-			} else {
-				vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-				vecinos.add(matrix[indiceFila - 1][indiceColumna + 1]);
-				vecinos.add(matrix[indiceFila + 1][indiceColumna - 1]);
-				vecinos.add(matrix[indiceFila + 1][indiceColumna]);
-			}
-			return vecinos;
-		}
-
-	}
-
-	static void buildMatrix() {
-		int nrows = (r * 2) - 1;
-		int ncol = r;
-		int num = 1;
-		boolean cond = true;
-		matrix = new int[nrows][];
-		for (int i = 0; i < nrows; i++) {
-			int[] row = new int[ncol];
-			for (int j = 0; j < ncol; j++) {
-				row[j] = num;
-				num++;
-			}
-			matrix[i] = row;
-			if (cond)
-				ncol++;
-			else
-				ncol--;
-			if (i + 1 == r) {
-				ncol -= 2;
-				cond = false;
-			}
-
-		}
-		n = num;
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/Bright Lights.java" "b/Problemas/Geometr\303\255a Computacional/Bright Lights.java"
deleted file mode 100644
index 6ad6ebd..0000000
--- "a/Problemas/Geometr\303\255a Computacional/Bright Lights.java"	
+++ /dev/null
@@ -1,129 +0,0 @@
-//https://vjudge.net/problem/UVA-10927
-import java.io.*;
-import java.util.*;
-
-public class Main {
-    public static void main(String[] args) throws Exception{
-        Scanner sc=new Scanner();
-        PrintWriter out=new PrintWriter(System.out);
-        int ds=1;
-        while (true){
-            int n=sc.nextInt();
-            if(n==0)
-                break;
-            HashMap<Double,Integer> map=new HashMap<>();
-            TreeSet<T> set=new TreeSet<>();
-            Point[] a=new Point[n];
-            for (int i = 0; i < n; i++)
-                a[i]=new Point(sc.nextInt(),sc.nextInt(),sc.nextInt());
-            Arrays.sort(a);
-            for (int i = 0; i < n; i++) {
-                double m=m(a[i]);
-                if(!map.containsKey(m))
-                    map.put(m,a[i].z);
-                else
-                    if(map.get(m)>=a[i].z) {
-                        int x=a[i].x;
-                        int y=a[i].y;
-                        set.add(new T(x,y));
-                    }
-                    else if(map.get(m)<a[i].z)
-                        map.put(m,a[i].z);
-
-            }
-            out.println("Data set "+ds+":");
-            if(set.size()==0)
-                out.println("All the lights are visible.");
-            else{
-                out.println("Some lights are not visible:");
-                while (set.size()>1){
-                    T s=set.pollFirst();
-                    out.println("x = "+s.x+", y = "+s.y+";");
-                }
-                T s=set.pollFirst();
-                out.println("x = "+s.x+", y = "+s.y+".");
-            }
-            ds++;
-        }
-        out.close();
-    }
-    static double m(Point a){
-        return (double) (a.y) /(a.x);
-    }
-    static class T implements Comparable<T>{
-        int x,y;
-        public T(int a, int b){
-            x=a;
-            y=b;
-        }
-
-        public int compareTo(T o) {
-            if(x<o.x) return -1;
-            if(x>o.x) return 1;
-            if(y<o.y) return -1;
-            if(y>o.y) return 1;
-            return 0;
-        }
-        public String toString(){
-            return "("+x+", "+y+")";
-        }
-    }
-    static class Point implements Comparable<Point>{
-        int x,y,z;
-        public Point(int a, int b, int c ){
-            x=a;
-            y=b;
-            z=c;
-        }
-
-        public int compareTo(Point o) {
-            if(Math.abs(x)<Math.abs(o.x)) return -1;
-            if(Math.abs(x)>Math.abs(o.x)) return 1;
-            if(Math.abs(y)<Math.abs(o.y)) return -1;
-            if(Math.abs(y)>Math.abs(o.y)) return 1;
-            return 0;
-        }
-        public String toString(){
-            return "("+x+", "+y+")";
-        }
-    }
-
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/CheckStraightLine.py" "b/Problemas/Geometr\303\255a Computacional/CheckStraightLine.py"
deleted file mode 100644
index b212350..0000000
--- "a/Problemas/Geometr\303\255a Computacional/CheckStraightLine.py"	
+++ /dev/null
@@ -1,15 +0,0 @@
-#https://leetcode.com/problems/check-if-it-is-a-straight-line/?envType=problem-list-v2&envId=geometry
-class Solution:
-    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:
-        def collinear(p1, p2, p3):
-            x1, y1 = p1
-            x2, y2 = p2
-            x3, y3 = p3
-
-            cross_product = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)
-            return cross_product == 0
-        res = True
-        n = len(coordinates)
-        for i in range(n - 2):
-            res = res and collinear(coordinates[i], coordinates[i + 1], coordinates[i + 2])
-        return res
diff --git "a/Problemas/Geometr\303\255a Computacional/ClosestPointPair.cpp" "b/Problemas/Geometr\303\255a Computacional/ClosestPointPair.cpp"
deleted file mode 100644
index 497fefe..0000000
--- "a/Problemas/Geometr\303\255a Computacional/ClosestPointPair.cpp"	
+++ /dev/null
@@ -1,109 +0,0 @@
-//https://www.spoj.com/problems/CLOPPAIR/en/
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(),A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define ll long long
-#define ull unsigned long long
-
-
-struct pt {
-    ll x, y, id;
-};
-
-struct cmp_x {
-    bool operator()(const pt &a, const pt &b) const {
-        return a.x < b.x || (a.x == b.x && a.y < b.y);
-    }
-};
-
-struct cmp_y {
-    bool operator()(const pt &a, const pt &b) const {
-        return a.y < b.y;
-    }
-};
-
-istream &operator>>(istream &is, pt &p) {
-    return is >> p.x >> p.y;
-}
-
-
-ostream &operator<<(ostream &os, const pt &p) {
-    return os << "(" << p.x << "," << p.y << ")";
-}
-
-int n;
-vector<pt> t;
-
-vector<pt> a;
-
-double mindist;
-pair<ll, ll> best_pair;
-
-void upd_ans(const pt &a, const pt &b) {
-    double dist = sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
-    if (dist < mindist) {
-        mindist = dist;
-        best_pair = {a.id, b.id};
-    }
-}
-
-
-void rec(int l, int r) {
-    if (r - l <= 3) {
-        for (int i = l; i < r; ++i) {
-            for (int j = i + 1; j < r; ++j) {
-                upd_ans(a[i], a[j]);
-            }
-        }
-        sort(a.begin() + l, a.begin() + r, cmp_y());
-        return;
-    }
-
-    int m = (l + r) >> 1;
-    int midx = a[m].x;
-    rec(l, m);
-    rec(m, r);
-
-    merge(a.begin() + l, a.begin() + m, a.begin() + m, a.begin() + r, t.begin(), cmp_y());
-    copy(t.begin(), t.begin() + r - l, a.begin() + l);
-    int tsz = 0;
-    for (int i = l; i < r; ++i) {
-        if (abs(a[i].x - midx) < mindist) {
-            for (int j = tsz - 1; j >= 0 && a[i].y - t[j].y < mindist; --j)
-                upd_ans(a[i], t[j]);
-            t[tsz++] = a[i];
-        }
-    }
-}
-
-void solve() {
-    cin >> n;
-    a.assign(n, {});
-    fori(i, 0, n) {
-        cin >> a[i];
-        a[i].id = i;
-    }
-    t.resize(n);
-    sort(a.begin(), a.end(), cmp_x());
-    mindist = 1E20;
-    rec(0, n);
-    ll x1 = best_pair.first;
-    ll x2 = best_pair.second;
-    if (x1 < x2)
-        cout << x1 << " " << x2 << " " << fixed << setprecision(6) << mindist << ln;
-    else
-        cout << x2 << " " << x1 << " " << fixed << setprecision(6) << mindist << ln;
-}
-
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t = 1;
-    while (t--)
-        solve();
-    return 0;
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/Disks.py" "b/Problemas/Geometr\303\255a Computacional/Disks.py"
deleted file mode 100644
index acb95d4..0000000
--- "a/Problemas/Geometr\303\255a Computacional/Disks.py"	
+++ /dev/null
@@ -1,41 +0,0 @@
-#https://codeforces.com/contest/1949/problem/I
-import sys
-sys.setrecursionlimit(100000)
-def dfs(t,s,color,state,g,set):
-    if(state[s]!=0):
-        if(state[s]!=color):
-            t[0]=False
-        return
-    g[color]+=1
-    state[s]=color
-    for v in range(n):
-        r=set[v][2]+set[s][2]
-        x=set[v][0]-set[s][0]
-        y=set[v][1]-set[s][1]
-        if(r*r==x*x+y*y):
-            dfs(t,v,1 if color==2 else 2,state,g,set)
-n=int(input())
-adj=[None]*n
-state=[0]*n
-set=[None]*n
-for i in range(n):
-    adj[i]=[]
-for i in range(n):
-    set[i]=([int(i) for i in input().split()])
-c=False
-for i in range(n):
-    if(state[i]==0):
-        t=[True]
-        grupo=[0,0,0]
-        dfs(t,i,1,state,grupo,set)
-        if(t[0]and grupo[1]!=grupo[2]):
-            c=True
-if(c):
-    print("YES")
-else:
-    print("NO")
-
-
-
-
-
diff --git "a/Problemas/Geometr\303\255a Computacional/FindingLines.java" "b/Problemas/Geometr\303\255a Computacional/FindingLines.java"
deleted file mode 100644
index 0f4e51a..0000000
--- "a/Problemas/Geometr\303\255a Computacional/FindingLines.java"	
+++ /dev/null
@@ -1,66 +0,0 @@
-import java.io.*;
-import java.util.*;
-
-public class FindingLines {
-	static int n;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st;
-		n = Integer.parseInt(in.readLine());
-		double p = Double.parseDouble(in.readLine());
-		Point[] puntos = new Point[n];
-		for (int i = 0; i < n; i++) {
-			st = new StringTokenizer(in.readLine());
-			puntos[i] = new Point(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));
-		}
-		System.out.println(solve(puntos, p) ? "possible" : "impossible");
-
-	}
-
-	static boolean solve(Point[] puntos, double p) {
-		if (n < 3)
-			return true;
-		Random rand = new Random();
-		for (int i = 0; i < 250; i++) {
-			Point p1 = puntos[rand.nextInt(0, n)];
-			Point p2 = puntos[rand.nextInt(0, n)];
-			if (p1 == p2 || p1.equals(p2))
-				continue;
-			double frac = 0;
-			Point vector1 = restarVectores(p2, p1);
-			for (Point point : puntos) {
-				Point vector2 = restarVectores(point, p1);
-				if (productoCruzado(vector2, vector1) == 0)
-					frac++;
-				if ((frac / n) >= (p / 100))
-					return true;
-			}
-		}
-
-		return false;
-	}
-
-	static Point restarVectores(Point p1, Point p2) {
-		return new Point(p1.x - p2.x, p1.y - p2.y);
-	}
-
-	static int productoCruzado(Point p1, Point p2) {
-		return p1.x * p2.y - p1.y * p2.x;
-	}
-
-	static class Point {
-		int x;
-		int y;
-
-		Point(int x, int y) {
-			this.x = x;
-			this.y = y;
-		}
-
-		public String toString() {
-			return "(" + x + ", " + y + ")";
-		}
-	}
-
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/GenerateRandomPointInACircle.py" "b/Problemas/Geometr\303\255a Computacional/GenerateRandomPointInACircle.py"
deleted file mode 100644
index e926ead..0000000
--- "a/Problemas/Geometr\303\255a Computacional/GenerateRandomPointInACircle.py"	
+++ /dev/null
@@ -1,24 +0,0 @@
-#https://leetcode.com/problems/generate-random-point-in-a-circle/?envType=problem-list-v2&envId=geometry&difficulty=MEDIUM
-import random
-import math
-
-class Solution:
-
-    def __init__(self, radius: float, x_center: float, y_center: float):
-        self.radius = radius
-        self.x_center = x_center
-        self.y_center = y_center        
-
-    def randPoint(self) -> List[float]:
-        r = self.radius * math.sqrt(random.random())
-        theta = random.uniform(0, 2 * math.pi)
-        x = self.x_center + r * math.cos(theta)
-        y = self.y_center + r * math.sin(theta)
-        return [x,y]
-
-#Explanation
-#Let us use polar coordinates:
-x = R * cos(theta)
-y = R * sin(theta).
-#theta
-theta = values between 0 and 2pi
diff --git "a/Problemas/Geometr\303\255a Computacional/Goat Rope.cpp" "b/Problemas/Geometr\303\255a Computacional/Goat Rope.cpp"
deleted file mode 100644
index db8803e..0000000
--- "a/Problemas/Geometr\303\255a Computacional/Goat Rope.cpp"	
+++ /dev/null
@@ -1,73 +0,0 @@
-//https://open.kattis.com/problems/goatrope
-#include <bits/stdc++.h>
-using namespace std;
-#define ll long long
-const int MAXN = 1e5 + 5;
-const int MOD = 1e9 + 7;
-
-double distance(double x1, double y1, double x2, double y2) {
-    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
-}
-
-// Funcin para calcular la distancia de un punto a un segmento de lnea
-double distance_to_segment(double xp, double yp, double x1, double y1, double x2, double y2) {
-    double A = xp - x1;
-    double B = yp - y1;
-    double C = x2 - x1;
-    double D = y2 - y1;
-
-    double dot = A * C + B * D;
-    double len_sq = C * C + D * D;
-    double param = -1;
-
-    if (len_sq != 0)
-        param = dot / len_sq;
-
-    double xx, yy;
-
-    if (param < 0) {
-        xx = x1;
-        yy = y1;
-    } else if (param > 1) {
-        xx = x2;
-        yy = y2;
-    } else {
-        xx = x1 + param * C;
-        yy = y1 + param * D;
-    }
-
-    return distance(xp, yp, xx, yy);
-}
-
-void solve() {
-    int x0, y0, x1, y1, x2, y2;
-    cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2;
-
-    // Asegurarse de que x1 < x2 y y1 < y2
-    if (x1 > x2) swap(x1, x2);
-    if (y1 > y2) swap(y1, y2);
-
-    // Distancia a los lados del rectngulo
-    double dist_left = distance_to_segment(x0, y0, x1, y1, x1, y2);   // Lado izquierdo
-    double dist_right = distance_to_segment(x0, y0, x2, y1, x2, y2);  // Lado derecho
-    double dist_bottom = distance_to_segment(x0, y0, x1, y1, x2, y1); // Lado inferior
-    double dist_top = distance_to_segment(x0, y0, x1, y2, x2, y2);    // Lado superior
-
-    // Distancia a las esquinas del rectngulo
-    double dist_corner1 = distance(x0, y0, x1, y1); // Esquina inferior izquierda
-    double dist_corner2 = distance(x0, y0, x1, y2); // Esquina superior izquierda
-    double dist_corner3 = distance(x0, y0, x2, y1); // Esquina inferior derecha
-    double dist_corner4 = distance(x0, y0, x2, y2); // Esquina superior derecha
-
-    double min_dist = min({dist_left, dist_right, dist_bottom, dist_top, dist_corner1, dist_corner2, dist_corner3, dist_corner4});
-  
-    cout << fixed << setprecision(6) << min_dist << endl;
-}
-
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/HittingTheTargets.py" "b/Problemas/Geometr\303\255a Computacional/HittingTheTargets.py"
deleted file mode 100644
index 0d4d563..0000000
--- "a/Problemas/Geometr\303\255a Computacional/HittingTheTargets.py"	
+++ /dev/null
@@ -1,65 +0,0 @@
-class Rectangle:
-    def __init__(self, x1,y1,x2,y2):
-        self.x1 = x1
-        self.y1 = y1
-        self.x2 = x2
-        self.y2 = y2
-    
-    def __str__(self):
-        return f"({self.x1}, {self.y1}) ({self.x2}, {self.y2})"
-        
-class Circle:
-    def __init__(self, x,y,r):
-        self.x = x
-        self.y = y
-        self.r = r
-    
-    def __str__(self):
-        return f"({self.x}, {self.y}, {self.r})"
-
-class Point:
-    def __init__(self,x,y):
-        self.x = x
-        self.y = y
-    
-    def __str__(self):
-        return f"({self.x}, {self.y})"
-
-
-def isInRectangle(p:Point,rec:Rectangle):
-    isX = False
-    isY = False
-    if p.x>=rec.x1 and p.x<=rec.x2:
-        isX = True
-    if p.y>=rec.y1 and p.y<=rec.y2:
-        isY = True
-    return isX and isY
-
-dist = lambda p1,p2: ((p1.x-p2.x)**2+(p1.y-p2.y)**2)**0.5
-
-def isInCircle(p:Point,c:Circle):
-    return dist(p,Point(c.x,c.y))<=c.r
-
-rectangulos = []
-circulos = []
-
-m = int(input())
-for _ in range(m):
-    s = input().split()
-    if s[0] == "rectangle":
-        rectangulos.append(Rectangle(int(s[1]),int(s[2]),int(s[3]),int(s[4])))
-    else:
-        circulos.append(Circle(int(s[1]),int(s[2]),int(s[3])))
-
-n = int(input())
-for _ in range(n):
-    x,y = [int(i) for i in input().split()]
-    p = Point(x,y)
-    c  = 0
-    for i in rectangulos:
-        if isInRectangle(p,i):
-            c+=1
-    for i in circulos:
-        if isInCircle(p,i):
-            c+=1
-    print(c)
diff --git "a/Problemas/Geometr\303\255a Computacional/HoneyHeist.java" "b/Problemas/Geometr\303\255a Computacional/HoneyHeist.java"
deleted file mode 100644
index 0e8a8f8..0000000
--- "a/Problemas/Geometr\303\255a Computacional/HoneyHeist.java"	
+++ /dev/null
@@ -1,197 +0,0 @@
-import java.util.*;
-import java.io.*;
-
-public class HoneyHeist {
-	static HashSet<Integer> blocked;
-	static int[][] matrix;
-	static int r;
-	static int n;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st = new StringTokenizer(in.readLine());
-		r = Integer.parseInt(st.nextToken());
-		int N = Integer.parseInt(st.nextToken());
-		int A = Integer.parseInt(st.nextToken());
-		int B = Integer.parseInt(st.nextToken());
-		int X = Integer.parseInt(st.nextToken());
-		blocked = new HashSet<>();
-		st = new StringTokenizer(in.readLine());
-		for (int i = 0; i < X; i++)
-			blocked.add(Integer.parseInt(st.nextToken()));
-		buildMatrix();
-		int ans = bfs(A, B, N);
-		System.out.println(ans > 0 ? ans : "NO");
-
-	}
-
-	static int bfs(int s, int t, int pasos) {
-		boolean[] visited = new boolean[n];
-		int[] d = new int[n];
-		visited[s] = true;
-		d[s] = 0;
-		Queue<Integer> Q = new LinkedList<>();
-		Q.add(s);
-		while (!Q.isEmpty()) {
-			int u = Q.poll();
-			for (int v : getVecinos(u))
-				if (blocked.contains(v))
-					visited[v] = true;
-				else if (!visited[v]) {
-					visited[v] = true;
-					d[v] = d[u] + 1;
-					Q.add(v);
-				}
-
-		}
-		if (d[t] > pasos)
-			return -1;
-		else
-			return d[t];
-
-	}
-
-	static ArrayList<Integer> getVecinos(int u) {
-		ArrayList<Integer> vecinos = new ArrayList<>();
-		int indiceFila = 0;
-		int indiceColumna = 0;
-		for (int i = 0; i < matrix.length; i++) {
-			int val = Arrays.binarySearch(matrix[i], u);
-			if (val >= 0) {
-				indiceFila = i;
-				indiceColumna = val;
-				break;
-			}
-		}
-		if (indiceColumna == 0) {
-			if (indiceFila == 0) {
-				vecinos.add(matrix[0][1]);
-				vecinos.add(matrix[1][0]);
-				vecinos.add(matrix[1][1]);
-				return vecinos;
-			}
-			if (indiceFila == (r - 1)) {
-				vecinos.add(matrix[r - 2][0]);
-				vecinos.add(matrix[r - 1][1]);
-				vecinos.add(matrix[r][0]);
-				return vecinos;
-			}
-			if (indiceFila == matrix.length - 1) {
-				vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-				vecinos.add(matrix[indiceFila - 1][indiceColumna + 1]);
-				vecinos.add(matrix[indiceFila][indiceColumna + 1]);
-				return vecinos;
-			} else {
-				if (indiceFila < (r - 1)) {
-					vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-					vecinos.add(matrix[indiceFila][indiceColumna + 1]);
-					vecinos.add(matrix[indiceFila + 1][indiceColumna]);
-					vecinos.add(matrix[indiceFila + 1][indiceColumna + 1]);
-					return vecinos;
-				} else {
-					vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-					vecinos.add(matrix[indiceFila][indiceColumna + 1]);
-					vecinos.add(matrix[indiceFila + 1][indiceColumna]);
-					vecinos.add(matrix[indiceFila - 1][indiceColumna + 1]);
-					return vecinos;
-				}
-			}
-		}
-		if (indiceColumna == matrix[indiceFila].length - 1) {
-			if (indiceFila == 0) {
-				vecinos.add(matrix[0][matrix[indiceFila].length - 2]);
-				vecinos.add(matrix[1][matrix[indiceFila].length - 1]);
-				vecinos.add(matrix[1][matrix[indiceFila].length]);
-				return vecinos;
-			}
-			if (indiceFila == (r - 1)) {
-				vecinos.add(matrix[r - 2][matrix[indiceFila].length - 2]);
-				vecinos.add(matrix[r - 1][matrix[indiceFila].length - 2]);
-				vecinos.add(matrix[r][matrix[indiceFila].length - 2]);
-				return vecinos;
-			}
-			if (indiceFila == matrix.length - 1) {
-				vecinos.add(matrix[matrix.length - 2][indiceColumna]);
-				vecinos.add(matrix[matrix.length - 2][indiceColumna + 1]);
-				vecinos.add(matrix[matrix.length - 1][indiceColumna - 1]);
-				return vecinos;
-			} else {
-				if (indiceFila < r - 1) {
-					vecinos.add(matrix[indiceFila - 1][indiceColumna - 1]);
-					vecinos.add(matrix[indiceFila][indiceColumna - 1]);
-					vecinos.add(matrix[indiceFila + 1][indiceColumna]);
-					vecinos.add(matrix[indiceFila + 1][indiceColumna + 1]);
-					return vecinos;
-				} else {
-					vecinos.add(matrix[indiceFila - 1][indiceColumna + 1]);
-					vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-					vecinos.add(matrix[indiceFila][indiceColumna - 1]);
-					vecinos.add(matrix[indiceFila + 1][indiceColumna - 1]);
-					return vecinos;
-				}
-			}
-		}
-		if (indiceFila == 0) {
-			vecinos.add(matrix[indiceFila][indiceColumna - 1]);
-			vecinos.add(matrix[indiceFila][indiceColumna + 1]);
-			vecinos.add(matrix[indiceFila + 1][indiceColumna]);
-			vecinos.add(matrix[indiceFila + 1][indiceColumna + 1]);
-			return vecinos;
-		}
-		if (indiceFila == matrix.length - 1) {
-			vecinos.add(matrix[indiceFila][indiceColumna - 1]);
-			vecinos.add(matrix[indiceFila][indiceColumna + 1]);
-			vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-			vecinos.add(matrix[indiceFila - 1][indiceColumna + 1]);
-			return vecinos;
-		} else {
-			vecinos.add(matrix[indiceFila][indiceColumna - 1]);
-			vecinos.add(matrix[indiceFila][indiceColumna + 1]);
-			if (indiceFila < (r - 1)) {
-				vecinos.add(matrix[indiceFila - 1][indiceColumna - 1]);
-				vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-				vecinos.add(matrix[indiceFila + 1][indiceColumna]);
-				vecinos.add(matrix[indiceFila + 1][indiceColumna + 1]);
-			} else if (indiceFila == (r - 1)) {
-				vecinos.add(matrix[indiceFila - 1][indiceColumna - 1]);
-				vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-				vecinos.add(matrix[indiceFila + 1][indiceColumna - 1]);
-				vecinos.add(matrix[indiceFila + 1][indiceColumna]);
-			} else {
-				vecinos.add(matrix[indiceFila - 1][indiceColumna]);
-				vecinos.add(matrix[indiceFila - 1][indiceColumna + 1]);
-				vecinos.add(matrix[indiceFila + 1][indiceColumna - 1]);
-				vecinos.add(matrix[indiceFila + 1][indiceColumna]);
-			}
-			return vecinos;
-		}
-
-	}
-
-	static void buildMatrix() {
-		int nrows = (r * 2) - 1;
-		int ncol = r;
-		int num = 1;
-		boolean cond = true;
-		matrix = new int[nrows][];
-		for (int i = 0; i < nrows; i++) {
-			int[] row = new int[ncol];
-			for (int j = 0; j < ncol; j++) {
-				row[j] = num;
-				num++;
-			}
-			matrix[i] = row;
-			if (cond)
-				ncol++;
-			else
-				ncol--;
-			if (i + 1 == r) {
-				ncol -= 2;
-				cond = false;
-			}
-
-		}
-		n = num;
-	}
-
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/Intersection.java" "b/Problemas/Geometr\303\255a Computacional/Intersection.java"
deleted file mode 100644
index 8019038..0000000
--- "a/Problemas/Geometr\303\255a Computacional/Intersection.java"	
+++ /dev/null
@@ -1,86 +0,0 @@
-import java.awt.geom.Line2D;
-import java.awt.geom.Rectangle2D;
-import java.io.*;
-import java.util.*;
-
-public class Intersection {
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		int n = in.nextInt();
-		for (int i = 0; i < n; i++) {
-			int x1 = in.nextInt();
-			int y1 = in.nextInt();
-			int x2 = in.nextInt();
-			int y2 = in.nextInt();
-			int x3 = in.nextInt();
-			int y3 = in.nextInt();
-			int x4 = in.nextInt();
-			int y4 = in.nextInt();
-			Line2D.Double line = new Line2D.Double(x1, y1, x2, y2);
-			int xmin = Math.min(x3, x4);
-			int ymin = Math.min(y3, y4);
-			Rectangle2D.Double rectangle = new Rectangle2D.Double(xmin, ymin, Math.abs(x3 - x4), Math.abs(y3 - y4));
-			System.out.println(rectangle.intersectsLine(line) ? "T" : "F");
-		}
-
-	}
-
-	static class Input {
-
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/Jabuke.cpp" "b/Problemas/Geometr\303\255a Computacional/Jabuke.cpp"
deleted file mode 100644
index d737063..0000000
--- "a/Problemas/Geometr\303\255a Computacional/Jabuke.cpp"	
+++ /dev/null
@@ -1,43 +0,0 @@
-//https://open.kattis.com/problems/jabuke
-#include <bits/stdc++.h>
-using namespace std;
-#define ll long long
-
-double triangleArea(double x1, double y1, double x2, double y2, double x3, double y3) {
-    return abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0;
-}
-
-bool isPointInTriangle(pair<double, double> A, pair<double, double> B, pair<double, double> C, pair<double, double> P) {
-    double A_area = triangleArea(A.first, A.second, B.first, B.second, C.first, C.second);
-    double A_area1 = triangleArea(P.first, P.second, B.first, B.second, C.first, C.second);
-    double A_area2 = triangleArea(A.first, A.second, P.first, P.second, C.first, C.second);
-    double A_area3 = triangleArea(A.first, A.second, B.first, B.second, P.first, P.second);
-
-    return A_area == (A_area1 + A_area2 + A_area3);
-}
-
-void solve() {
-    pair<double, double> A, B, C, P;
-    cin >> A.first >> A.second;
-    cin >> B.first >> B.second;
-    cin >> C.first >> C.second;
-
-    int n;
-    cin >> n;
-
-    int cnt = 0;
-    while (n--) {
-        cin >> P.first >> P.second;
-        if (isPointInTriangle(A, B, C, P))
-            cnt++;
-    }
-    cout << fixed << setprecision(1) << triangleArea(A.first, A.second, B.first, B.second, C.first, C.second) << endl;
-    cout << cnt << endl;
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/Jigsaw of Shadows.cpp" "b/Problemas/Geometr\303\255a Computacional/Jigsaw of Shadows.cpp"
deleted file mode 100644
index 4f76b45..0000000
--- "a/Problemas/Geometr\303\255a Computacional/Jigsaw of Shadows.cpp"	
+++ /dev/null
@@ -1,50 +0,0 @@
-//https://codeforces.com/gym/105505/problem/J
-#include <bits/stdc++.h>
-#include <iomanip>
-#define pi 3.141592653589793238462643383279502884197
-using namespace std;
-const int nmax=3*1e5+5;
-pair<int,int> nums[nmax];
-double d(int t, int x) {
-    return (double)x/tan(t*pi/180);
-}
-double h(int t, double x) {
-    return (double)x*tan(t*pi/180);
-}
-int main() {
-    ios::sync_with_stdio(false);
-    cin.tie(0);
-    cout<<fixed<<setprecision(10);
-    int t,n;
-    cin>>t>>n;
-    for(int i =0;i<n;i++) {
-        int x,h;
-        cin>>x>>h;
-        nums[i]={x,h};
-    }
-
-    sort(nums,nums+n);
-    long double ans=0;
-    double res=0;
-    for(int i =0;i<n;i++) {
-        double x=nums[i].first+d(t,nums[i].second);
-        res=x;
-        pair <int,int> p={nums[i].first,nums[i].second};
-        while(true) {
-            if(i+1==n||x<=nums[i+1].first) {
-                ans+=res-p.first;
-                break;
-            }
-            if(h(t,x-nums[i+1].first)<=nums[i+1].second) {
-                ans+=nums[i+1].first-nums[i].first;
-                break;
-            }
-            res-=nums[i+1].first-nums[i].first;
-            ans+=nums[i+1].first-nums[i].first;
-            i++;
-
-        }
-    }
-    cout<<ans<<"\n";
-    return 0;
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/KClosestPointToOrigin.java" "b/Problemas/Geometr\303\255a Computacional/KClosestPointToOrigin.java"
deleted file mode 100644
index 36e3be9..0000000
--- "a/Problemas/Geometr\303\255a Computacional/KClosestPointToOrigin.java"	
+++ /dev/null
@@ -1,21 +0,0 @@
-//leetocde 973
-import java.awt.*;
-class Solution {
-    public int[][] kClosest(int[][] points, int k) {
-        int n = points.length;
-        Point[] puntos = new Point[n];
-        for(int i = 0;i<n;i++)
-            puntos[i] = new Point(points[i][0],points[i][1]);
-        Arrays.sort(puntos,(p1,p2)->{
-            if(p1.distance(new Point(0,0))<p2.distance(new Point(0,0)))
-                return -1;
-            return 1;
-        });
-        int[][] res = new int[k][2];
-        for(int i = 0;i<k;i++){
-            res[i][0] = puntos[i].x;
-            res[i][1] = puntos[i].y;
-        }
-        return res;
-    }
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/Largest Triangle Area.py" "b/Problemas/Geometr\303\255a Computacional/Largest Triangle Area.py"
deleted file mode 100644
index 52d716c..0000000
--- "a/Problemas/Geometr\303\255a Computacional/Largest Triangle Area.py"	
+++ /dev/null
@@ -1,67 +0,0 @@
-#https://leetcode.com/problems/largest-triangle-area/?envType=problem-list-v2&envId=geometry
-
-#first solution
-from itertools import combinations
-
-class Solution:
-    def largestTriangleArea(self, points: List[List[int]]) -> float:
-        max_area = 0
-
-        for p1, p2, p3 in combinations(points, 3):
-            x1, y1 = p1
-            x2, y2 = p2
-            x3, y3 = p3
-
-            area = abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2))/2.0
-            max_area = max(max_area, area)
-        
-        return max_area
-
-
-#second solution
-class Solution:
-    def largestTriangleArea(self, points: List[List[int]]) -> float:
-        # max_area = 0
-
-        # for (x1, y1), (x2, y2), (x3, y3) in combinations(points, 3):
-        #     area = abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2
-        #     max_area = max(max_area, area)
-        
-        # return max_area
-
-        def area(x1, y1, x2, y2, x3, y3):
-            return abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2
-
-        # Function to compute the convex hull
-        def convex_hull(points):
-            points = sorted(points)  # Sort the points lexicographically
-            # Build the lower hull
-            lower = []
-            for p in points:
-                while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:
-                    lower.pop()
-                lower.append(p)
-            # Build the upper hull
-            upper = []
-            for p in reversed(points):
-                while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:
-                    upper.pop()
-                upper.append(p)
-            return lower[:-1] + upper[:-1]  # Remove the last point because it's repeated
-
-        # Cross product to determine the turn direction
-        def cross(o, a, b):
-            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])
-
-        hull = convex_hull(points)
-        max_area = 0
-        
-        # Iterate through each combination of points in the convex hull
-        for i in range(len(hull)):
-            for j in range(i + 1, len(hull)):
-                for k in range(j + 1, len(hull)):
-                    max_area = max(max_area, area(hull[i][0], hull[i][1], 
-                                                   hull[j][0], hull[j][1], 
-                                                   hull[k][0], hull[k][1]))
-        
-        return max_area
diff --git "a/Problemas/Geometr\303\255a Computacional/Logo.java" "b/Problemas/Geometr\303\255a Computacional/Logo.java"
deleted file mode 100644
index 4e6c7e8..0000000
--- "a/Problemas/Geometr\303\255a Computacional/Logo.java"	
+++ /dev/null
@@ -1,77 +0,0 @@
-import java.io.*;
-import java.util.*;
-import java.awt.geom.*;
-
-public class Logo {
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		int test = in.nextInt();
-		for (int cases = 0; cases < test; cases++) {
-			int n = in.nextInt();
-			Point2D.Double origen = new Point2D.Double(0, 0);
-			Point2D.Double destino = new Point2D.Double(0, 0);
-			double angle = 0;
-			for (int i = 0; i < n; i++) {
-				String dir = in.next();
-				int unit = in.nextInt();
-				if (dir.equals("fd"))
-					destino.setLocation(destino.x + unit * Math.cos(Math.toRadians(angle)),
-							destino.y + unit * Math.sin(Math.toRadians(angle)));
-				else if (dir.equals("bk"))
-					destino.setLocation(destino.x - unit * Math.cos(Math.toRadians(angle)),
-							destino.y - unit * Math.sin(Math.toRadians(angle)));
-				else if (dir.equals("lt"))
-					angle += unit;
-				else
-					angle -= unit;
-			}
-			System.out.println(Math.round(origen.distance(destino)));
-		}
-
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-	}
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/MinimalCoverage.cpp" "b/Problemas/Geometr\303\255a Computacional/MinimalCoverage.cpp"
deleted file mode 100644
index 77435a0..0000000
--- "a/Problemas/Geometr\303\255a Computacional/MinimalCoverage.cpp"	
+++ /dev/null
@@ -1,58 +0,0 @@
-//https://vjudge.net/problem/UVA-10020
-#include <bits/stdc++.h>
-using namespace std;
-using ll = long long;
-
-void solve() {
-    int t;
-    cin >> t;
-    while (t--) {
-        int m;
-        cin >> m;
-        vector<pair<int, int> > v;
-        while (true) {
-            int x, y;
-            cin >> x >> y;
-            if (x == 0 && y == 0) break;
-            v.emplace_back(x, y);
-        }
-        sort(v.begin(), v.end());
-        vector<pair<int, int> > ans;
-        int cur = 0;
-        int index = -1;
-        bool flag = true;
-        while (cur < m) {
-            pair<int, int> aux = {INT_MIN, INT_MIN};
-            for (int i = index + 1; i < v.size(); i++) {
-                int left = v[i].first;
-                int right = v[i].second;
-                if (left <= cur && right >= cur) {
-                    if (right >= aux.second) {
-                        aux = v[i];
-                        index = i;
-                    }
-                }
-            }
-
-            cur = aux.second;
-            if (cur == INT_MIN) {
-                flag = false;
-                break;
-            }
-            ans.emplace_back(aux);
-        }
-        if (flag) {
-            cout << ans.size() << endl;
-            for (const auto &x: ans) {
-                cout << x.first << ' ' << x.second << endl;
-            }
-        } else cout << 0 << endl;
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/MinimumTimeVisitingAllPoints.py" "b/Problemas/Geometr\303\255a Computacional/MinimumTimeVisitingAllPoints.py"
deleted file mode 100644
index 57043ec..0000000
--- "a/Problemas/Geometr\303\255a Computacional/MinimumTimeVisitingAllPoints.py"	
+++ /dev/null
@@ -1,17 +0,0 @@
-#https://leetcode.com/problems/minimum-time-visiting-all-points/?envType=problem-list-v2&envId=geometry&difficulty=EASY
-class Solution:
-    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:
-        total = 0
-        n = len(points)
-        for i in range(1, n):
-            x1, y1 = points[i - 1]
-            x2, y2 = points[i]         
-
-            dx = abs(x2 - x1)
-            dy = abs(y2 - y1)
-
-            if dx == dy:
-                total += dx
-            else:
-                total += max(dx, dy)
-        return total 
diff --git "a/Problemas/Geometr\303\255a Computacional/MirrorReflection.cpp" "b/Problemas/Geometr\303\255a Computacional/MirrorReflection.cpp"
deleted file mode 100644
index 4ea3e2a..0000000
--- "a/Problemas/Geometr\303\255a Computacional/MirrorReflection.cpp"	
+++ /dev/null
@@ -1,23 +0,0 @@
-// https://leetcode.com/problems/mirror-reflection/?envType=problem-list-v2&envId=geometry&difficulty=MEDIUM
-
-#include <iostream>
-#include <algorithm>
-using namespace std;
-class Solution {
-public:
-    int mirrorReflection(int p, int q) {
-        // Calcular el Mnimo Comn Mltiplo (MCM) 
-        int l = lcm(p, q); 
-
-        // Calcular el nmero de reflexiones
-        int x = l / p; // Reflexiones verticales
-        int y = l / q; // Reflexiones horizontales
-
-        // Determinar el receptor
-        if (x % 2 == 0 && y % 2 == 1) return 0; 
-        if (x % 2 == 1 && y % 2 == 1) return 1; 
-        if (x % 2 == 1 && y % 2 == 0) return 2; 
-
-        return -1;
-    }
-};
diff --git "a/Problemas/Geometr\303\255a Computacional/Operaciones basicas vectores y matrices.ipynb" "b/Problemas/Geometr\303\255a Computacional/Operaciones basicas vectores y matrices.ipynb"
deleted file mode 100644
index 7272a40..0000000
--- "a/Problemas/Geometr\303\255a Computacional/Operaciones basicas vectores y matrices.ipynb"	
+++ /dev/null
@@ -1,140 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "markdown",
-   "id": "72b8cb9b",
-   "metadata": {},
-   "source": [
-    "# Operaciones con vectores y matrices"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "69427880",
-   "metadata": {},
-   "source": [
-    "# Vectores\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 15,
-   "id": "bca27a92",
-   "metadata": {
-    "scrolled": true
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "1 2 3\n",
-      "4 5 6\n",
-      "[5, 7, 9]\n",
-      "[-3, -3, -3]\n",
-      "[2, 4, 6]\n",
-      "32\n"
-     ]
-    }
-   ],
-   "source": [
-    "import math\n",
-    "\n",
-    "u = list(map(int, input().split()))\n",
-    "v = list(map(int, input().split()))\n",
-    "esc = 2\n",
-    "\n",
-    "suma = [a + b for a, b in zip(u, v)]\n",
-    "resta = [a - b for a, b in zip(u, v)]\n",
-    "vector_por_escalar = [esc * x for x in vector1]\n",
-    "producto_punto = sum(map(mul, u, v))\n",
-    "\n",
-    "\n",
-    "print(suma)  \n",
-    "print(resta) \n",
-    "print(vector_por_escalar)\n",
-    "print(producto_punto)  "
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "6ad8f270",
-   "metadata": {},
-   "source": [
-    "# Matrices"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 10,
-   "id": "446d934b",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "[[6, 8], [10, 12]]\n",
-      "[[-4, -4], [-4, -4]]\n",
-      "[[19, 22], [43, 50]]\n"
-     ]
-    }
-   ],
-   "source": [
-    "matriz = [[1, 2], [3, 4]]\n",
-    "matriz2 = [[5, 6], [7, 8]]\n",
-    "escalar = 3\n",
-    "\n",
-    "suma = [[a + b for a, b in zip(fila1, fila2)] for fila1, fila2 in zip(matriz, matriz2)]\n",
-    "resta = [[a - b for a, b in zip(fila1, fila2)] for fila1, fila2 in zip(matriz, matriz2)]\n",
-    "producto_escalar_matriz = [[escalar * x for x in fila] for fila in matriz]\n",
-    "\n",
-    "\n",
-    "def multiplicar_matrices(matriz1, matriz2):\n",
-    "    filas_matriz1 = len(matriz1)\n",
-    "    columnas_matriz1 = len(matriz1[0])\n",
-    "    filas_matriz2 = len(matriz2)\n",
-    "    columnas_matriz2 = len(matriz2[0])\n",
-    "\n",
-    "    if columnas_matriz1 != filas_matriz2:\n",
-    "        return None  # Las matrices no son compatibles para la multiplicacin\n",
-    "\n",
-    "    matriz_resultado = [[0 for j in range(columnas_matriz2)] for i in range(filas_matriz1)]\n",
-    "\n",
-    "    # Multiplicar las matrices\n",
-    "    for i in range(filas_matriz1):\n",
-    "        for j in range(columnas_matriz2):\n",
-    "            for k in range(columnas_matriz1):\n",
-    "                matriz_resultado[i][j] += matriz1[i][k] * matriz2[k][j]\n",
-    "\n",
-    "    return matriz_resultado\n",
-    "\n",
-    "print(suma)\n",
-    "print(resta)\n",
-    "print(producto_escalar_matriz)\n",
-    "print(multiplicar_matrices(matriz, matriz2))"
-   ]
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python 3 (ipykernel)",
-   "language": "python",
-   "name": "python3"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.9.13"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/PolygonArea.cpp" "b/Problemas/Geometr\303\255a Computacional/PolygonArea.cpp"
deleted file mode 100644
index 0a1b898..0000000
--- "a/Problemas/Geometr\303\255a Computacional/PolygonArea.cpp"	
+++ /dev/null
@@ -1,59 +0,0 @@
-//https://cses.fi/problemset/task/2191
-using namespace std;
-#include <bits/stdc++.h>
-#include <iostream>
-#include <vector>
-#include <unordered_map>
-#include <unordered_set>
-#include <algorithm>
-#include <climits>
-#include <cmath>
-#include <math.h>
-#include <iomanip>
-#include <set>
-#include <deque>
-#include <queue>
-#include <stack>
-#include <string>
-#include <utility>
-#include <numeric>
-#define PI acos(-1)
-#define toRadians(angle) PI *angle / 180
-#define toDegree(angle) (180 * angle) / PI
-#define fori(i, k, n) for (int i = k; i < (n); i++)
-#define MAXN 200000
-#define ln "\n"
-
-struct point
-{
-    long long x, y;
-    point() {}
-    point(long long x, long long y) : x(x), y(y) {}
-};
-
-long long area(const vector<point> &p, int n)
-{
-    long long area = 0;
-    for (long long i = 0; i < n; i++)
-        area += (p[i].x * p[(i + 1) % n].y - p[(i + 1) % n].x * p[i].y);
-    return abs(area);
-}
-
-void solve()
-{
-    int n;
-    cin >> n;
-    vector<point> p(n);
-    fori(i, 0, n)
-            cin >>
-        p[i].x >> p[i].y;
-    cout << area(p, n) << ln;
-}
-
-int main()
-{
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    solve();
-    return 0;
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/ProjectionAreaOf3DShapes.py" "b/Problemas/Geometr\303\255a Computacional/ProjectionAreaOf3DShapes.py"
deleted file mode 100644
index f92e5e1..0000000
--- "a/Problemas/Geometr\303\255a Computacional/ProjectionAreaOf3DShapes.py"	
+++ /dev/null
@@ -1,16 +0,0 @@
-#https://leetcode.com/problems/projection-area-of-3d-shapes/description/?envType=problem-list-v2&envId=geometry&difficulty=EASY
-class Solution:
-    def projectionArea(self, grid: List[List[int]]) -> int:
-        n = len(grid)
-        
-        # Area of the xy-projection
-        xy_area = sum(1 for i in range(n) for j in range(n) if grid[i][j] > 0)
-        
-        # Area of the yz-projection
-        yz_area = sum(max(row) for row in grid)
-        
-        # Area of the zx-projection
-        zx_area = sum(max(grid[i][j] for i in range(n)) for j in range(n))
-        
-        total_area = xy_area + yz_area + zx_area
-        return total_area
diff --git "a/Problemas/Geometr\303\255a Computacional/Robot Protection.py" "b/Problemas/Geometr\303\255a Computacional/Robot Protection.py"
deleted file mode 100644
index fdb0f69..0000000
--- "a/Problemas/Geometr\303\255a Computacional/Robot Protection.py"	
+++ /dev/null
@@ -1,55 +0,0 @@
-class Point:
-    def __init__(self, x, y):
-        self.x = x
-        self.y = y
-
-    def __getitem__(self, index):
-        return [self.x, self.y][index]
-
-def cross_product(p1, p2, p3):
-    x1, y1 = p1
-    x2, y2 = p2
-    x3, y3 = p3
-    return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)
-
-def convex_hull(points):
-    n = len(points)
-    if n <= 2:
-        return points
-
-    points.sort(key=lambda p: (p.x, p.y))
-    lower_hull = []
-    upper_hull = []
-
-    for p in points:
-        while len(lower_hull) >= 2 and cross_product(lower_hull[-2], lower_hull[-1], p) <= 0:
-            lower_hull.pop()
-        lower_hull.append(p)
-
-    for p in reversed(points):
-        while len(upper_hull) >= 2 and cross_product(upper_hull[-2], upper_hull[-1], p) <= 0:
-            upper_hull.pop()
-        upper_hull.append(p)
-
-    lower_hull.pop()
-    upper_hull.pop()
-    return lower_hull + upper_hull
-
-def polygon_area(points):
-    area = 0
-    for i in range(len(points)):
-        j = (i + 1) % len(points)
-        area += points[i][0] * points[j][1] - points[j][0] * points[i][1]
-    return abs(area) // 2
-
-while True:
-    n = int(input())
-    if n == 0:
-        break
-    points = []
-    for _ in range(n):
-        x, y = map(int, input().split())
-        points.append(Point(x, y))
-    hull = convex_hull(points)
-    area = polygon_area(hull)
-    print(float(area))
diff --git "a/Problemas/Geometr\303\255a Computacional/Sunny Mountains(java).java" "b/Problemas/Geometr\303\255a Computacional/Sunny Mountains(java).java"
deleted file mode 100644
index 2ca4a5e..0000000
--- "a/Problemas/Geometr\303\255a Computacional/Sunny Mountains(java).java"	
+++ /dev/null
@@ -1,91 +0,0 @@
-//https://vjudge.net/problem/UVA-920
-import java.io.*;
-import java.text.DecimalFormat;
-import java.util.*;
-
-public class Main {
-
-    public static void main(String[] args) throws Exception{
-        Scanner sc=new Scanner();
-        DecimalFormat f=new DecimalFormat("#0.00");
-        PrintWriter out=new PrintWriter(System.out);
-        int t=sc.nextInt();
-        for (int times = 0; times < t; times++) {
-            int n=sc.nextInt();
-            Point[] a=new Point[n];
-            for (int i = 0; i < n; i++)
-                a[i]=new Point(sc.nextInt(),sc.nextInt());
-            Arrays.sort(a);
-            double c=d(a[n-1],a[n-2]);
-            Point s=a[n-2];
-
-            for (int i = n-3; i >=0 ; i--) {
-                if(a[i].y>s.y){
-                    double m= (a[i+1].y - a[i].y) /(a[i+1].x-a[i].x);
-                    double x= (s.y-a[i].y+a[i].x*m)/m;
-                    c+=d(a[i],new Point(x,s.y));
-                    s=a[i];
-                }
-            }
-            out.println(f.format(c));
-        }
-        out.close();
-    }
-    static double d(Point a,Point b){
-        return Math.hypot(a.x-b.x,a.y-b.y);
-    }
-    static class Point implements Comparable<Point>{
-        double x,y;
-        public Point(double a, double b){
-            x=a;
-            y=b;
-        }
-
-        public int compareTo(Point o) {
-            if(x<o.x)return -1;
-            return 1;
-        }
-        public String toString(){
-            return "("+x+", "+y+")";
-        }
-    }
-
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/SunnyMountains.py" "b/Problemas/Geometr\303\255a Computacional/SunnyMountains.py"
deleted file mode 100644
index 51da9b6..0000000
--- "a/Problemas/Geometr\303\255a Computacional/SunnyMountains.py"	
+++ /dev/null
@@ -1,52 +0,0 @@
-#https://vjudge.net/problem/UVA-920
-class Point:
-    def __init__(self,x,y):
-        self.x = x
-        self.y = y
-    
-    def __str__(self):
-        return f"({self.x},{self.y}) "
-
-def pendiente(p1:Point,p2:Point):
-    return (p1.y - p2.y)/(p1.x-p2.x)
-
-
-def eqLine(y, p1,p2):
-    m = pendiente(p1,p2)
-    return (y-p1.y+m*p1.x)/m
-    
-dist = lambda p1,p2 : ((p1.x-p2.x)**2 + (p1.y-p2.y)**2)**0.5
-
-t = int(input())
-for _ in range(t):
-    n = int(input())
-    arr = []
-    for i in range(n):
-        x,y = [int(j) for j in input().split()]
-        arr.append(Point(x,y))
-    arr.sort(key=lambda p: p.x)
-    ans = dist(arr[-1],arr[-2])
-    maxi = arr[-2]
-    for i in reversed(range(0,n-2)):
-        p1 = arr[i]
-        if p1.y<=maxi.y:
-            continue
-        p2 = arr[i+1]
-        p3 = Point(eqLine(maxi.y, p1, p2),maxi.y)
-        ans+=dist(p1,p3)
-        maxi = p1
-    print(f"{ans:.2f}")
-
-
-
-
-
-
-
-
-
-
-
-
-
-
diff --git "a/Problemas/Geometr\303\255a Computacional/SurfaceAreaof3DShapes.py" "b/Problemas/Geometr\303\255a Computacional/SurfaceAreaof3DShapes.py"
deleted file mode 100644
index 484f619..0000000
--- "a/Problemas/Geometr\303\255a Computacional/SurfaceAreaof3DShapes.py"	
+++ /dev/null
@@ -1,26 +0,0 @@
-#https://leetcode.com/problems/surface-area-of-3d-shapes/?envType=problem-list-v2&envId=geometry&difficulty=EASY
-class Solution:
-    def surfaceArea(self, grid: List[List[int]]) -> int:
-        n = len(grid)
-        m = len(grid[0])
-        res = 0
-
-        for r in range(n):
-            for c in range(m):
-                if grid[r][c] != 0:
-                    #formula:
-                    # A = 2*(bl + lh + hb)
-                    res += 2*(grid[r][c] + grid[r][c] + 1)
-                # Arriba
-                if r > 0:
-                    res -= min(grid[r][c], grid[r - 1][c])
-                # Abajo
-                if r < n - 1:
-                    res -= min(grid[r][c], grid[r + 1][c])
-                # Izquierda
-                if c > 0:
-                    res -= min(grid[r][c], grid[r][c - 1])
-                # Derecha
-                if c < m - 1:
-                    res -= min(grid[r][c], grid[r][c + 1])
-        return res
diff --git "a/Problemas/Geometr\303\255a Computacional/TheGreatDivide.cpp" "b/Problemas/Geometr\303\255a Computacional/TheGreatDivide.cpp"
deleted file mode 100644
index f44304b..0000000
--- "a/Problemas/Geometr\303\255a Computacional/TheGreatDivide.cpp"	
+++ /dev/null
@@ -1,214 +0,0 @@
-//https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=73&page=show_problem&problem=1197
-#include <bits/stdc++.h>
-using namespace std;
-
-struct Point {
-    double x, y;
-    
-    bool operator==(const Point& other) const {
-        return x == other.x && y == other.y;
-    }
-    
-    Point operator-(const Point& other) const {
-        return {x - other.x, y - other.y};
-    }
-};
-
-int orientation(const Point& a, const Point& b, const Point& c) {
-    double cross = (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);
-    return (cross < 0) ? -1 : (cross > 0) ? 1 : 0;
-}
-
-
-vector<Point> convexHull(vector<Point> points, bool includeCollinear = false) {
-    if (points.size() <= 1) return points;
-    
-    sort(points.begin(), points.end(), [](const Point& a, const Point& b) {
-        return make_pair(a.x, a.y) < make_pair(b.x, b.y);
-    });
-    
-    vector<Point> hull;
-    for (int phase = 0; phase < 2; ++phase) {
-        auto start = hull.size();
-        for (const auto& p : points) {
-            while (hull.size() >= start + 2) {
-                auto a = hull[hull.size()-2];
-                auto b = hull.back();
-                int o = orientation(a, b, p);
-                if (o < 0 || (!includeCollinear && o == 0)) break;
-                hull.pop_back();
-            }
-            hull.push_back(p);
-        }
-        hull.pop_back();
-        reverse(points.begin(), points.end());
-    }
-    
-    if (hull.size() == 2 && hull[0] == hull[1]) hull.pop_back();
-    return hull;
-}
-
-class PolygonIntersectionChecker {
-public:
-    static bool check(const vector<Point>& poly1, const vector<Point>& poly2) {
-        return checkSeparatingAxis(poly1, poly2) && checkSeparatingAxis(poly2, poly1);
-    }
-
-private:
-    static bool checkSeparatingAxis(const vector<Point>& poly1, const vector<Point>& poly2) {
-        for (size_t i = 0; i < poly1.size(); ++i) {
-            Point edge = poly1[(i+1)%poly1.size()] - poly1[i];
-            Point normal = {-edge.y, edge.x};
-            
-            // Normalizar el vector normal
-            double len = sqrt(normal.x*normal.x + normal.y*normal.y);
-            normal.x /= len;
-            normal.y /= len;
-            
-            auto [min1, max1] = projectPolygon(poly1, normal);
-            auto [min2, max2] = projectPolygon(poly2, normal);
-            
-            if (max1 < min2 || max2 < min1) return false;
-        }
-        return true;
-    }
-    
-    static pair<double, double> projectPolygon(const vector<Point>& poly, const Point& axis) {
-        double min_proj = axis.x*poly[0].x + axis.y*poly[0].y;
-        double max_proj = min_proj;
-        
-        for (const auto& p : poly) {
-            double proj = axis.x*p.x + axis.y*p.y;
-            min_proj = min(min_proj, proj);
-            max_proj = max(max_proj, proj);
-        }
-        return {min_proj, max_proj};
-    }
-};
-
-int main() {
-    ios::sync_with_stdio(false);
-    cin.tie(nullptr);
-    
-    while (true) {
-        int M, C;
-        cin >> M >> C;
-        if (M == 0 && C == 0) break;
-
-        vector<Point> pointsM(M), pointsC(C);
-        for (auto& p : pointsM) cin >> p.x >> p.y;
-        for (auto& p : pointsC) cin >> p.x >> p.y;
-        
-        auto hullM = convexHull(pointsM);
-        auto hullC = convexHull(pointsC);
-        
-        cout << (PolygonIntersectionChecker::check(hullM, hullC) ? "No" : "Yes") << endl;
-    }
-    
-    return 0;
-}
-    vector<pt> st;
-    for (int i = 0; i < (int)a.size(); i++) {
-        while (st.size() > 1 && !cw(st[st.size()-2], st.back(), a[i], include_collinear))
-            st.pop_back();
-        st.push_back(a[i]);
-    }
-
-    if (include_collinear == false && st.size() == 2 && st[0] == st[1])
-        st.pop_back();
-
-    a = st;
-}
-
-class PolygonIntersection {
-private:
-    static double dotProduct(const pt& a, const pt& b) {
-        return a.x * b.x + a.y * b.y;
-    }
-    
-    static pt getNormal(const pt& edge) {
-        return pt{-edge.y, edge.x};
-    }
-    
-    static void projectPolygon(const std::vector<pt>& vertices, const pt& axis, double& min, double& max) {
-        min = dotProduct(vertices[0], axis);
-        max = min;
-        
-        for (size_t i = 1; i < vertices.size(); i++) {
-            double projection = dotProduct(vertices[i], axis);
-            if (projection < min) min = projection;
-            if (projection > max) max = projection;
-        }
-    }
-
-public:
-    static bool doPolygonsIntersect(const std::vector<pt>& poly1, const std::vector<pt>& poly2) {
-        for (size_t i = 0; i < poly1.size(); i++) {
-            size_t next = (i + 1) % poly1.size();
-            pt edge = {
-                poly1[next].x - poly1[i].x,
-                poly1[next].y - poly1[i].y
-            };
-            pt normal = getNormal(edge);
-            
-            double length = sqrt(normal.x * normal.x + normal.y * normal.y);
-            normal.x /= length;
-            normal.y /= length;
-            
-            double min1, max1, min2, max2;
-            projectPolygon(poly1, normal, min1, max1);
-            projectPolygon(poly2, normal, min2, max2);
-            
-            if (max1 < min2 || max2 < min1) {
-                return false;
-            }
-        }
-        
-        for (size_t i = 0; i < poly2.size(); i++) {
-            size_t next = (i + 1) % poly2.size();
-            pt edge = {
-                poly2[next].x - poly2[i].x,
-                poly2[next].y - poly2[i].y
-            };
-            pt normal = getNormal(edge);
-            
-            double length = sqrt(normal.x * normal.x + normal.y * normal.y);
-            normal.x /= length;
-            normal.y /= length;
-            
-            double min1, max1, min2, max2;
-            projectPolygon(poly1, normal, min1, max1);
-            projectPolygon(poly2, normal, min2, max2);
-            
-            if (max1 < min2 || max2 < min1) {
-                return false;
-            }
-        }
-        
-        return true; 
-    }
-};
-
-
-int main() {
-    while (true) {
-        int M, C;
-        cin >> M >> C;
-        if (M == 0 && C == 0) break;
-
-        vector<pt> pointsMaj(M), pointsClev(C);
-        for (int i = 0; i < M; i++) {
-            cin >> pointsMaj[i].x >> pointsMaj[i].y;
-        }
-        for (int i = 0; i < C; i++) {
-            cin >> pointsClev[i].x >> pointsClev[i].y;
-        }
-
-        convex_hull(pointsMaj);
-        convex_hull(pointsClev);
-
-        cout << (PolygonIntersection::doPolygonsIntersect(pointsMaj, pointsClev) ? "No" : "Yes") << endl;
-        
-    }
-    return 0;
-}
diff --git "a/Problemas/Geometr\303\255a Computacional/TouringRobot.py" "b/Problemas/Geometr\303\255a Computacional/TouringRobot.py"
deleted file mode 100644
index faf44b2..0000000
--- "a/Problemas/Geometr\303\255a Computacional/TouringRobot.py"	
+++ /dev/null
@@ -1,44 +0,0 @@
-#https://onlinejudge.org/contests/211-7b52419c/11509.html
-import math
-
-def calcular_angulo(x1, y1, x2, y2):
-    return math.atan2(y2 - y1, x2 - x1)
-
-def angulo_rotacion(angulo1, angulo2):
-    rotacion = angulo2 - angulo1
-    if rotacion < 0: #angulo antihorario
-        rotacion += 2 * math.pi
-    #if rotacion > 0: #angulo horario
-        #rotacion -= 2 * math.pi
-    return rotacion
-
-def calcular_giro(puntos): 
-    n = len(puntos)
-    if n < 2:
-        return 0
-    angulo_total = 0.0
-    for i in range(n):
-        x1, y1 = puntos[i]
-        x2, y2 = puntos[(i + 1) % n]
-        x3, y3 = puntos[(i + 2) % n]
-
-        angulo1 = calcular_angulo(x1, y1, x2, y2)
-        angulo2 = calcular_angulo(x2, y2, x3, y3)
-
-        rotacion = angulo_rotacion(angulo1, angulo2)
-        rotacion_grados = math.degrees(rotacion)
-        if rotacion_grados > 0:  # solo contar giros positivos para sentido antihorario
-            angulo_total += rotacion_grados
-        #if rotacion_grados < 0: # solo contar giros positivos para  sentido horario
-            #angulo_total += -rotacion_grados 
-    return round(angulo_total / 360)  # nmero de giros completos
-
-while True:
-    n = int(input())
-    if n == 0:
-        break
-    puntos = []
-    for i in range(n):
-        x, y = map(int, input().split())
-        puntos.append((x, y))
-    print(calcular_giro(puntos))
diff --git "a/Problemas/Geometr\303\255a Computacional/Wheels.java" "b/Problemas/Geometr\303\255a Computacional/Wheels.java"
deleted file mode 100644
index 422cb21..0000000
--- "a/Problemas/Geometr\303\255a Computacional/Wheels.java"	
+++ /dev/null
@@ -1,154 +0,0 @@
-import java.util.*;
-import java.io.*;
-
-public class Wheels {
-	static int n;
-	static HashMap<Point, ArrayList<Point>> adj;
-	static HashMap<Point, Racional> fracciones;
-	static HashMap<Point, Boolean> colores;
-	static HashMap<Point, Boolean> visited;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st;
-		int t = Integer.parseInt(in.readLine());
-		for (int cases = 0; cases < t; cases++) {
-			n = Integer.parseInt(in.readLine());
-			adj = new HashMap<>();
-			Point[] circulos = new Point[n];
-			Point s = null;
-			for (int i = 0; i < n; i++) {
-				st = new StringTokenizer(in.readLine());
-				int x = Integer.parseInt(st.nextToken());
-				int y = Integer.parseInt(st.nextToken());
-				int r = Integer.parseInt(st.nextToken());
-				if (i == 0)
-					s = new Point(i, x, y, r);
-				circulos[i] = new Point(i, x, y, r);
-			}
-			buildGraph(s, circulos);
-			bfs(s);
-			for (Point p : new TreeSet<>(List.of(circulos)))
-				if (fracciones.containsKey(p)) {
-					Racional frac = fracciones.get(p);
-					frac.simplificar();
-					System.out.println(
-							frac + " " + Map.of(true, "clockwise", false, "counterclockwise").get(colores.get(p)));
-				} else
-					System.out.println("not moving");
-
-		}
-
-	}
-
-	static void buildGraph(Point s, Point[] circulos) {
-		visited = new HashMap<>();
-		Stack<Point> pila = new Stack<>();
-		pila.push(s);
-		visited.put(s, true);
-		while (!pila.isEmpty()) {
-			Point u = pila.pop();
-			for (Point v : circulos)
-				if (visited.get(v) == null)
-					if (seTocan(u, v)) {
-						visited.put(v, true);
-						addEdge(u, v);
-						pila.push(v);
-					}
-
-		}
-	}
-
-	static void bfs(Point s) {
-		visited = new HashMap<>();
-		colores = new HashMap<>();
-		fracciones = new HashMap<>();
-		Queue<Point> Q = new LinkedList<>();
-		Q.add(s);
-		fracciones.put(s, new Racional(1, 1));
-		visited.put(s, true);
-		colores.put(s, true);
-		while (!Q.isEmpty()) {
-			Point u = Q.poll();
-			if (adj.get(u) == null)
-				continue;
-			for (Point v : adj.get(u)) {
-				if (visited.get(v) == null) {
-					colores.put(v, !colores.get(u));
-					fracciones.put(v, new Racional(s.r, v.r));
-					visited.put(v, true);
-					Q.add(v);
-				}
-			}
-		}
-
-	}
-
-	static void addEdge(Point c1, Point c2) {
-		if (adj.get(c1) == null)
-			adj.put(c1, new ArrayList<>());
-		adj.get(c1).add(c2);
-
-	}
-
-	static boolean seTocan(Point c1, Point c2) {
-		return Math.sqrt(Math.pow(c2.x - c1.x, 2) + Math.pow(c2.y - c1.y, 2)) == c2.r + c1.r;
-	}
-
-	static class Point implements Comparable<Point> {
-		int prioridad;
-		int x;
-		int y;
-		int r;
-
-		Point(int prioridad, int x, int y, int r) {
-			this.prioridad = prioridad;
-			this.x = x;
-			this.y = y;
-			this.r = r;
-		}
-
-		public int compareTo(Point c) {
-			return Integer.compare(prioridad, c.prioridad);
-		}
-
-		public boolean equals(Object o) {
-			Point op = (Point) o;
-			return x == op.x && y == op.y && r == op.r;
-		}
-	}
-
-	static class Racional {
-		long numerador;
-		long denominador;
-
-		Racional(long numerador, long denominador) {
-			this.numerador = numerador;
-			this.denominador = denominador;
-
-		}
-
-		public void simplificar() {
-			if (mcd(numerador, denominador) != 1) {
-				long div = mcd(numerador, denominador);
-				numerador /= div;
-				denominador /= div;
-			}
-		}
-
-		public String toString() {
-			if (denominador == 1)
-				return String.valueOf(numerador);
-			else
-				return numerador + "/" + denominador;
-		}
-
-		long mcd(long a, long b) {
-			if (a % b == 0)
-				return b;
-			else
-				return mcd(b, a % b);
-		}
-	}
-
-}
diff --git a/Problemas/Grafos/2-SAT/GiantPizza.cpp b/Problemas/Grafos/2-SAT/GiantPizza.cpp
deleted file mode 100644
index 4398575..0000000
--- a/Problemas/Grafos/2-SAT/GiantPizza.cpp
+++ /dev/null
@@ -1,105 +0,0 @@
-#include <iostream>
-using namespace std;
-#include <vector>
-#include <stack>
-int m;
-vector<vector<int>> adj;
-vector<vector<int>> adjT;
-stack<int> top_sort;
-vector<int> scc;
-vector<bool> state;
-int nscc;
-vector<bool> variables;
-
-void TWOSAT() {
-	adj.resize(m);
-	adjT.resize(m);
-}
-
-void addEdge(int a, int b) {
-	adj[a].push_back(b);
-	adjT[b].push_back(a);
-}
-
-void dfs(int u) {
-	state[u] = true;
-	for (int v : adj[u])
-		if (!state[v])
-			dfs(v);
-	top_sort.push(u);
-}
-
-void dfs_kos(int u) {
-	scc[u] = nscc;
-	state[u] = true;
-	for (int v : adjT[u])
-		if (!state[v])
-			dfs_kos(v);
-}
-
-void strongly_cc() {
-	state.resize(m,false);
-	for (int i = 0; i < m; i++)
-		if (!state[i])
-			dfs(i);
-	scc.resize(m);
-	nscc = 1;
-	fill(state.begin(), state.end(), false);
-	while (!top_sort.empty()) {
-		int u = top_sort.top();
-		top_sort.pop();
-		if (!state[u]) {
-			dfs_kos(u);
-			nscc++;
-		}
-	}
-}
-
-void asignarVariables() {
-	variables.resize(m, false);
-	for (int i = 0; i < m/2; i++)
-		variables[i] = scc[i] > scc[i + (m / 2)];
-}
-
-
-int main() {
-	int n,o;
-	cin >> n >>o;
-	m = 2 * o;
-	TWOSAT();
-	for (int i = 0; i < n; i++){
-		char signo1,signo2;
-		int num1, num2;
-		cin >> signo1 >>num1>>signo2>>num2;
-		num1--;
-		num2--;
-		if (signo1=='+' && signo2=='+') {
-			addEdge(num1 + o, num2);
-			addEdge(num2 + o, num1);
-		}
-		else if (signo1=='+' && signo2=='-') {
-			addEdge(num1 + o, num2 + o);
-			addEdge(num2, num1);
-		}
-		else if (signo1=='-' && signo2=='+') {
-			addEdge(num1, num2);
-			addEdge(num2 + o, num1 + o);
-		}
-		else {
-			addEdge(num1, num2 + o);
-			addEdge(num2, num1 + o);
-		}
-	}
-	strongly_cc();
-	for (int i = 0; i < o; i++)
-		if (scc[i] == scc[i + o]) {
-			cout<<"IMPOSSIBLE";
-			return 0;
-		}
-	asignarVariables();
-	for (int i = 0; i < o; i++)
-		cout<< (variables[i] ? "+ " : "- ");
-
-	
-	return 0;
-}
diff --git a/Problemas/Grafos/2-SAT/Illumination.java b/Problemas/Grafos/2-SAT/Illumination.java
deleted file mode 100644
index 25b0a07..0000000
--- a/Problemas/Grafos/2-SAT/Illumination.java
+++ /dev/null
@@ -1,157 +0,0 @@
-//https://open.kattis.com/problems/illumination
-import java.io.*;
-import java.util.*;
-
-public class Illumination2SAT {
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		int n = in.nextInt();
-		int r = in.nextInt();
-		int k = in.nextInt();
-		Lampara[] lamparas = new Lampara[k];
-		TWOSAT solver = new TWOSAT(2 * k);
-		for (int i = 0; i < k; i++) {
-			int row = in.nextInt();
-			int col = in.nextInt();
-			lamparas[i] = new Lampara(row - 1, col - 1);
-		}
-
-		for (int i = 0; i < k; i++)
-			for (int j = i + 1; j < k; j++) {
-				if (lamparas[i].fila == lamparas[j].fila
-						&& Math.abs(lamparas[i].columna - lamparas[j].columna) <= 2 * r) {
-					solver.addEdge(i, j + k);
-					solver.addEdge(j, i + k);
-
-				}
-				if (lamparas[i].columna == lamparas[j].columna
-						&& Math.abs(lamparas[i].fila - lamparas[j].fila) <= 2 * r) {
-					solver.addEdge(i + k, j);
-					solver.addEdge(j + k, i);
-				}
-
-			}
-		solver.strongly_cc();
-		for (int i = 0; i < k; i++)
-			if (solver.scc[i] == solver.scc[i + k]) {
-				System.out.println(0);
-				return;
-			}
-		System.out.println(1);
-	}
-
-	static class Lampara {
-		int fila;
-		int columna;
-
-		Lampara(int f, int c) {
-			this.fila = f;
-			this.columna = c;
-		}
-	}
-
-	static class TWOSAT {
-		int n;
-		ArrayList<Integer>[] adj;
-		ArrayList<Integer>[] adjT;
-		Stack<Integer> top_sort;
-		int[] d, scc;
-		int time;
-		int nscc;
-
-		TWOSAT(int n) {
-			this.n = n;
-			adj = new ArrayList[n];
-			adjT = new ArrayList[n];
-			for (int i = 0; i < n; i++) {
-				adj[i] = new ArrayList<>();
-				adjT[i] = new ArrayList<>();
-			}
-		}
-
-		void addEdge(int a, int b) {
-			adj[a].add(b);
-			adjT[b].add(a);
-		}
-
-		void strongly_cc() {
-			d = new int[n];
-			top_sort = new Stack<>();
-			time = 1;
-			for (int i = 0; i < n; i++)
-				if (d[i] == 0)
-					dfs(i);
-			scc = new int[n];
-			nscc = 0;
-			Arrays.fill(d, 0);
-			Arrays.fill(scc, -1);
-			while (!top_sort.isEmpty()) {
-				int u = top_sort.pop();
-				if (d[u] == 0) {
-					dfs_kos(u);
-					nscc++;
-				}
-			}
-		}
-
-		void dfs(int u) {
-			d[u] = time++;
-			for (int v : adj[u])
-				if (d[v] == 0)
-					dfs(v);
-			top_sort.push(u);
-
-		}
-
-		void dfs_kos(int u) {
-			scc[u] = nscc;
-			d[u] = time++;
-			for (int v : adjT[u])
-				if (d[v] == 0)
-					dfs_kos(v);
-		}
-
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-	}
-
-}
diff --git a/Problemas/Grafos/AP & Bridges/BertownRoads.cpp b/Problemas/Grafos/AP & Bridges/BertownRoads.cpp
deleted file mode 100644
index 7256acd..0000000
--- a/Problemas/Grafos/AP & Bridges/BertownRoads.cpp	
+++ /dev/null
@@ -1,72 +0,0 @@
-//https://codeforces.com/problemset/problem/118/E
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(), A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define ll long long
-#define ull unsigned long long
-
-vector<vector<pair<int, int> > > adj;
-vector<pair<int, int> > edges;
-vector<int> d, low;
-int TIME;
-bool cond;
-
-
-void tarjan(int u, int par) {
-    d[u] = low[u] = TIME++;
-    for (const auto &ee: adj[u]) {
-        int v = ee.first;
-        int edge = ee.second;
-        if (v == par)
-            continue;
-        if (d[v] == 0) {
-            edges[edge] = {u + 1, v + 1};
-            tarjan(v, u);
-            low[u] = min(low[u], low[v]);
-            if (d[u] < low[v]) {
-                cond = false;
-                return;
-            }
-        } else {
-            edges[edge] = {v + 1, u + 1};
-            low[u] = min(low[u], d[v]);
-        }
-    }
-}
-
-void solve() {
-    int n, m;
-    cin >> n >> m;
-    adj.assign(n, vector<pair<int, int> >());
-    fori(i, 0, m) {
-        int a, b;
-        cin >> a >> b;
-        a--;
-        b--;
-        adj[a].emplace_back(b, i);
-        adj[b].emplace_back(a, i);
-    }
-    edges.assign(m, {});
-    d.assign(n, 0);
-    low.assign(n, 0);
-    TIME = 1;
-    cond = true;
-    tarjan(0, -1);
-    if (cond)
-        for (const auto &ee: edges)
-            cout << ee.first << " " << ee.second << ln;
-    else
-        cout << 0 << ln;
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t = 1;
-    while (t--)
-        solve();
-    return 0;
-}
diff --git a/Problemas/Grafos/AP & Bridges/Birthday Party.java b/Problemas/Grafos/AP & Bridges/Birthday Party.java
deleted file mode 100644
index 9c1de7f..0000000
--- a/Problemas/Grafos/AP & Bridges/Birthday Party.java	
+++ /dev/null
@@ -1,118 +0,0 @@
-//https://open.kattis.com/problems/birthday
-import java.io.*;
-import java.util.*;
-class Main{
-    static int N;
-    static ArrayList<Integer>[] adj;
-    static int[] d, f, low;
-    static int time;
-    static ArrayList<int[]> bridg;
-    static boolean b;
-    public static void main(String[] args) throws IOException {
-        Scanner sc = new Scanner();
-        PrintWriter out=new PrintWriter(System.out);
-        while (true){
-            N=sc.nextInt();int m=sc.nextInt();
-            if(N==0 && m==0)
-                break;
-            d=new int[N];
-            low=new int[N];
-            adj=new ArrayList[N];
-            b=false;
-            for (int i = 0; i < N; i++)
-                adj[i]=new ArrayList<>();
-            for (int i = 0; i < m ; i++) {
-                int a=sc.nextInt();
-                int b=sc.nextInt();
-                adj[a].add(b);
-                adj[b].add(a);
-            }
-            if(!bfs())
-                System.out.println("YES");
-            else{
-                get_bridges();
-                System.out.println(b ? "YES":"NO");
-            }
-
-        }
-    }
-    static boolean bfs(){
-        boolean[] state=new boolean[N];
-        Queue<Integer> q=new LinkedList<>();
-        int c=1;
-        state[0]=true;
-        q.add(0);
-        while (!q.isEmpty()){
-            int u=q.poll();
-            for(int v:adj[u]){
-                if(!state[v]){
-                    state[v]=true;
-                    c++;
-                    q.add(v);
-                }
-            }
-        }
-        return c==N;
-    }
-    static void dfs(int u, int par) {
-        if(b)
-            return;
-        d[u] = time++;
-        low[u] = d[u];
-        for(int v:adj[u]) {
-            if (v==par) continue;
-            else if (d[v]>0)
-                low[u] = Math.min(low[u], d[v]);
-            else {
-                dfs(v, u);
-                low[u] = Math.min(low[u], low[v]);
-                if (low[v]>d[u])b=true;
-            }
-        }
-
-    }
-
-    static void get_bridges() {
-        d = new int[N];
-        low = new int[N];
-        time = 1;
-        bridg = new ArrayList<int[]>();
-        dfs(0, -1);
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    return "";
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar(){
-            return next().charAt(0);
-        }
-
-    }
-}
diff --git a/Problemas/Grafos/AP & Bridges/Critical Links.cpp b/Problemas/Grafos/AP & Bridges/Critical Links.cpp
deleted file mode 100644
index ee281f9..0000000
--- a/Problemas/Grafos/AP & Bridges/Critical Links.cpp	
+++ /dev/null
@@ -1,74 +0,0 @@
-//https://vjudge.net/problem/UVA-796
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(), A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define ll long long
-#define ull unsigned long long
-
-vector<vector<int> > adj;
-vector<int> d, low;
-int TIME;
-vector<pair<int, int> > ans;
-
-void dfs(int u, int par) {
-    d[u] = low[u] = TIME++;
-    for (const auto &v: adj[u]) {
-        if (v == par)
-            continue;
-        if (d[v] == 0) {
-            dfs(v, u);
-            low[u] = min(low[u], low[v]);
-            if (d[u] < low[v]) {
-                if (u < v)
-                    ans.emplace_back(u, v);
-                else
-                    ans.emplace_back(v, u);
-            }
-        } else {
-            low[u] = min(low[u], d[v]);
-        }
-    }
-}
-
-void solve() {
-    int n;
-    while (cin >> n) {
-        adj.assign(n, vector<int>());
-        fori(i, 0, n) {
-            int a, m;
-            char c;
-            cin >> a;
-            cin >> c >> m >> c;
-            fori(j, 0, m) {
-                int b;
-                cin >> b;
-                adj[a].push_back(b);
-            }
-        }
-        TIME = 1;
-        d.assign(n, 0);
-        low.assign(n, 0);
-        ans.clear();
-        fori(u, 0, n)
-            if (d[u] == 0)
-                dfs(u, -1);
-        int k = ans.size();
-        cout << k << " critical links" << ln;
-        sort(all(ans));
-        for (const auto &ee: ans)
-            cout << ee.first << " - " << ee.second << ln;
-        cout << ln;
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t = 1;
-    while (t--)
-        solve();
-    return 0;
-}
diff --git a/Problemas/Grafos/AP & Bridges/DovesAndBombs.java b/Problemas/Grafos/AP & Bridges/DovesAndBombs.java
deleted file mode 100644
index eecb2e2..0000000
--- a/Problemas/Grafos/AP & Bridges/DovesAndBombs.java	
+++ /dev/null
@@ -1,94 +0,0 @@
-//https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=1706
-import java.io.*;
-import java.util.*;
-
-public class DovesAndBombs {
-	static int n;
-	static ArrayList<Integer>[] adj;
-	static int[] d, low;
-	static int time;
-	static int[] ap;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		PrintWriter out = new PrintWriter(System.out);
-		StringTokenizer st;
-		while (true) {
-			st = new StringTokenizer(in.readLine());
-			n = Integer.parseInt(st.nextToken());
-			int m = Integer.parseInt(st.nextToken());
-			if (n == 0 && m == 0)
-				break;
-			adj = new ArrayList[n];
-			for (int i = 0; i < n; i++)
-				adj[i] = new ArrayList<>();
-			while (true) {
-				st = new StringTokenizer(in.readLine());
-				int a = Integer.parseInt(st.nextToken());
-				int b = Integer.parseInt(st.nextToken());
-				if (a == -1 && b == -1)
-					break;
-				adj[a].add(b);
-				adj[b].add(a);
-			}
-			TreeSet<Output> ans = new TreeSet<>();
-			d = new int[n];
-			low = new int[n];
-			time = 1;
-			ap = new int[n];
-			Arrays.fill(d, -1);
-			for (int i = 0; i < n; i++)
-				if (d[i] == -1)
-					dfs(i, -1);
-			for (int i = 0; i < n; i++)
-				ans.add(new Output(i, ap[i] + 1));
-			for (int i = 0; i < m; i++)
-				out.println(ans.pollFirst());
-			out.println("");
-		}
-		out.flush();
-	}
-
-	static void dfs(int u, int par) {
-		d[u] = time++;
-		low[u] = d[u];
-		int children = 0;
-		for (int v : adj[u])
-			if (v == par)
-				continue;
-			else if (d[v] > 0)
-				low[u] = Math.min(low[u], d[v]);
-			else {
-				children++;
-				dfs(v, u);
-				low[u] = Math.min(low[u], low[v]);
-				if (par != -1 && low[v] >= d[u])
-					ap[u]++;
-			}
-		if (par == -1 && children > 1)
-			ap[u]++;
-	}
-
-	static class Output implements Comparable<Output> {
-		int vertex;
-		int paloma;
-
-		Output(int v, int p) {
-			this.vertex = v;
-			this.paloma = p;
-		}
-
-		public int compareTo(Output o) {
-			if (paloma < o.paloma)
-				return 1;
-			if (paloma > o.paloma)
-				return -1;
-			return Integer.compare(vertex, o.vertex);
-		}
-
-		public String toString() {
-			return vertex + " " + paloma;
-		}
-
-	}
-}
diff --git a/Problemas/Grafos/AP & Bridges/Hedge Mazes.cpp b/Problemas/Grafos/AP & Bridges/Hedge Mazes.cpp
deleted file mode 100644
index c33f7e9..0000000
--- a/Problemas/Grafos/AP & Bridges/Hedge Mazes.cpp	
+++ /dev/null
@@ -1,97 +0,0 @@
-//https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3785
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(),A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-
-
-int n, tiempo;
-vector<vector<int> > adj;
-vector<int> d, low, pi, Size;
-
-int Find(int u) {
-    int aux = u;
-    while (u != pi[u])
-        u = pi[u];
-    while (aux != pi[aux]) {
-        aux = pi[aux];
-        pi[aux] = u;
-    }
-    return u;
-}
-
-void Union(int u, int v) {
-    int x = Find(u);
-    int y = Find(v);
-    if (x == y)
-        return;
-    if (Size[x] < Size[y]) {
-        pi[x] = y;
-        Size[y] += Size[x];
-    } else {
-        pi[y] = x;
-        Size[x] += Size[y];
-    }
-}
-
-
-void dfs(int u, int par) {
-    d[u] = low[u] = tiempo++;
-    for (const auto &v: adj[u]) {
-        if (v == par)
-            continue;
-        if (d[v] > 0)
-            low[u] = min(low[u], d[v]);
-        else {
-            dfs(v, u);
-            low[u] = min(low[u], low[v]);
-            if (low[v] > d[u])
-                Union(v, u);
-        }
-    }
-}
-
-
-void solve() {
-    while (true) {
-        int m, q;
-        cin >> n >> m >> q;
-        if (n == 0 && m == 0 && q == 0)break;
-        adj.assign(n, vector<int>());
-        fori(i, 0, m) {
-            int a, b;
-            cin >> a >> b;
-            a--;
-            b--;
-            adj[a].push_back(b);
-            adj[b].push_back(a);
-        }
-        d.assign(n, 0);
-        low.assign(n, 0);
-        pi.assign(n, 0);
-        Size.assign(n, 1);
-        tiempo = 1;
-        fori(i, 0, n)
-            pi[i] = i;
-        dfs(0, -1);
-        fori(i, 0, q) {
-            int a, b;
-            cin >> a >> b;
-            a--;
-            b--;
-            cout << (Find(a) == Find(b) ? "Y" : "N") << ln;
-        }
-        cout << "-" << ln;
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t = 1;
-    while (t--)
-        solve();
-    return 0;
-}
diff --git a/Problemas/Grafos/AP & Bridges/Sumberging Islands.java b/Problemas/Grafos/AP & Bridges/Sumberging Islands.java
deleted file mode 100644
index 8ccdaf0..0000000
--- a/Problemas/Grafos/AP & Bridges/Sumberging Islands.java	
+++ /dev/null
@@ -1,75 +0,0 @@
-/* https://vjudge.net/problem/SPOJ-SUBMERGE */
-
-import java.io.*;
-import java.util.*;
-
-public class SubmergingIslands {
-    
-    static int N;
-    static int contador;
-    static HashMap<String, Integer> indices;
-    static ArrayList<Integer>[] adj;
-    static int[] d, low;
-    static int time;
-    static boolean[] ap;
-
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf= new BufferedReader(new InputStreamReader(System.in));
-        while(true){
-            String[] l1=bf.readLine().split(" ");
-            int n=Integer.parseInt(l1[0]);
-            int m=Integer.parseInt(l1[1]);
-            if(n==0&&m==0)
-                return;
-            N=n;
-            adj=new ArrayList[n];
-            for (int i = 0; i < n; i++)
-                adj[i]=new ArrayList<>();
-            for (int i = 0; i < m; i++) {
-                String[] l2=bf.readLine().split(" ");
-                int a=Integer.parseInt(l2[0]);
-                int b=Integer.parseInt(l2[1]);
-                addEdge(a-1,b-1);
-            }
-            get_articulation_points();
-            int contador=0;
-            for (int i = 0; i < n; i++) {
-                if(ap[i])
-                    contador++;
-            }
-            System.out.println(contador);
-        }
-    }
-
-    static void addEdge(int a, int b){
-        adj[a].add(b);
-        adj[b].add(a);
-    }
-    
-    static void dfs(int u, int par) {
-        d[u] = time++;
-        low[u] = d[u];
-        int children = 0;
-        contador++;
-        for(int v:adj[u]) {
-            if (v==par) continue;
-            else if (d[v]>0)
-                low[u] = Math.min(low[u], d[v]);
-            else {
-                children++;
-                dfs(v, u);
-                low[u] = Math.min(low[u], low[v]);
-                if (par!=-1 && low[v]>=d[u]) ap[u] = true;
-            }
-        }
-        if (par==-1 && children>1) ap[u] = true;
-    }
-
-    static void get_articulation_points() {
-        d = new int[N];
-        low = new int[N];
-        time = 1;
-        ap = new boolean[N];
-        dfs(0,   -1);
-    }
-}
diff --git a/Problemas/Grafos/AP & Bridges/Tourist Guide.java b/Problemas/Grafos/AP & Bridges/Tourist Guide.java
deleted file mode 100644
index 028ff4c..0000000
--- a/Problemas/Grafos/AP & Bridges/Tourist Guide.java	
+++ /dev/null
@@ -1,120 +0,0 @@
-//https://vjudge.net/problem/UVA-10199
-
-import java.io.*;
-import java.util.*;
-
-public class TouristGuide {
-    static int n;
-    static ArrayList<Integer>[] adj;
-    static int[] d, low;
-    static int time;
-    static Boolean[] ap;
-
-    public static void main(String[] args) throws Exception {
-        Input in = new Input(System.in);
-        int map = 1;
-        while(true){
-            n = in.nextInt();
-            if(n == 0) break;
-            Map<String, Integer> cities = new HashMap<>();
-            HashMap<Integer,String> citiesinv = new HashMap<>();
-            for (int i = 0; i < n; i++){
-                String city = in.nextLine();
-                cities.put(city, i);
-                citiesinv.put(i, city);
-            }
-            adj = new ArrayList[n];
-            for(int i = 0; i < n; i++)
-                adj[i] = new ArrayList<>();
-            int m = in.nextInt();
-            for (int i = 0; i < m; i++){
-                String a = in.next();
-                String b = in.next();
-                adj[cities.get(a)].add(cities.get(b));
-                adj[cities.get(b)].add(cities.get(a));
-            }
-            get_articulation_points();
-            int count = 0;
-            for (boolean x : ap)
-                if (x) count++;
-            if (map != 1) System.out.println();
-            System.out.printf("City map #%d: %d camera(s) found\n", map, count);
-            TreeSet<String> arbol = new TreeSet<>();
-            for (int i = 0; i < ap.length; i++)
-                if (ap[i]) arbol.add(citiesinv.get(i));
-            map += 1;
-            for (String city : arbol) System.out.println(city);
-        }
-    }
-
-    static void dfs(int u, int par) {
-        d[u] = time++;
-        low[u] = d[u];
-        int children = 0;
-        for(int v : adj[u]) {
-            if (v == par) continue;
-            else if (d[v] > 0)
-                low[u] = Math.min(low[u], d[v]);
-            else {
-                children++;
-                dfs(v, u);
-                low[u] = Math.min(low[u], low[v]);
-                if (par != -1 && low[v] >= d[u]) ap[u] = true;
-            }
-        }
-        if (par == -1 && children > 1) ap[u] = true;
-    }
-
-    static void get_articulation_points() {
-        d = new int[n];
-        low = new int[n];
-        time = 1;
-        ap = new Boolean[n];
-        Arrays.fill(ap, false);
-        for (int i = 0; i < n; i++)
-            if (d[i] == 0) dfs(i, -1);
-    }
-
-    static class Input {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Input(InputStream f) {
-            br = new BufferedReader(new InputStreamReader(f));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-    }
-}
diff --git a/Problemas/Grafos/BitMask/Cleaning Robot.cpp b/Problemas/Grafos/BitMask/Cleaning Robot.cpp
deleted file mode 100644
index 8532919..0000000
--- a/Problemas/Grafos/BitMask/Cleaning Robot.cpp	
+++ /dev/null
@@ -1,86 +0,0 @@
-//https://vjudge.net/problem/SPOJ-CLEANRBT
-using namespace std;
-#include <bits/stdc++.h>
-#define ll long long
-#define Pair pair<int,int>
-#define eb emplace_back
-#define all(x) (x).begin(), (x).end()
-#define ln "\n"
-#define For(i, a, b) for(int i = a; i < b; i++)
-#define Rfor(i, a, b) for(int i = a; i >= b; i--)
-const ll inf = 1e18;
-const ll mod = 998244353;
-const int N = 100001;
-struct PairHash {
-    template <typename T1, typename T2>
-    size_t operator()(const pair<T1, T2>& p) const {
-        auto hash1 = hash<T1>{}(p.first);
-        auto hash2 = hash<T2>{}(p.second);
-        return hash1 ^ hash2*31;
-    }
-};
-int r, c;
-vector<string> grid;
-vector<vector<int> > cambio = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
-vector<vector<vector<int>>> d;
-unordered_map<Pair,int,PairHash> mp;
-struct Node {
-    int x,y,msk;
-};
-void bfs(Pair s) {
-    d[s.first][s.second][0]=0;
-    queue<Node> q;
-    q.push({s.first,s.second,0});
-    while(!q.empty()) {
-        auto u=q.front();
-        q.pop();
-        int i=u.x,j=u.y,msk=u.msk;
-        for(auto ch:cambio) {
-            int x=i+ch[0],y=j+ch[1];
-            int newMask=msk;
-            if(x<0||x>=r||y<0||y>=c||grid[x][y]=='x')
-                continue;
-            if(mp.count({x,y}))
-                newMask|=1<<mp[{x,y}];
-            if(d[i][j][msk]+1<d[x][y][newMask]) {
-                d[x][y][newMask]=d[i][j][msk]+1;
-                q.push({x,y,newMask});
-            }
-        }
-    }
-}
-int main() {
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    //freopen("socdist.in", "r",stdin);
-    //freopen("socdist.out", "w", stdout)
-    while (true) {
-        cin >> c >> r;
-        if (r == 0 && c == 0)break;
-        grid.resize(r);
-        mp.clear();
-        Pair s;
-        int k = 0;
-        For(i, 0, r) {
-            cin >> grid[i];
-            For(j,0,c) {
-                if (grid[i][j] == 'o')
-                    s = {i, j};
-                else if (grid[i][j] == '*')
-                    mp[{i,j}]=k++;
-            }
-        }
-        d.assign(r, vector<vector<int>>(c,vector<int>(1<<k,1e9)));
-        bfs(s);
-        int ans=1e9;
-        For(i, 0, r) {
-            For(j, 0, c) {
-                if(grid[i][j]=='*')
-                    ans=min(ans, d[i][j][(1<<k)-1]);
-            }
-        }
-        cout<<(ans==1e9?-1:ans)<<ln;
-    }
-
-    return 0;
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/Angry Programmer.java b/Problemas/Grafos/Flujos/maxFlow-minCut/Angry Programmer.java
deleted file mode 100644
index 789cd94..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/Angry Programmer.java	
+++ /dev/null
@@ -1,162 +0,0 @@
-//https://vjudge.net/problem/UVA-11506
-import java.io.*;
-import java.util.*;
-
-public class Main {
-    static ArrayList<Integer>[] adj;
-    static int n;
-    static final int INF = Integer.MAX_VALUE;
-    static int[][] capacity;
-
-    public static void main(String[] args) {
-        Scanner sc = new Scanner();
-        PrintWriter out = new PrintWriter(System.out);
-        for (;;) {
-            n = sc.nextInt();
-            int m = sc.nextInt();
-            if (n == 0 && m == 0)
-                break;
-            adj = new ArrayList[2 * n];
-            capacity = new int[2 * n][2 * n];
-            for (int i = 0; i < adj.length; i++)
-                adj[i] = new ArrayList<>();
-
-            capacity[0][n] = INF;
-            capacity[n][0] = INF;
-            capacity[n-1][2*n-1] = INF;
-            capacity[2*n-1][n-1] = INF;
-            addEdge(n, 0);
-            addEdge(0, n);
-            addEdge(n - 1, 2 * n - 1);
-            addEdge(2 * n - 1, n - 1);
-            for (int i = 0; i < n - 2; i++) {
-                int a = sc.nextInt() - 1;
-                int w = sc.nextInt();
-                addEdge(a, a + n);
-                addEdge(a + n, a);
-                capacity[a][a+n] = w;
-
-            }
-            for (int i = 0; i < m; i++) {
-                int a = sc.nextInt() - 1;
-                int b = sc.nextInt() - 1;
-                int w = sc.nextInt();
-                addEdge(a+n,b);
-                addEdge(b,a+n);
-                capacity[a+n][b] = w;
-                addEdge(b+n,a);
-                addEdge(a,b+n);
-                capacity[b+n][a] = w;
-            }
-            out.println(maxflow(0,n-1));
-        }
-        out.close();
-
-    }
-
-    static void addEdge(int a, int b) {
-        adj[a].add(b);
-    }
-
-    static boolean bfs(int s, int t, int[] parent) {
-        boolean[] visited = new boolean[n * 2];
-        Queue<Integer> q = new LinkedList<>();
-        q.add(s);
-        parent[s] = -1;
-        visited[s] = true;
-        while (!q.isEmpty()) {
-            int cur = q.poll();
-            for (int n : adj[cur]) {
-                if (!visited[n] && capacity[cur][n] > 0) {
-                    parent[n] = cur;
-                    visited[n] = true;
-                    q.add(n);
-                    if (n == t)
-                        return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    static int maxflow(int s, int t) {
-        int[] pi = new int[2 * n];
-        int maxflow = 0;
-        while (bfs(s, t, pi)) {
-            int flow = INF;
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                flow = Math.min(flow, capacity[p][cur]);
-            }
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                capacity[p][cur] -= flow;
-                capacity[cur][p] += flow;
-            }
-
-            maxflow += flow;
-        }
-        return maxflow;
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public void close() throws IOException {
-            br.close();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/Coconuts.cpp b/Problemas/Grafos/Flujos/maxFlow-minCut/Coconuts.cpp
deleted file mode 100644
index 50596a7..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/Coconuts.cpp
+++ /dev/null
@@ -1,114 +0,0 @@
-//https://vjudge.net/problem/SPOJ-COCONUTS
-#include <bits/stdc++.h>
-using namespace std;
-struct FlowEdge {
-    int v, u;
-    long long cap, flow = 0;
-    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}
-};
-
-struct Dinic {
-    const long long flow_inf = 1e18;
-    vector<FlowEdge> edges;
-    vector<vector<int>> adj;
-    int n, m = 0;
-    int s, t;
-    vector<int> level, ptr;
-    queue<int> q;
-
-    Dinic(int n, int s, int t) : n(n), s(s), t(t) {
-        adj.resize(n);
-        level.resize(n);
-        ptr.resize(n);
-    }
-
-    void add_edge(int v, int u, long long cap) {
-        edges.emplace_back(v, u, cap);
-        edges.emplace_back(u, v, 0);
-        adj[v].push_back(m);
-        adj[u].push_back(m + 1);
-        m += 2;
-    }
-
-    bool bfs() {
-        while (!q.empty()) {
-            int v = q.front();
-            q.pop();
-            for (int id : adj[v]) {
-                if (edges[id].cap == edges[id].flow)
-                    continue;
-                if (level[edges[id].u] != -1)
-                    continue;
-                level[edges[id].u] = level[v] + 1;
-                q.push(edges[id].u);
-            }
-        }
-        return level[t] != -1;
-    }
-
-    long long dfs(int v, long long pushed) {
-        if (pushed == 0)
-            return 0;
-        if (v == t)
-            return pushed;
-        for (int& cid = ptr[v]; cid < (int)adj[v].size(); cid++) {
-            int id = adj[v][cid];
-            int u = edges[id].u;
-            if (level[v] + 1 != level[u])
-                continue;
-            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));
-            if (tr == 0)
-                continue;
-            edges[id].flow += tr;
-            edges[id ^ 1].flow -= tr;
-            return tr;
-        }
-        return 0;
-    }
-
-    long long flow() {
-        long long f = 0;
-        while (true) {
-            fill(level.begin(), level.end(), -1);
-            level[s] = 0;
-            q.push(s);
-            if (!bfs())
-                break;
-            fill(ptr.begin(), ptr.end(), 0);
-            while (long long pushed = dfs(s, flow_inf)) {
-                f += pushed;
-            }
-        }
-        return f;
-    }
-};
-
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    while(true) {
-        int n,m;
-        cin >> n >> m;
-        if(n==0)
-            break;
-        Dinic fl(n+2,0,n+1);
-        for(int i =1;i<=n;i++) {
-            int c;
-            cin >> c;
-            if(c)
-                fl.add_edge(0,i,1);
-            else
-                fl.add_edge(i,n+1,1);
-        }
-        for(int i =1;i<=m;i++) {
-            int u,v;
-            cin >> u >> v;
-            fl.add_edge(u,v,1);
-            fl.add_edge(v,u,1);
-        }
-        cout << fl.flow() << "\n";
-
-    }
-    return 0;
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/Cops and Robbers.java b/Problemas/Grafos/Flujos/maxFlow-minCut/Cops and Robbers.java
deleted file mode 100644
index 37c8891..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/Cops and Robbers.java	
+++ /dev/null
@@ -1,168 +0,0 @@
-//https://open.kattis.com/problems/copsandrobbers
-import java.io.*;
-import java.util.*;
-
-class Main {
-    static HashSet<Integer>[] adj;
-    static int n;
-    static final int INF = 1<<30;
-    static int[][] capacity;
-    public static void main(String[] args) {
-        Scanner sc=new Scanner();
-        int m=sc.nextInt(),N=sc.nextInt(),c=sc.nextInt();
-        n=N*m*2+2;
-        adj=new HashSet[n];
-        for(int i=0;i<n;i++)
-            adj[i]=new HashSet<>();
-        capacity=new int[n][n];
-        char[][] map=new char[N][m];
-        for (int i = 0; i < N; i++)
-            map[i]=sc.next().toCharArray();
-        int[] dx={0,0,1,-1};
-        int[] dy={1,-1,0,0};
-        int s=n-2;
-        int t=n-1;
-        int[] pesos=new int[c];
-        for (int i = 0; i < c; i++)
-            pesos[i]=sc.nextInt();
-        for (int i = 0; i < N; i++) {
-            for (int j = 0; j < m; j++) {
-                int u=index(N,m,i,j,0);
-                int v=index(N,m,i,j,1);
-                if(map[i][j]=='B'){
-                    adj[s].add(v);
-                    adj[v].add(s);
-                    capacity[s][v]=INF;
-                }
-                else if(map[i][j]=='.'){
-                    adj[u].add(v);
-                    adj[v].add(u);
-                    capacity[u][v]=INF;
-                }
-                else{
-                    adj[u].add(v);
-                    adj[v].add(u);
-                    capacity[u][v]=pesos[map[i][j]-'a'];
-                }
-                for (int k = 0; k < 4; k++) {
-                    int ii=i+dx[k];
-                    int jj=j+dy[k];
-                    if(ii>=0&&ii<N&&jj>=0&&jj<m){
-                        int w=index(N,m,ii,jj,0);
-                        adj[v].add(w);
-                        adj[w].add(v);
-                        capacity[v][w]=INF;
-                    }
-                    else{
-                        adj[v].add(t);
-                        adj[t].add(v);
-                        capacity[v][t]=INF;
-                    }
-                }
-            }
-        }
-        int ans=maxflow(s,t);
-        System.out.println(ans>=INF?-1:ans);
-    }
-    static int index(int n, int m,int i, int j, int d){
-        return d==0 ? i*m+j:i*m+j+n*m;
-    }
-    static int maxflow(int s, int t) {
-        int[] pi = new int[n];
-        int maxflow = 0;
-        while (bfs(s, t, pi)) {
-            int flow = INF;
-            for (int u = t; u != s; u = pi[u]) {
-                int p = pi[u];
-                flow = Math.min(flow, capacity[p][u]);
-            }
-            for (int u = t; u != s; u = pi[u]) {
-                int p = pi[u];
-                capacity[p][u] -= flow;
-                capacity[u][p] += flow;
-            }
-            maxflow += flow;
-        }
-        return maxflow;
-    }
-
-    static boolean bfs(int s, int t, int[] pi) {
-        boolean[] visited = new boolean[n];
-        Queue<Integer> Q = new LinkedList<>();
-        Q.add(s);
-        pi[s] = -1;
-        visited[s] = true;
-        while (!Q.isEmpty()) {
-            int u = Q.poll();
-            for (int v : adj[u])
-                if (!visited[v] && capacity[u][v] > 0) {
-                    pi[v] = u;
-                    visited[v] = true;
-                    if (v == t)
-                        return true;
-                    Q.add(v);
-                }
-        }
-        return false;
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public void close() throws IOException {
-            br.close();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/Distinct Routes.java b/Problemas/Grafos/Flujos/maxFlow-minCut/Distinct Routes.java
deleted file mode 100644
index 348c251..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/Distinct Routes.java	
+++ /dev/null
@@ -1,154 +0,0 @@
-//https://vjudge.net/problem/CSES-1711
-import java.io.*;
-import java.util.*;
-
-public class Main {
-    static ArrayList<Integer>[] adj;
-    static int n;
-    static final int INF = Integer.MAX_VALUE;
-    static int[][] capacity;
-    static int[][] flo;
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner();
-        PrintWriter out=new PrintWriter(System.out);
-        n=sc.nextInt();
-        int m=sc.nextInt();
-        adj=new ArrayList[n];
-        capacity=new int[n][n];
-        flo=new int[n][n];
-        for (int i = 0; i < n; i++)
-            adj[i]=new ArrayList<>();
-        for (int i = 0; i < m; i++) {
-            int u=sc.nextInt()-1,v=sc.nextInt()-1;
-            adj[u].add(v);
-            adj[v].add(u);
-            capacity[u][v]=1;
-        }
-        int flow=maxflow(0,n-1);
-        out.println(flow);
-        for(int i =0;i<flow;i++){
-            StringBuilder sb=new StringBuilder();
-            int k=n-1;
-            int c=1;
-            while(k>0){
-                sb.insert(0,(k+1)+" ");
-                for (int j = 0; j < n; j++) {
-                    if(flo[j][k]==1){
-                        flo[j][k]=0;
-                        k=j;
-                        c++;
-                        break;
-                    }
-                }
-            }
-            sb.insert(0,1+" ");
-            out.println(c);
-            out.println(sb);
-        }
-        out.close();
-    }
-    static boolean bfs(int s, int t, int[] parent) {
-        boolean[] visited = new boolean[n];
-        Queue<Integer> q = new LinkedList<>();
-        q.add(s);
-        parent[s] = -1;
-        visited[s] = true;
-        while (!q.isEmpty()) {
-            int cur = q.poll();
-            for (int n : adj[cur]) {
-                if (!visited[n] && capacity[cur][n] > 0) {
-                    parent[n] = cur;
-                    visited[n] = true;
-                    q.add(n);
-                    if (n == t)
-                        return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    static int maxflow(int s, int t) {
-        int[] pi = new int[n];
-        int maxflow = 0;
-        while (bfs(s, t, pi)) {
-            int flow = INF;
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                flow = Math.min(flow, capacity[p][cur]);
-            }
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                capacity[p][cur] -= flow;
-                capacity[cur][p] += flow;
-                flo[p][cur] += flow;
-                flo[cur][p] -= flow;
-            }
-
-            maxflow += flow;
-        }
-        return maxflow;
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public void close() throws IOException {
-            br.close();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/Download Speed.java b/Problemas/Grafos/Flujos/maxFlow-minCut/Download Speed.java
deleted file mode 100644
index e660900..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/Download Speed.java	
+++ /dev/null
@@ -1,157 +0,0 @@
-//https://vjudge.net/problem/CSES-1694
-import java.io.*;
-import java.util.*;
-
-public class Main {
-    public static void main(String[] args) {
-        Scanner sc=new Scanner();
-        int n=sc.nextInt()+1;
-        int m=sc.nextInt();
-        DinicMaxFlow d=new DinicMaxFlow(n);
-        for (int i = 0; i < m ; i++) {
-            int u=sc.nextInt(),v=sc.nextInt(),w=sc.nextInt();
-            d.addEdge(u,v,w);
-        }
-        System.out.println(d.maxFlow(1,n-1));
-    }
-    static class Edge {
-        int to, rev;
-        long cap, flow;
-
-        Edge(int to, int rev, long cap) {
-            this.to = to;
-            this.rev = rev;
-            this.cap = cap;
-            this.flow = 0;
-        }
-    }
-
-    static class DinicMaxFlow {
-        int n;
-        List<Edge>[] adj;
-        int[] level;
-        int[] ptr;
-        DinicMaxFlow(int n) {
-            this.n = n;
-            adj = new ArrayList[n];
-            for (int i = 0; i < n; i++) {
-                adj[i] = new ArrayList<>();
-            }
-            level = new int[n];
-            ptr = new int[n];
-        }
-
-        void addEdge(int a, int b, int cap) {
-            adj[a].add(new Edge(b, adj[b].size(), cap));
-            adj[b].add(new Edge(a, adj[a].size() - 1, 0));
-        }
-
-        boolean bfs(int s, int t) {
-            Arrays.fill(level, -1);
-            Queue<Integer> queue = new LinkedList<>();
-            queue.add(s);
-            level[s] = 0;
-            while (!queue.isEmpty()) {
-                int v = queue.poll();
-                for (Edge edge : adj[v]) {
-                    if (level[edge.to] < 0 && edge.flow < edge.cap) {
-                        level[edge.to] = level[v] + 1;
-                        queue.add(edge.to);
-                    }
-                }
-            }
-            return level[t] >= 0;
-        }
-
-        long dfs(int s, int t, long flow) {
-            if (s == t) {
-                return flow;
-            }
-            for (; ptr[s] < adj[s].size(); ptr[s]++) {
-                Edge edge = adj[s].get(ptr[s]);
-                if (level[edge.to] == level[s] + 1 && edge.flow < edge.cap) {
-                    long pushed = dfs(edge.to, t, Math.min(flow, edge.cap - edge.flow));
-                    if (pushed > 0) {
-                        edge.flow += pushed;
-                        adj[edge.to].get(edge.rev).flow -= pushed;
-                        return pushed;
-                    }
-                }
-            }
-            return 0;
-        }
-
-        long maxFlow(int s, int t) {
-            long flow = 0;
-            while (bfs(s, t)) {
-                Arrays.fill(ptr, 0);
-                long pushed;
-                while ((pushed = dfs(s, t, Long.MAX_VALUE)) != 0) {
-                    flow += pushed;
-                }
-            }
-            return flow;
-        }
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public void close() throws IOException {
-            br.close();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/Dungeon of Death.java b/Problemas/Grafos/Flujos/maxFlow-minCut/Dungeon of Death.java
deleted file mode 100644
index dd271e5..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/Dungeon of Death.java	
+++ /dev/null
@@ -1,139 +0,0 @@
-//https://vjudge.net/problem/SPOJ-QUEST4
-import java.io.*;
-import java.util.*;
-public class Main {
-    static long[][] capacity;
-    static HashSet<Integer>[] adj;
-    static int INF = Integer.MAX_VALUE;
-    static int n=245;
-
-    public static void main(String[] args) throws Exception {
-        Scanner sc = new Scanner();
-        PrintWriter out = new PrintWriter(System.out);
-        int ti = sc.nextInt();
-        for (int tim = 0; tim < ti; tim++) {
-            int m=sc.nextInt();
-            adj = new HashSet[n];
-            capacity = new long[n][n];
-            int s=n-2,t=n-1;
-            for (int i = 0; i < n; i++)
-                adj[i] = new HashSet<>();
-            for (int i = 0; i < m; i++) {
-                int u = sc.nextInt(),v = sc.nextInt()+120;
-                adj[u].add(v);
-                adj[v].add(u);
-                adj[s].add(u);
-                adj[u].add(s);
-                adj[v].add(t);
-                adj[t].add(v);
-                capacity[s][u]=1;
-                capacity[v][t]=1;
-                capacity[u][v]=1;
-            }
-            System.out.println(maxflow(s,t));
-        }
-
-
-    }
-
-    static boolean bfs(int s, int t, int[] parent) {
-        boolean[] visited = new boolean[n];
-        Queue<Integer> q = new LinkedList<>();
-        q.add(s);
-        parent[s] = -1;
-        visited[s] = true;
-        while (!q.isEmpty()) {
-            int cur = q.poll();
-            for (int n : adj[cur]) {
-                if (!visited[n] && capacity[cur][n] > 0) {
-                    parent[n] = cur;
-                    visited[n] = true;
-                    q.add(n);
-                    if (n == t)
-                        return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    static long maxflow(int s, int t) {
-        int[] pi = new int[n];
-        long maxflow = 0;
-        while (bfs(s, t, pi)) {
-            long flow = INF;
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                flow = Math.min(flow, capacity[p][cur]);
-            }
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                capacity[p][cur] -= flow;
-                capacity[cur][p] += flow;
-            }
-            maxflow += flow;
-        }
-        return maxflow;
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public void close() throws IOException {
-            br.close();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/Fast Maximum Flow.java b/Problemas/Grafos/Flujos/maxFlow-minCut/Fast Maximum Flow.java
deleted file mode 100644
index 3758322..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/Fast Maximum Flow.java	
+++ /dev/null
@@ -1,158 +0,0 @@
-//https://vjudge.net/problem/SPOJ-FASTFLOW
-import java.io.*;
-import java.util.*;
-
-public class Main {
-    public static void main(String[] args) {
-        Scanner sc=new Scanner();
-        int n=sc.nextInt()+1;
-        int m=sc.nextInt();
-        DinicMaxFlow d=new DinicMaxFlow(n);
-        for (int i = 0; i < m ; i++) {
-            int u=sc.nextInt(),v=sc.nextInt(),w=sc.nextInt();
-            d.addEdge(u,v,w);
-            d.addEdge(v,u,w);
-        }
-        System.out.println(d.maxFlow(1,n-1));
-    }
-    static class Edge {
-        int to, rev;
-        long cap, flow;
-
-        Edge(int to, int rev, long cap) {
-            this.to = to;
-            this.rev = rev;
-            this.cap = cap;
-            this.flow = 0;
-        }
-    }
-
-    static class DinicMaxFlow {
-        int n;
-        List<Edge>[] adj;
-        int[] level;
-        int[] ptr;
-        DinicMaxFlow(int n) {
-            this.n = n;
-            adj = new ArrayList[n];
-            for (int i = 0; i < n; i++) {
-                adj[i] = new ArrayList<>();
-            }
-            level = new int[n];
-            ptr = new int[n];
-        }
-
-        void addEdge(int a, int b, int cap) {
-            adj[a].add(new Edge(b, adj[b].size(), cap));
-            adj[b].add(new Edge(a, adj[a].size() - 1, 0));
-        }
-
-        boolean bfs(int s, int t) {
-            Arrays.fill(level, -1);
-            Queue<Integer> queue = new LinkedList<>();
-            queue.add(s);
-            level[s] = 0;
-            while (!queue.isEmpty()) {
-                int v = queue.poll();
-                for (Edge edge : adj[v]) {
-                    if (level[edge.to] < 0 && edge.flow < edge.cap) {
-                        level[edge.to] = level[v] + 1;
-                        queue.add(edge.to);
-                    }
-                }
-            }
-            return level[t] >= 0;
-        }
-
-        long dfs(int s, int t, long flow) {
-            if (s == t) {
-                return flow;
-            }
-            for (; ptr[s] < adj[s].size(); ptr[s]++) {
-                Edge edge = adj[s].get(ptr[s]);
-                if (level[edge.to] == level[s] + 1 && edge.flow < edge.cap) {
-                    long pushed = dfs(edge.to, t, Math.min(flow, edge.cap - edge.flow));
-                    if (pushed > 0) {
-                        edge.flow += pushed;
-                        adj[edge.to].get(edge.rev).flow -= pushed;
-                        return pushed;
-                    }
-                }
-            }
-            return 0;
-        }
-
-        long maxFlow(int s, int t) {
-            long flow = 0;
-            while (bfs(s, t)) {
-                Arrays.fill(ptr, 0);
-                long pushed;
-                while ((pushed = dfs(s, t, Long.MAX_VALUE)) != 0) {
-                    flow += pushed;
-                }
-            }
-            return flow;
-        }
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public void close() throws IOException {
-            br.close();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/Grid Puzzle I.cpp b/Problemas/Grafos/Flujos/maxFlow-minCut/Grid Puzzle I.cpp
deleted file mode 100644
index f5d20e6..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/Grid Puzzle I.cpp	
+++ /dev/null
@@ -1,139 +0,0 @@
-//https://vjudge.net/problem/CSES-2432
-#include <bits/stdc++.h>
-using namespace std;
-struct FlowEdge {
-    int v, u;
-    long long cap, flow = 0;
-    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}
-};
-
-struct Dinic {
-    const long long flow_inf = 1e18;
-    vector<FlowEdge> edges;
-    vector<vector<int>> adj;
-    int n, m = 0;
-    int s, t;
-    vector<int> level, ptr;
-    queue<int> q;
-
-    Dinic(int n, int s, int t) : n(n), s(s), t(t) {
-        adj.resize(n);
-        level.resize(n);
-        ptr.resize(n);
-    }
-
-    void add_edge(int v, int u, long long cap) {
-        edges.emplace_back(v, u, cap);
-        edges.emplace_back(u, v, 0);
-        adj[v].push_back(m);
-        adj[u].push_back(m + 1);
-        m += 2;
-    }
-
-    bool bfs() {
-        while (!q.empty()) {
-            int v = q.front();
-            q.pop();
-            for (int id : adj[v]) {
-                if (edges[id].cap == edges[id].flow)
-                    continue;
-                if (level[edges[id].u] != -1)
-                    continue;
-                level[edges[id].u] = level[v] + 1;
-                q.push(edges[id].u);
-            }
-        }
-        return level[t] != -1;
-    }
-
-    long long dfs(int v, long long pushed) {
-        if (pushed == 0)
-            return 0;
-        if (v == t)
-            return pushed;
-        for (int& cid = ptr[v]; cid < (int)adj[v].size(); cid++) {
-            int id = adj[v][cid];
-            int u = edges[id].u;
-            if (level[v] + 1 != level[u])
-                continue;
-            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));
-            if (tr == 0)
-                continue;
-            edges[id].flow += tr;
-            edges[id ^ 1].flow -= tr;
-            return tr;
-        }
-        return 0;
-    }
-
-    long long flow() {
-        long long f = 0;
-        while (true) {
-            fill(level.begin(), level.end(), -1);
-            level[s] = 0;
-            q.push(s);
-            if (!bfs())
-                break;
-            fill(ptr.begin(), ptr.end(), 0);
-            while (long long pushed = dfs(s, flow_inf)) {
-                f += pushed;
-            }
-        }
-        return f;
-    }
-};
-int index(int n, int m,int i, int j, int d){
-    return d==0 ? i*m+j:i*m+j+n*m;
-}
-
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    int n;
-    cin >> n;
-    int m=(n<<1)+2;
-    int s=m-2,t=m-1;
-    Dinic fl(m,s,t);
-    int row=0,col=0;
-    for(int i=0;i<n;i++) {
-        int a;
-        cin >> a;
-        row+=a;
-        if(a)
-            fl.add_edge(s,i,a);
-    }
-    for(int i=0;i<n;i++) {
-        int a;
-        cin >> a;
-        col+=a;
-        if(a)
-            fl.add_edge(i+n,t,a);
-    }
-    if(col!=row) {
-        cout<<"-1"<<endl;
-        return 0;
-    }
-    for(int i=0;i<n;i++)
-        for(int j=0;j<n;j++)
-            fl.add_edge(i,j+n,1);
-
-    int ans=fl.flow();
-    if(ans!=col) {
-        cout<<"-1"<<endl;
-        return 0;
-    }
-    vector<vector<bool>>state(n,vector<bool>(n,false));
-    for(int i=0;i<n;i++)
-        for(auto j:fl.adj[i]) {
-            if(j&1)continue;
-            if(fl.edges[j].flow)
-                state[i][fl.edges[j].u-n] = true;
-        }
-    for(int i=0;i<n;i++) {
-        for(int j=0;j<n;j++)
-            cout<<(state[i][j]?"X":".");
-        cout<<"\n";
-    }
-    return 0;
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/Kill the Werewolf.java b/Problemas/Grafos/Flujos/maxFlow-minCut/Kill the Werewolf.java
deleted file mode 100644
index 6262e21..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/Kill the Werewolf.java	
+++ /dev/null
@@ -1,159 +0,0 @@
-//https://www.acmicpc.net/problem/13876
-import java.io.*;
-import java.util.*;
-public class Main {
-    static ArrayList<Integer>[] adj;
-    static int n;
-    static final int INF = Integer.MAX_VALUE;
-    static int[][] capacity;
-    public static void main(String[] args) {
-        Scanner sc=new Scanner();
-        int m=sc.nextInt();
-        int[][] votes=new int[m][2];
-        for (int i = 0; i < m; i++) {
-            votes[i][0]=sc.nextInt()-1;
-            votes[i][1]=sc.nextInt()-1;
-        }
-        int ans=0;
-        for (int i = 0; i < m; i++) {
-            int p=0;
-            n=(m<<1)+2;
-            adj=new ArrayList[n];
-            capacity=new int[n][n];
-            for (int j = 0; j < n; j++)
-                adj[j]=new ArrayList<>();
-            int s=n-2;
-            int t=n-1;
-            for (int j = 0; j < m; j++)
-                if(votes[j][0]==i||votes[j][1]==i)
-                    p++;
-            for (int j = 0; j < m; j++) {
-                if(i==j) continue;
-                if(votes[j][0]!=i&&votes[j][1]!=i){
-                    adj[s].add(j);
-                    adj[j].add(s);
-                    capacity[s][j]=1;
-                    adj[votes[j][0]+m].add(j);
-                    adj[j].add(votes[j][0]+m);
-                    capacity[j][votes[j][0]+m]=1;
-                    adj[votes[j][1]+m].add(j);
-                    adj[j].add(votes[j][1]+m);
-                    capacity[j][votes[j][1]+m]=1;
-                    adj[votes[j][0]+m].add(t);
-                    adj[t].add(votes[j][0]+m);
-                    capacity[votes[j][0]+m][t]=p-1;
-                    adj[votes[j][1]+m].add(t);
-                    adj[t].add(votes[j][1]+m);
-                    capacity[votes[j][1]+m][t]=p-1;
-                }
-            }
-            capacity[votes[i][0]+m][t]--;
-            capacity[votes[i][1]+m][t]--;
-            if(maxflow(s,t)<m-p-1)
-                ans++;
-        }
-        System.out.println(ans);
-
-    }
-    static boolean bfs(int s, int t, int[] parent) {
-        boolean[] visited = new boolean[n];
-        Queue<Integer> q = new LinkedList<>();
-        q.add(s);
-        parent[s] = -1;
-        visited[s] = true;
-        while (!q.isEmpty()) {
-            int cur = q.poll();
-            for (int n : adj[cur]) {
-                if (!visited[n] && capacity[cur][n] > 0) {
-                    parent[n] = cur;
-                    visited[n] = true;
-                    q.add(n);
-                    if (n == t)
-                        return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    static int maxflow(int s, int t) {
-        int[] pi = new int[n];
-        int maxflow = 0;
-        while (bfs(s, t, pi)) {
-            int flow = INF;
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                flow = Math.min(flow, capacity[p][cur]);
-            }
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                capacity[p][cur] -= flow;
-                capacity[cur][p] += flow;
-            }
-
-            maxflow += flow;
-        }
-        return maxflow;
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public void close() throws IOException {
-            br.close();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/Knightsbridge Rises.java b/Problemas/Grafos/Flujos/maxFlow-minCut/Knightsbridge Rises.java
deleted file mode 100644
index 92b4123..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/Knightsbridge Rises.java	
+++ /dev/null
@@ -1,206 +0,0 @@
-//https://vjudge.net/problem/Gym-101606K    Problem K in the PDF
-import java.io.*;
-import java.util.*;
-public class Main {
-    static ArrayList<Integer>[] adj;
-    static int n;
-    static final int INF = Integer.MAX_VALUE;
-    static int[][] capacity;
-    static int[][] flo;
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner();
-        PrintWriter pw=new PrintWriter(System.out);
-        int m=sc.nextInt();
-        int[][] gruas=new int[m][2];
-        for (int i = 0; i < m; i++) {
-            gruas[i][0] = sc.nextInt();
-            gruas[i][1] = sc.nextInt();
-        }
-        int q=sc.nextInt();
-        int[] queries=new int[q];
-        HashMap<Integer,Integer> map=new HashMap<>();
-        HashMap<Integer,Integer> map2=new HashMap<>();
-        int cont=0;
-        for (int i = 0; i < q; i++) {
-            int u=sc.nextInt();
-            queries[i]=u;
-            if(!map.containsKey(u)) {
-                map.put(u, cont);
-                cont++;
-            }
-            if(!map2.containsKey(u))
-                map2.put(u,1);
-            else
-                map2.put(u,map2.get(u)+1);
-        }
-        n=(m<<1)+map.size()+2;
-        capacity=new int[n][n];
-        flo=new int[n][n];
-        int s=n-2;
-        int t=n-1;
-        adj=new ArrayList[n];
-        for (int i = 0; i < n; i++)
-            adj[i]=new ArrayList<>();
-        for (int i = 0; i < m; i++) {
-            adj[i].add(i+m);
-            adj[i+m].add(i);
-            capacity[i][i+m]=1;
-        }
-        for(int i=0;i<m;i++) {
-            if(gruas[i][0]==0){
-                adj[s].add(i);
-                adj[i+m].add(s);
-                capacity[s][i]=1;
-            }
-            for (int j = 0; j < m; j++) {
-                if(i==j)continue;
-                if(gruas[i][1]>=gruas[j][0]){
-                    adj[i+m].add(j);
-                    adj[j].add(i+m);
-                    capacity[i+m][j]=1;
-                }
-            }
-            for (int j = 0; j < q; j++) {
-                if(gruas[i][1]>=queries[j]){
-                    adj[i+m].add((m<<1)+map.get(queries[j]));
-                    adj[(m<<1)+map.get(queries[j])].add(i+m);
-                    capacity[i+m][(m<<1)+map.get(queries[j])]=1;
-                }
-            }
-        }
-        for(Map.Entry<Integer,Integer> entry:map.entrySet()) {
-            adj[(m<<1)+entry.getValue()].add(t);
-            adj[t].add((m<<1)+entry.getValue());
-            capacity[(m<<1)+entry.getValue()][t]=map2.get(entry.getKey());
-        }
-        int flag=maxflow(s,t);
-        if(flag<q){
-            System.out.println("impossible");
-            return;
-        }
-        for(int j:queries) {
-            int k=(m<<1)+map.get(j);
-            StringBuilder sb= new StringBuilder();
-            boolean fl=false;
-            while(k!=s){
-                for(int i = 0;i<n;i++){
-                    if(flo[i][k]==1){
-                        flo[i][k]=0;
-                        k=i;
-                        if(fl){
-                            sb.insert(0, (i+1) + " ");
-                            break;
-                        }
-                    }
-                }
-                fl=!fl;
-            }
-            System.out.println(sb);
-        }
-
-    }
-    static boolean bfs(int s, int t, int[] parent) {
-        boolean[] visited = new boolean[n];
-        Queue<Integer> q = new LinkedList<>();
-        q.add(s);
-        parent[s] = -1;
-        visited[s] = true;
-        while (!q.isEmpty()) {
-            int cur = q.poll();
-            for (int n : adj[cur]) {
-                if (!visited[n] && capacity[cur][n] > 0) {
-                    parent[n] = cur;
-                    visited[n] = true;
-                    q.add(n);
-                    if (n == t)
-                        return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    static int maxflow(int s, int t) {
-        int[] pi = new int[n];
-        int maxflow = 0;
-        while (bfs(s, t, pi)) {
-            int flow = INF;
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                flow = Math.min(flow, capacity[p][cur]);
-            }
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                capacity[p][cur] -= flow;
-                capacity[cur][p] += flow;
-                flo[p][cur] += flow;
-                flo[cur][p] -= flow;
-            }
-
-            maxflow += flow;
-        }
-        return maxflow;
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public void close() throws IOException {
-            br.close();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/Maximum flow.java b/Problemas/Grafos/Flujos/maxFlow-minCut/Maximum flow.java
deleted file mode 100644
index 17602fd..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/Maximum flow.java	
+++ /dev/null
@@ -1,75 +0,0 @@
-//https://basecamp.eolymp.com/en/problems/1991
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-public class FlowEOlymp {
-    static int INF = Integer.MAX_VALUE;
-    static int n;
-    static int[][] capacity;
-    static ArrayList<Integer>[] adj;
-    public static void main(String[] args)throws IOException {
-        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
-        String[] l1 = bf.readLine().split(" ");
-        n = Integer.parseInt(l1[0]);
-        int m = Integer.parseInt(l1[1]);
-        capacity = new int[n][n];
-        adj = new ArrayList[n];
-        for (int i = 0; i < n; i++)
-            adj[i] = new ArrayList<>();
-        for (int i = 0; i < m; i++) {
-            String[] l2 = bf.readLine().split(" ");
-            int a = Integer.parseInt(l2[0]);
-            int b = Integer.parseInt(l2[1]);
-            int c = Integer.parseInt(l2[2]);
-            a--;
-            b--;
-            adj[a].add(b);
-            adj[b].add(a);
-            capacity[a][b]+= c;
-            capacity[b][a]+= c;
-        }
-        System.out.println(maxflow(0,n-1));
-    }
-    static boolean bfs(int s, int t, int[] parent){
-        boolean[] visited=new boolean[n];
-        Queue<Integer> q=new LinkedList<>();
-        q.add(s);
-        parent[s]=-1;
-        visited[s]=true;
-        while (!q.isEmpty()){
-            int cur=q.poll();
-            for(int n:adj[cur]){
-                if(!visited[n]&&capacity[cur][n]>0){
-                    parent[n]=cur;
-                    visited[n]=true;
-                    q.add(n);
-                    if(n==t)
-                        return true;
-                }
-            }
-        }
-        return false;
-    }
-    static int maxflow(int s, int t){
-        int[] pi=new int[n];
-        int maxflow=0;
-        while (bfs(s,t,pi)){
-            int flow=INF;
-            for(int cur=t;cur!=s;cur=pi[cur]){
-                int p=pi[cur];
-                flow=Math.min(flow,capacity[p][cur]);
-            }
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                capacity[p][cur] -= flow;
-                capacity[cur][p] += flow;
-            }
-
-            maxflow += flow;
-        }
-        return maxflow;
-    }
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/MaximumFlow.java b/Problemas/Grafos/Flujos/maxFlow-minCut/MaximumFlow.java
deleted file mode 100644
index fb87110..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/MaximumFlow.java
+++ /dev/null
@@ -1,143 +0,0 @@
-//https://open.kattis.com/problems/maxflow
-import java.io.*;
-import java.util.*;
-class Main {
-    static long c=0;
-    static int[][] capacity;
-    static int[][] fEdges;
-    static ArrayList<Integer>[] adj;
-    static int INF = Integer.MAX_VALUE;
-    static int n;
-    public static void main(String[] args) throws IOException {
-        Scanner sc=new Scanner();
-        PrintWriter out=new PrintWriter(System.out);
-        n=sc.nextInt();
-        int m=sc.nextInt(),s=sc.nextInt(),t=sc.nextInt();
-        capacity=new int[n][n];
-        fEdges=new int[n][n];
-        adj=new ArrayList[n];
-        for (int i = 0; i < n; i++)
-            adj[i]=new ArrayList<>();
-        for (int i = 0; i < m; i++) {
-            int u=sc.nextInt(),v=sc.nextInt(),w=sc.nextInt();
-            adj[u].add(v);
-            adj[v].add(u);
-            capacity[u][v]=w;
-        }
-        int f=maxflow(s,t);
-        LinkedList<int[]> list=new LinkedList<>();
-        for (int i = 0; i < n; i++)
-            for (int j = 0; j < n; j++) {
-                if (i == j) continue;
-                if(fEdges[i][j]>0)
-                    list.add(new int[]{i,j});
-            }
-        out.println(n+" "+f+" "+list.size());
-        for (int[] i:list)
-            out.println(i[0]+" "+i[1]+" "+fEdges[i[0]][i[1]]);
-        out.close();
-
-
-    }
-    static boolean bfs(int s, int t, int[] parent){
-        boolean[] visited=new boolean[n];
-        Queue<Integer> q=new LinkedList<>();
-        q.add(s);
-        parent[s]=-1;
-        visited[s]=true;
-        while (!q.isEmpty()){
-            int cur=q.poll();
-            for(int n:adj[cur]){
-                if(!visited[n]&&capacity[cur][n]>0){
-                    parent[n]=cur;
-                    visited[n]=true;
-                    q.add(n);
-                    if(n==t)
-                        return true;
-                }
-            }
-        }
-        return false;
-    }
-    static int maxflow(int s, int t){
-        int[] pi=new int[n];
-        int maxflow=0;
-        while (bfs(s,t,pi)){
-            int flow=INF;
-            for(int cur=t;cur!=s;cur=pi[cur]){
-                int p=pi[cur];
-                flow=Math.min(flow,capacity[p][cur]);
-            }
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                capacity[p][cur] -= flow;
-                capacity[cur][p] += flow;
-                fEdges[p][cur] += flow;
-                fEdges[cur][p] -= flow;
-            }
-
-            maxflow += flow;
-        }
-        return maxflow;
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public void close() throws IOException {
-            br.close();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/MazeMovementDinic.java b/Problemas/Grafos/Flujos/maxFlow-minCut/MazeMovementDinic.java
deleted file mode 100644
index 6a4cad4..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/MazeMovementDinic.java
+++ /dev/null
@@ -1,117 +0,0 @@
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-class MazeMovement {
-    public static void main(String[] args) throws IOException {
-        //se utiliza el algoritmo de Dinic para hallar la flujo maximos
-        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
-        int n=Integer.parseInt(bf.readLine());
-        DinicMaxFlow f = new DinicMaxFlow(n);
-        int[] datos=new int[n];
-        TreeMap<Integer,Integer> indices=new TreeMap<>();
-        for (int i = 0; i < n; i++) {
-            int v=Integer.parseInt(bf.readLine());
-            datos[i] = v;
-            indices.put(v,i);
-        }
-        for (int i = 0; i < n-1; i++) {
-            for (int j = i+1; j < n; j++) {
-                int v=gcd(datos[i],datos[j]);
-                if(v>1){
-                    f.addEdge(i,j,v);
-                    f.addEdge(j,i,v);
-                }
-            }
-        }
-        int min=indices.pollFirstEntry().getValue();
-        int max=indices.pollLastEntry().getValue();
-        System.out.println(f.maxFlow(min, max));
-    }
-    static int gcd(int n1, int n2) {
-        if (n2 == 0) {
-            return n1;
-        }
-        return gcd(n2, n1 % n2);
-    }
-    static class Edge {
-        int to, rev;
-        int cap, flow;
-
-        Edge(int to, int rev, int cap) {
-            this.to = to;
-            this.rev = rev;
-            this.cap = cap;
-            this.flow = 0;
-        }
-    }
-
-    static class DinicMaxFlow {
-        int n;
-        List<Edge>[] adj;
-        int[] level;
-        int[] ptr;
-        DinicMaxFlow(int n) {
-            this.n = n;
-            adj = new ArrayList[n];
-            for (int i = 0; i < n; i++) {
-                adj[i] = new ArrayList<>();
-            }
-            level = new int[n];
-            ptr = new int[n];
-        }
-
-        void addEdge(int a, int b, int cap) {
-            adj[a].add(new Edge(b, adj[b].size(), cap));
-            adj[b].add(new Edge(a, adj[a].size() - 1, 0));
-        }
-
-        boolean bfs(int s, int t) {
-            Arrays.fill(level, -1);
-            Queue<Integer> queue = new LinkedList<>();
-            queue.add(s);
-            level[s] = 0;
-            while (!queue.isEmpty()) {
-                int v = queue.poll();
-                for (Edge edge : adj[v]) {
-                    if (level[edge.to] < 0 && edge.flow < edge.cap) {
-                        level[edge.to] = level[v] + 1;
-                        queue.add(edge.to);
-                    }
-                }
-            }
-            return level[t] >= 0;
-        }
-
-        int dfs(int s, int t, int flow) {
-            if (s == t) {
-                return flow;
-            }
-            for (; ptr[s] < adj[s].size(); ptr[s]++) {
-                Edge edge = adj[s].get(ptr[s]);
-                if (level[edge.to] == level[s] + 1 && edge.flow < edge.cap) {
-                    int pushed = dfs(edge.to, t, Math.min(flow, edge.cap - edge.flow));
-                    if (pushed > 0) {
-                        edge.flow += pushed;
-                        adj[edge.to].get(edge.rev).flow -= pushed;
-                        return pushed;
-                    }
-                }
-            }
-            return 0;
-        }
-
-        int maxFlow(int s, int t) {
-            int flow = 0;
-            while (bfs(s, t)) {
-                Arrays.fill(ptr, 0);
-                int pushed;
-                while ((pushed = dfs(s, t, Integer.MAX_VALUE)) != 0) {
-                    flow += pushed;
-                }
-            }
-            return flow;
-        }
-    }
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/MazeMovementEdmondKarp.java b/Problemas/Grafos/Flujos/maxFlow-minCut/MazeMovementEdmondKarp.java
deleted file mode 100644
index 5b59b71..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/MazeMovementEdmondKarp.java
+++ /dev/null
@@ -1,91 +0,0 @@
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-class MazeMovement {
-    static int INF = Integer.MAX_VALUE;
-
-    static int n;
-    static int[][] capacity;
-    static ArrayList<Integer>[] adj;
-    public static void main(String[] args)throws IOException {
-        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
-        n=Integer.parseInt(bf.readLine());
-        int[] datos=new int[n];
-        TreeMap<Integer,Integer> indices=new TreeMap<>();
-        adj=new ArrayList[n];
-        for (int i = 0; i < n; i++)
-            adj[i]=new ArrayList<>();
-        capacity=new int[n][n];
-        for (int i = 0; i < n; i++) {
-            int v=Integer.parseInt(bf.readLine());
-            datos[i] = v;
-            indices.put(v,i);
-        }
-        for (int i = 0; i < n-1; i++) {
-            for (int j = i+1; j < n; j++) {
-                int v=gcd(datos[i],datos[j]);
-                if(v>1){
-                    adj[i].add(j);
-                    adj[j].add(i);
-                    capacity[i][j]=v;
-                    capacity[j][i]=v;
-                }
-
-            }
-        }
-        int min=indices.pollFirstEntry().getValue();
-        int max=indices.pollLastEntry().getValue();
-        //System.out.println(Arrays.toString(adj));
-        System.out.println(maxflow(min,max));
-
-    }
-    static int gcd(int n1, int n2) {
-        if (n2 == 0) {
-            return n1;
-        }
-        return gcd(n2, n1 % n2);
-    }
-    static boolean bfs(int s, int t, int[] parent){
-        boolean[] visited=new boolean[n];
-        Queue<Integer> q=new LinkedList<>();
-        q.add(s);
-        parent[s]=-1;
-        visited[s]=true;
-        while (!q.isEmpty()){
-            int cur=q.poll();
-            for(int n:adj[cur]){
-                if(!visited[n]&&capacity[cur][n]>0){
-                    parent[n]=cur;
-                    visited[n]=true;
-                    q.add(n);
-                    if(n==t)
-                        return true;
-                }
-            }
-        }
-        return false;
-    }
-    static int maxflow(int s, int t){
-        int[] pi=new int[n];
-        int maxflow=0;
-        while (bfs(s,t,pi)){
-            int flow=INF;
-            for(int cur=t;cur!=s;cur=pi[cur]){
-                int p=pi[cur];
-                flow=Math.min(flow,capacity[p][cur]);
-            }
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                capacity[p][cur] -= flow;
-                capacity[cur][p] += flow;
-            }
-
-            maxflow += flow;
-        }
-        return maxflow;
-    }
-
-
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/Penguins.cpp b/Problemas/Grafos/Flujos/maxFlow-minCut/Penguins.cpp
deleted file mode 100644
index 0536df0..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/Penguins.cpp
+++ /dev/null
@@ -1,137 +0,0 @@
-//https://vjudge.net/problem/LightOJ-1154
-#include <bits/stdc++.h>
-#define ll long long;
-using namespace std;struct FlowEdge {
-    int v, u;
-    long long cap, flow = 0;
-    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}
-};
-
-struct Dinic {
-    const long long flow_inf = 1e18;
-    vector<FlowEdge> edges;
-    vector<vector<int>> adj;
-    int n, m = 0;
-    int s, t;
-    vector<int> level, ptr;
-    queue<int> q;
-
-    Dinic(int n) : n(n){
-        adj.resize(n);
-        level.resize(n);
-        ptr.resize(n);
-    }
-
-    void add_edge(int v, int u, long long cap) {
-        edges.emplace_back(v, u, cap);
-        edges.emplace_back(u, v, 0);
-        adj[v].push_back(m);
-        adj[u].push_back(m + 1);
-        m += 2;
-    }
-
-    bool bfs() {
-        while (!q.empty()) {
-            int v = q.front();
-            q.pop();
-            for (int id : adj[v]) {
-                if (edges[id].cap == edges[id].flow)
-                    continue;
-                if (level[edges[id].u] != -1)
-                    continue;
-                level[edges[id].u] = level[v] + 1;
-                q.push(edges[id].u);
-            }
-        }
-        return level[t] != -1;
-    }
-
-    long long dfs(int v, long long pushed) {
-        if (pushed == 0)
-            return 0;
-        if (v == t)
-            return pushed;
-        for (int& cid = ptr[v]; cid < (int)adj[v].size(); cid++) {
-            int id = adj[v][cid];
-            int u = edges[id].u;
-            if (level[v] + 1 != level[u])
-                continue;
-            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));
-            if (tr == 0)
-                continue;
-            edges[id].flow += tr;
-            edges[id ^ 1].flow -= tr;
-            return tr;
-        }
-        return 0;
-    }
-
-    long long flow(int _s, int _t) {
-        s=_s,t=_t;
-        long long f = 0;
-        while (true) {
-            fill(level.begin(), level.end(), -1);
-            level[s] = 0;
-            q.push(s);
-            if (!bfs())
-                break;
-            fill(ptr.begin(), ptr.end(), 0);
-            while (long long pushed = dfs(s, flow_inf)) {
-                f += pushed;
-            }
-        }
-        return f;
-    }
-};
-int rock[102][4];
-double dis(int a, int b, int c, int d) {
-    return sqrt((c-a)*(c-a)+(d-b)*(d-b));
-}
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    int tim,tc=0;
-    cin>>tim;
-    while(tim--) {
-        int m;
-        cin>>m;
-        double dist;
-        cin>>dist;
-        for(int i =0;i<m;i++)
-            cin>>rock[i][0]>>rock[i][1]>>rock[i][2]>>rock[i][3];
-        int n=2*m+1;
-        int s=n-1;
-
-        vector<int> l;
-        for (int k =0;k<m;k++) {
-            Dinic d(n);
-            int c=0;
-            for (int i =0;i<m;i++) {
-                int a=rock[i][2];
-                c+=a;
-                if(a)
-                    d.add_edge(s,i,a);
-                d.add_edge(i,i+m,rock[i][3]);
-                for (int j =i+1;j<m;j++) {
-                    if(dis(rock[i][0],rock[i][1],rock[j][0],rock[j][1])<=dist) {
-                        d.add_edge(i+m,j,10000000000);
-                        d.add_edge(j+m,i,10000000000);
-
-                    }
-                }
-            }
-            if(d.flow(s,k)==c)
-                l.push_back(k);
-        }
-        if(l.empty())
-            cout<<"Case "<<++tc<<": -1"<<"\n";
-        else {
-            cout<<"Case "<<++tc<<":";
-            for(auto i:l)
-                cout<<" "<<i;
-            cout<<"\n";
-        }
-    }
-    return 0;
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/PoliceChase.java b/Problemas/Grafos/Flujos/maxFlow-minCut/PoliceChase.java
deleted file mode 100644
index e137ba1..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/PoliceChase.java
+++ /dev/null
@@ -1,101 +0,0 @@
-//https://cses.fi/problemset/task/1695
-import java.io.*;
-import java.util.*;
-
-public class PoliceChase {
-	static int n;
-	static ArrayList<Integer>[] adj;
-	static int INF = Integer.MAX_VALUE;
-	static int[][] capacity;
-
-	@SuppressWarnings("unchecked")
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st = new StringTokenizer(in.readLine());
-		PrintWriter out = new PrintWriter(System.out);
-		n = Integer.parseInt(st.nextToken());
-		int m = Integer.parseInt(st.nextToken());
-		adj = new ArrayList[n];
-		for (int i = 0; i < n; i++)
-			adj[i] = new ArrayList<>();
-		capacity = new int[n][n];
-		for (int i = 0; i < m; i++) {
-			st = new StringTokenizer(in.readLine());
-			int a = Integer.parseInt(st.nextToken()) - 1;
-			int b = Integer.parseInt(st.nextToken()) - 1;
-			adj[a].add(b);
-			adj[b].add(a);
-			capacity[a][b] = capacity[b][a] = 1;
-		}
-		out.println(maxflow(0, n - 1));
-		boolean[] visited = dfs(0);
-		for (int u = 0; u < n; u++)
-			for (int v : adj[u])
-				if (visited[u] && !visited[v])
-					out.println((u + 1) + " " + (v + 1));
-		out.flush();
-	}
-
-	static boolean[] dfs(int s) {
-		boolean[] visited = new boolean[n];
-		Stack<Integer> Q = new Stack<>();
-		visited[s] = true;
-		Q.push(s);
-		while (!Q.isEmpty()) {
-			int u = Q.pop();
-			for (int v = 0; v < n; v++)
-				if (capacity[u][v] > 0 && !visited[v]) {
-					visited[v] = true;
-					Q.push(v);
-				}
-		}
-		return visited;
-	}
-
-	static int maxflow(int s, int t) {
-		int[] pi = new int[n];
-		int maxflow = 0;
-		while (bfs(s, t, pi)) {
-			int flow = INF;
-			for (int u = t; u != s; u = pi[u]) {
-				int p = pi[u];
-				flow = Math.min(flow, capacity[p][u]);
-			}
-			for (int u = t; u != s; u = pi[u]) {
-				int p = pi[u];
-				capacity[p][u] -= flow;
-				capacity[u][p] += flow;
-			}
-			maxflow += flow;
-		}
-		return maxflow;
-	}
-
-	static boolean bfs(int s, int t, int[] pi) {
-		boolean[] visited = new boolean[n];
-		Queue<Integer> Q = new LinkedList<>();
-		Q.add(s);
-		pi[s] = -1;
-		visited[s] = true;
-		while (!Q.isEmpty()) {
-			int u = Q.poll();
-			for (int v : adj[u])
-				if (!visited[v] && capacity[u][v] > 0) {
-					pi[v] = u;
-					visited[v] = true;
-					if (v == t)
-						return true;
-					Q.add(v);
-				}
-		}
-		return false;
-	}
-	/*
-	 * A minimum cut can be found after performing a maximum flow computation using
-	 * the Ford-Fulkerson method. One possible minimum cut is the following: the set
-	 * of all the vertices that can be reached from S in the residual graph (using
-	 * edges with positive residual capacity), and the set of all the other
-	 * vertices. This partition can be easily found using DFS starting at S .
-	 */
-
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/Potholers.java b/Problemas/Grafos/Flujos/maxFlow-minCut/Potholers.java
deleted file mode 100644
index a2ed1f7..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/Potholers.java
+++ /dev/null
@@ -1,137 +0,0 @@
-//https://www.spoj.com/problems/POTHOLE/
-import java.io.*;
-import java.util.*;
-public class Main {
-    static long[][] capacity;
-    static ArrayList<Integer>[] adj;
-    static int INF = Integer.MAX_VALUE;
-    static int n;
-
-    public static void main(String[] args) throws Exception {
-        Scanner sc = new Scanner();
-        PrintWriter out = new PrintWriter(System.out);
-        int t = sc.nextInt();
-        for (int tim = 0; tim < t; tim++) {
-            n=sc.nextInt();
-            adj = new ArrayList[n];
-            capacity = new long[n][n];
-            for (int i = 0; i < n; i++)
-                adj[i] = new ArrayList<>();
-            for (int i = 0; i < n-1; i++) {
-                int j = sc.nextInt();
-                for (int k = 0; k < j; k++) {
-                    int v = sc.nextInt()-1;
-                    adj[i].add(v);
-                    adj[v].add(i);
-                    capacity[i][v]=INF;
-                    if(i==0||v==n-1)
-                        capacity[i][v]=1;
-                }
-            }
-            System.out.println(maxflow(0,n-1));
-        }
-
-
-    }
-
-    static boolean bfs(int s, int t, int[] parent) {
-        boolean[] visited = new boolean[n];
-        Queue<Integer> q = new LinkedList<>();
-        q.add(s);
-        parent[s] = -1;
-        visited[s] = true;
-        while (!q.isEmpty()) {
-            int cur = q.poll();
-            for (int n : adj[cur]) {
-                if (!visited[n] && capacity[cur][n] > 0) {
-                    parent[n] = cur;
-                    visited[n] = true;
-                    q.add(n);
-                    if (n == t)
-                        return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    static long maxflow(int s, int t) {
-        int[] pi = new int[n];
-        long maxflow = 0;
-        while (bfs(s, t, pi)) {
-            long flow = INF;
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                flow = Math.min(flow, capacity[p][cur]);
-            }
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                capacity[p][cur] -= flow;
-                capacity[cur][p] += flow;
-            }
-            maxflow += flow;
-        }
-        return maxflow;
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public void close() throws IOException {
-            br.close();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/Power Transmission.cpp b/Problemas/Grafos/Flujos/maxFlow-minCut/Power Transmission.cpp
deleted file mode 100644
index c4687a1..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/Power Transmission.cpp	
+++ /dev/null
@@ -1,128 +0,0 @@
-//https://vjudge.net/problem/LightOJ-1155
-#include <bits/stdc++.h>
-#define ll long long;
-using namespace std;struct FlowEdge {
-    int v, u;
-    long long cap, flow = 0;
-    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}
-};
-
-struct Dinic {
-    const long long flow_inf = 1e18;
-    vector<FlowEdge> edges;
-    vector<vector<int>> adj;
-    int n, m = 0;
-    int s, t;
-    vector<int> level, ptr;
-    queue<int> q;
-
-    Dinic(int n) : n(n){
-        adj.resize(n);
-        level.resize(n);
-        ptr.resize(n);
-    }
-
-    void add_edge(int v, int u, long long cap) {
-        edges.emplace_back(v, u, cap);
-        edges.emplace_back(u, v, 0);
-        adj[v].push_back(m);
-        adj[u].push_back(m + 1);
-        m += 2;
-    }
-
-    bool bfs() {
-        while (!q.empty()) {
-            int v = q.front();
-            q.pop();
-            for (int id : adj[v]) {
-                if (edges[id].cap == edges[id].flow)
-                    continue;
-                if (level[edges[id].u] != -1)
-                    continue;
-                level[edges[id].u] = level[v] + 1;
-                q.push(edges[id].u);
-            }
-        }
-        return level[t] != -1;
-    }
-
-    long long dfs(int v, long long pushed) {
-        if (pushed == 0)
-            return 0;
-        if (v == t)
-            return pushed;
-        for (int& cid = ptr[v]; cid < (int)adj[v].size(); cid++) {
-            int id = adj[v][cid];
-            int u = edges[id].u;
-            if (level[v] + 1 != level[u])
-                continue;
-            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));
-            if (tr == 0)
-                continue;
-            edges[id].flow += tr;
-            edges[id ^ 1].flow -= tr;
-            return tr;
-        }
-        return 0;
-    }
-
-    long long flow(int _s, int _t) {
-        s=_s,t=_t;
-        long long f = 0;
-        while (true) {
-            fill(level.begin(), level.end(), -1);
-            level[s] = 0;
-            q.push(s);
-            if (!bfs())
-                break;
-            fill(ptr.begin(), ptr.end(), 0);
-            while (long long pushed = dfs(s, flow_inf)) {
-                f += pushed;
-            }
-        }
-        return f;
-    }
-};
-int regul[105];
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    int tim,tc=0;
-    cin>>tim;
-    while(tim--) {
-        int n;
-        cin>>n;
-        for (int i =0; i < n; i++)
-            cin>>regul[i];
-        int g=2*n+2;
-        int s=g-2,t=g-1;
-        Dinic d(g);
-        for (int i =0; i < n; i++)
-            d.add_edge(i,i+n,regul[i]);
-        int m;
-        cin>>m;
-        for (int i =0; i < m; i++) {
-            int u,v,c;
-            cin>>u>>v>>c;
-            u--,v--;
-            d.add_edge(u+n,v,c);
-        }
-        int B,D;
-        cin>>B>>D;
-        for (int i =0; i < B; i++) {
-            int v;
-            cin>>v;
-            v--;
-            d.add_edge(s,v,1<<30);
-        }
-        for (int i =0; i < D; i++) {
-            int u;
-            cin>>u;
-            u--;
-            d.add_edge(u+n,t,1<<30);
-        }
-        cout<<"Case "<<++tc<<": "<<d.flow(s,t)<<"\n";
-    }
-    return 0;
-}
diff --git a/Problemas/Grafos/Flujos/maxFlow-minCut/School Dance.java b/Problemas/Grafos/Flujos/maxFlow-minCut/School Dance.java
deleted file mode 100644
index 7217923..0000000
--- a/Problemas/Grafos/Flujos/maxFlow-minCut/School Dance.java	
+++ /dev/null
@@ -1,168 +0,0 @@
-//https://vjudge.net/problem/CSES-1696
-import java.io.*;
-import java.util.*;
-
-public class Main {
-    static ArrayList<Integer>[] adj;
-    static int n;
-    static final int INF = Integer.MAX_VALUE;
-    static int[][] capacity;
-    static int[][] flo;
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner();
-        PrintWriter out=new PrintWriter(System.out);
-        int boys=sc.nextInt(),girls=sc.nextInt(),m=sc.nextInt();
-        n=boys+girls+2;
-        adj=new ArrayList[n];
-        for (int i = 0; i < n; i++)
-            adj[i]=new ArrayList<>();
-        capacity=new int[n][n];
-        flo=new int[n][n];
-        for (int i = 0; i < m; i++) {
-            int u=sc.nextInt()-1,v=sc.nextInt()-1+boys;
-            adj[u].add(v);
-            adj[v].add(u);
-            capacity[u][v]=1;
-        }
-        int s=n-2,t=n-1;
-        for(int i =0;i<boys;i++){
-            adj[s].add(i);
-            adj[i].add(s);
-            capacity[s][i]=1;
-        }
-        for(int i =0;i<girls;i++){
-            adj[t].add(i+boys);
-            adj[i+boys].add(t);
-            capacity[i+boys][t]=1;
-        }
-        int flow=maxflow(s,t);
-        out.println(flow);
-        for(int i =0;i<flow;i++){
-            StringBuilder sb=new StringBuilder();
-            int k=t;
-            for(int j=0;j<n;j++){
-                if(flo[j][k]==1){
-                    flo[j][k]=0;
-                    sb.insert(0,j-boys+1);
-                    k=j;
-                    break;
-                }
-            }
-            for(int j=0;j<n;j++){
-                if(flo[j][k]==1){
-                    flo[j][k]=0;
-                    sb.insert(0,j+1+" ");
-                    k=j;
-                    break;
-                }
-            }
-            out.println(sb);
-        }
-
-        out.close();
-    }
-    static boolean bfs(int s, int t, int[] parent) {
-        boolean[] visited = new boolean[n];
-        Queue<Integer> q = new LinkedList<>();
-        q.add(s);
-        parent[s] = -1;
-        visited[s] = true;
-        while (!q.isEmpty()) {
-            int cur = q.poll();
-            for (int n : adj[cur]) {
-                if (!visited[n] && capacity[cur][n] > 0) {
-                    parent[n] = cur;
-                    visited[n] = true;
-                    q.add(n);
-                    if (n == t)
-                        return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    static int maxflow(int s, int t) {
-        int[] pi = new int[n];
-        int maxflow = 0;
-        while (bfs(s, t, pi)) {
-            int flow = INF;
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                flow = Math.min(flow, capacity[p][cur]);
-            }
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                capacity[p][cur] -= flow;
-                capacity[cur][p] += flow;
-                flo[p][cur] += flow;
-                flo[cur][p] -= flow;
-            }
-
-            maxflow += flow;
-        }
-        return maxflow;
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public void close() throws IOException {
-            br.close();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Flujos/minCost-maxFlow/Dijkstra, Dijkstra.cpp b/Problemas/Grafos/Flujos/minCost-maxFlow/Dijkstra, Dijkstra.cpp
deleted file mode 100644
index d90c797..0000000
--- a/Problemas/Grafos/Flujos/minCost-maxFlow/Dijkstra, Dijkstra.cpp	
+++ /dev/null
@@ -1,90 +0,0 @@
-//https://vjudge.net/problem/UVA-10806
-#include <bits/stdc++.h>
-using namespace std;
-#define MAX 100007
-#define INF (1<<30)
-#define ll long long
-#define nmax 101
-typedef pair<int,int> pii;
-struct edge {
-    int from, to, flow, cost;
-    edge(int fr, int t, int fl,int c) {
-        from=fr;
-        to=t;
-        flow=fl;
-        cost=c;
-    }
-};
-vector<edge> Edges;
-vector<int> adj[nmax];
-int d[nmax],pi[nmax];
-void addEdge(int u, int v, int f, int c) {
-    adj[u].push_back(Edges.size());
-    Edges.push_back(edge(u,v,f,c));
-    adj[v].push_back(Edges.size());
-    Edges.push_back(edge(v,u,0,-c));
-}
-void shortest_path(int n, int s) {
-    bool state[nmax];
-    for(int i=0;i<n;i++)
-        d[i]=INF,pi[i]=-1,state[i]=0;
-    d[s]=0;
-    queue<int> q;
-    q.push(s);
-    while(!q.empty()) {
-        int u = q.front();
-        q.pop();
-        state[u]=0;
-        for(int i=0;i<adj[u].size();i++) {
-            int id=adj[u][i];
-            int v=Edges[id].to;
-            if(Edges[id].flow>0&&d[v]>d[u]+Edges[id].cost) {
-                pi[v]=id;
-                d[v]=d[u]+Edges[id].cost;
-                if(!state[v]) state[v]=1,q.push(v);
-            }
-        }
-    }
-}
-int min_cost_flow(int n,int k, int s, int t) {
-    int flow=0,ret=0;
-    while(flow<k) {
-        shortest_path(n,s);
-        if(d[t]==INF)return -1;
-        int f=k-flow,cur=t;
-        while(cur!=s) {
-            f=min(f,Edges[pi[cur]].flow);
-            cur=Edges[pi[cur]].from;
-        }
-        flow+=f;
-        ret+=f*d[t];
-        cur=t;
-        while(cur!=s) {
-            Edges[pi[cur]].flow-=f;
-            Edges[pi[cur]^1].flow+=f;
-            cur=Edges[pi[cur]].from;
-        }
-    }
-    return flow<k?-1:ret;
-}
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    int n;
-    while(cin>>n&&n) {
-        Edges.clear();
-        for(int i=0;i<n;i++)adj[i].clear();
-        int m;
-        cin>>m;
-        for(int i=0;i<m;i++) {
-            int u, v,w;
-            cin>>u>>v>>w;
-            addEdge(--u, --v, 1,w);
-            addEdge(v, u, 1,w);
-        }
-        int ans=min_cost_flow(n, 2, 0, n-1);
-        string sout=ans==-1?"Back to jail":to_string(ans);
-        cout<<sout<< endl;
-    }
-}
diff --git a/Problemas/Grafos/Flujos/minCost-maxFlow/Grid Puzzle II.cpp b/Problemas/Grafos/Flujos/minCost-maxFlow/Grid Puzzle II.cpp
deleted file mode 100644
index 13cb231..0000000
--- a/Problemas/Grafos/Flujos/minCost-maxFlow/Grid Puzzle II.cpp	
+++ /dev/null
@@ -1,136 +0,0 @@
-//vjudge.net/problem/CSES-2131
-#include <bits/stdc++.h>
-using namespace std;
-#define MAX 100007
-#define INF (1<<30)
-#define ll long long
-#define nmax 200
-typedef pair<int, int> pii;
-
-struct edge {
-    int from, to, flow, cost;
-
-    edge(int fr, int t, int fl, int c) {
-        from = fr;
-        to = t;
-        flow = fl;
-        cost = c;
-    }
-};
-
-vector<edge> Edges;
-vector<int> adj[nmax];
-int d[nmax], pi[nmax];
-
-void addEdge(int u, int v, int f, int c) {
-    adj[u].push_back(Edges.size());
-    Edges.push_back(edge(u, v, f, c));
-    adj[v].push_back(Edges.size());
-    Edges.push_back(edge(v, u, 0, -c));
-}
-
-void shortest_path(int n, int s) {
-    bool state[nmax];
-    for (int i = 0; i < n; i++)
-        d[i] = INF, pi[i] = -1, state[i] = 0;
-    d[s] = 0;
-    queue<int> q;
-    q.push(s);
-    while (!q.empty()) {
-        int u = q.front();
-        q.pop();
-        state[u] = 0;
-        for (int i = 0; i < adj[u].size(); i++) {
-            int id = adj[u][i];
-            int v = Edges[id].to;
-            if (Edges[id].flow > 0 && d[v] > d[u] + Edges[id].cost) {
-                pi[v] = id;
-                d[v] = d[u] + Edges[id].cost;
-                if (!state[v]) state[v] = 1, q.push(v);
-            }
-        }
-    }
-}
-
-int min_cost_flow(int n, int k, int s, int t) {
-    int flow = 0, ret = 0;
-    while (flow < k) {
-        shortest_path(n, s);
-        if (d[t] == INF)return -1;
-        int f = k - flow, cur = t;
-        while (cur != s) {
-            f = min(f, Edges[pi[cur]].flow);
-            cur = Edges[pi[cur]].from;
-        }
-        flow += f;
-        ret += f * d[t];
-        cur = t;
-        while (cur != s) {
-            Edges[pi[cur]].flow -= f;
-            Edges[pi[cur] ^ 1].flow += f;
-            cur = Edges[pi[cur]].from;
-        }
-    }
-    return flow < k ? -1 : ret;
-}
-
-int weigth[51][51];
-int rows[51], cols[51];
-
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    int n;
-    cin >> n;
-    int m = (n << 1) + 2;
-    int s = m - 2, t = m - 1;
-    int row = 0, col = 0;
-    for (int i = 0; i < n; i++) {
-        int a;
-        cin >> a;
-        row += a;
-        rows[i] = a;
-    }
-    for (int i = 0; i < n; i++) {
-        int a;
-        cin >> a;
-        col += a;
-        cols[i] = a;
-    }
-    if (col != row) {
-        cout << "-1" << endl;
-        return 0;
-    }
-    for (int i = 0; i < n; i++)
-        for (int j = 0; j < n; j++)
-            cin >> weigth[i][j];
-    for (int i = 0; i < n; i++)
-        if(rows[i])
-            addEdge(s, i, rows[i], 0);
-    for (int i = 0; i < n; i++)
-        if(cols[i])
-            addEdge(i + n, t, cols[i], 0);
-    for (int i = 0; i < n; i++)
-        for (int j = 0; j < n; j++)
-            addEdge(i, j + n, 1, -weigth[i][j]);
-    int ans = min_cost_flow(m, col, s, t);
-    if (col != 0 && ans == -1) {
-        cout << "-1" << endl;
-        return 0;
-    }
-    vector<vector<bool> > state(n, vector<bool>(n, false));
-    for (int i = 0; i < n; i++)
-        for (auto j: adj[i]) {
-            if (j & 1)continue;
-            if (Edges[j].flow)
-                state[i][Edges[j].to - n] = true;
-        }
-    cout << -ans << endl;
-    for (int i = 0; i < n; i++) {
-        for (int j = 0; j < n; j++)
-            cout << (state[i][j] ? "." : "X");
-        cout << "\n";
-    }
-    return 0;
-}
diff --git a/Problemas/Grafos/Flujos/minCost-maxFlow/Task Assignment.cpp b/Problemas/Grafos/Flujos/minCost-maxFlow/Task Assignment.cpp
deleted file mode 100644
index aaa9575..0000000
--- a/Problemas/Grafos/Flujos/minCost-maxFlow/Task Assignment.cpp	
+++ /dev/null
@@ -1,97 +0,0 @@
-//vjudge.net/problem/CSES-2129
-#include <bits/stdc++.h>
-using namespace std;
-#define INF (1<<30)
-#define ll long long
-#define nmax 40500
-struct edge {
-    int from, to, flow, cost;
-    edge(int fr, int t, int fl,int c) {
-        from=fr;
-        to=t;
-        flow=fl;
-        cost=c;
-    }
-};
-vector<edge> Edges;
-vector<int> adj[nmax];
-int d[nmax],pi[nmax];
-void addEdge(int u, int v, int f, int c) {
-    adj[u].push_back(Edges.size());
-    Edges.push_back(edge(u,v,f,c));
-    adj[v].push_back(Edges.size());
-    Edges.push_back(edge(v,u,0,-c));
-}
-void shortest_path(int n, int s) {
-    bool state[nmax];
-    for(int i=0;i<n;i++)
-        d[i]=INF,pi[i]=-1,state[i]=0;
-    d[s]=0;
-    queue<int> q;
-    q.push(s);
-    while(!q.empty()) {
-        int u = q.front();
-        q.pop();
-        state[u]=0;
-        for(int i=0;i<adj[u].size();i++) {
-            int id=adj[u][i];
-            int v=Edges[id].to;
-            if(Edges[id].flow>0&&d[v]>d[u]+Edges[id].cost) {
-                pi[v]=id;
-                d[v]=d[u]+Edges[id].cost;
-                if(!state[v]) state[v]=1,q.push(v);
-            }
-        }
-    }
-}
-int min_cost_flow(int n,int k, int s, int t) {
-    int flow=0,ret=0;
-    while(flow<k) {
-        shortest_path(n,s);
-        if(d[t]==INF)return -1;
-        int f=k-flow,cur=t;
-        while(cur!=s) {
-            f=min(f,Edges[pi[cur]].flow);
-            cur=Edges[pi[cur]].from;
-        }
-        flow+=f;
-        ret+=f*d[t];
-        cur=t;
-        while(cur!=s) {
-            Edges[pi[cur]].flow-=f;
-            Edges[pi[cur]^1].flow+=f;
-            cur=Edges[pi[cur]].from;
-        }
-    }
-    return flow<k?-1:ret;
-}
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    int n;
-    cin>>n;
-    int m=(n<<1)+2;
-    int s=m-2,t=m-1;
-    for(int i=0;i<n;i++) {
-        addEdge(s,i,1,0);
-        addEdge(i+n,t,1,0);
-        for (int j = 0; j < n; j++) {
-            int c;
-            cin>>c;
-            addEdge(i, j + n, 1, c);
-        }
-    }
-    int ans=min_cost_flow(m,n,s,t);
-    cout<<ans<< "\n";
-    for (int i = 0; i < n; i++) {
-        for(int id:adj[i]){
-            int v=Edges[id].to;
-            if(v==s)
-                continue;
-            if(Edges[id].flow==0)
-                cout<<(i+1)<<" "<<(v-n+1)<<"\n";
-        }
-    }
-
-}
diff --git a/Problemas/Grafos/Grid/10KindsOfPeople.java b/Problemas/Grafos/Grid/10KindsOfPeople.java
deleted file mode 100644
index b9ffb52..0000000
--- a/Problemas/Grafos/Grid/10KindsOfPeople.java
+++ /dev/null
@@ -1,65 +0,0 @@
-// https://open.kattis.com/problems/10kindsofpeople
-import java.util.*;
-class Main{
-    public static void main(String[] args){
-        Scanner tec=new Scanner(System.in);
-        int r= tec.nextInt();
-        int c= tec.nextInt();
-        char[][] mapa=new char[r][c];
-        int [][] grupos=new int[r][c];
-        tec.nextLine();
-        for (int i =0;i<r;i++){
-            String a= tec.nextLine();
-            for (int j = 0; j < c; j++) {
-                mapa[i][j]=a.charAt(j);
-            }
-        }
-        int n= tec.nextInt();
-        for (int i = 0; i < n; i++) {
-            int x1= tec.nextInt()-1;
-            int y1= tec.nextInt()-1;
-            int x2= tec.nextInt()-1;
-            int y2= tec.nextInt()-1;
-            System.out.println(alcanza(x1,y1,x2,y2,i+1,mapa,grupos));
-        }
-    }
-
-    static String alcanza(int x1, int y1, int x2, int y2, int g, char[][] mapas,int[][] grupos){
-        LinkedList<int[]> actual=new LinkedList<>();
-        actual.add(new int[]{x1,y1});
-        char numero=mapas[x1][y1];
-        if(grupos[x1][y1]==0){
-            while(actual.size()>0){
-                int[] par=actual.remove();
-                int r=par[0];
-                int c=par[1];
-                grupos[r][c]=g;
-                if(r>0&&numero==mapas[r-1][c]&&grupos[r-1][c]==0){
-                    grupos[r-1][c]=g;
-                    actual.add(new int[]{r-1,c});
-                }
-                if(c>0&&numero==mapas[r][c-1]&&grupos[r][c-1]==0){
-                    grupos[r][c-1]=g;
-                    actual.add(new int[]{r,c-1});
-                }
-                if (r<mapas.length-1&&numero==mapas[r+1][c]&&grupos[r+1][c]==0){
-                    grupos[r+1][c]=g;
-                    actual.add(new int[]{r+1,c});
-                }
-                if(c<mapas[0].length-1&&numero==mapas[r][c+1]&&grupos[r][c+1]==0){
-                    grupos[r][c+1]=g;
-                    actual.add(new int[]{r,c+1});
-                }
-            }
-        }
-        if(grupos[x1][y1]==grupos[x2][y2]) {
-            if (mapas[x1][y1] == '0')
-                return "binary";
-            else
-                return "decimal";
-        }
-        else
-            return "neither";
-    }
-
-}
diff --git a/Problemas/Grafos/Grid/Coast Length.java b/Problemas/Grafos/Grid/Coast Length.java
deleted file mode 100644
index 8d11e66..0000000
--- a/Problemas/Grafos/Grid/Coast Length.java	
+++ /dev/null
@@ -1,122 +0,0 @@
-//https://open.kattis.com/problems/coast
-import java.io.*;
-import java.util.*;
-
-class Main{
-    static int[][] map;
-    static boolean[][] sea;
-    static int n,m;
-    public static void main(String[] args) throws Exception{
-        Scanner sc=new Scanner();
-        n=sc.nextInt();
-        m=sc.nextInt();
-        map=new int[n][m];
-        sea=new boolean[n][m];
-        for (int i = 0; i <n ; i++) {
-            for (int j = 0; j < m; j++)
-                map[i][j]=sc.nextChar()-'0';
-            sc.nextLine();
-        }
-        for (int i = 0; i < m; i++)
-            if(!sea[0][i]&&map[0][i]==0)
-                bfsSea(0,i);
-        for (int i = 0; i < m; i++)
-            if(!sea[n-1][i]&&map[n-1][i]==0)
-                bfsSea(n-1,i);
-        for (int i = 0; i < n; i++)
-            if(!sea[i][0]&&map[i][0]==0)
-                bfsSea(i,0);
-        for (int i = 0; i < n; i++)
-            if(!sea[i][m-1]&&map[i][m-1]==0)
-                bfsSea(i,m-1);
-        int c=0;
-        for (int i = 0; i < n; i++) {
-            for (int j = 0; j < m; j++) {
-                if(map[i][j]==1){
-                    if(i+1<n&&sea[i+1][j])
-                        c++;
-                    if(j+1<m&&sea[i][j+1])
-                        c++;
-                    if(i-1>=0&&sea[i-1][j])
-                        c++;
-                    if(j-1>=0&&sea[i][j-1])
-                        c++;
-                    if(i+1==n)
-                        c++;
-                    if(j+1==m)
-                        c++;
-                    if(i-1<0)
-                        c++;
-                    if(j-1<0)
-                        c++;
-                }
-            }
-        }
-
-        System.out.println(c);
-    }
-    static void bfsSea(int a, int b){
-        int[] s={a,b};
-        sea[a][b]=true;
-        Queue<int[]> q=new LinkedList<>();
-        q.add(s);
-        while (!q.isEmpty()){
-            int[] u=q.poll();
-            int i=u[0];
-            int j=u[1];
-            if(i+1<n&&map[i+1][j]==0&&!sea[i+1][j]){
-                sea[i+1][j]=true;
-                q.add(new int[]{i+1,j});
-            }
-            if(j+1<m&&map[i][j+1]==0&&!sea[i][j+1]){
-                sea[i][j+1]=true;
-                q.add(new int[]{i,j+1});
-            }
-            if(i-1>=0&&map[i-1][j]==0&&!sea[i-1][j]){
-                sea[i-1][j]=true;
-                q.add(new int[]{i-1,j});
-            }
-            if(j-1>=0&&map[i][j-1]==0&&!sea[i][j-1]){
-                sea[i][j-1]=true;
-                q.add(new int[]{i,j-1});
-            }
-        }
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Grid/CoastLenghtIan.java b/Problemas/Grafos/Grid/CoastLenghtIan.java
deleted file mode 100644
index f606c54..0000000
--- a/Problemas/Grafos/Grid/CoastLenghtIan.java
+++ /dev/null
@@ -1,123 +0,0 @@
-import java.util.*;
-import java.io.*;
-
-public class CoastLength {
-	static int[][] grid;
-	static int n;
-	static int m;
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		n = in.nextInt();
-		m = in.nextInt();
-		grid = new int[n + 2][m + 2];
-		for (int i = 1; i <= n; i++) {
-			String row = in.next();
-			int c = 0;
-			for (int j = 1; j <= m; j++) {
-				grid[i][j] = row.charAt(c) - '0';
-				c++;
-			}
-
-		}
-		System.out.println(bfs());
-
-	}
-
-	static int bfs() {
-		int ans = 0;
-		Queue<int[]> Q = new LinkedList<>();
-		Q.add(new int[] { 0, 0 });
-		grid[0][0] = -1;
-		while (!Q.isEmpty()) {
-			int[] cell = Q.poll();
-			int r = cell[0];
-			int c = cell[1];
-			if (r - 1 >= 0) {
-				if (grid[r - 1][c] == 0) {
-					grid[r - 1][c] = -1;
-					Q.add(new int[] { r - 1, c });
-				} else if (grid[r - 1][c] == 1)
-					ans++;
-			}
-			if (r + 1 <= n + 1) {
-				if (grid[r + 1][c] == 0) {
-					grid[r + 1][c] = -1;
-					Q.add(new int[] { r + 1, c });
-				} else if (grid[r + 1][c] == 1)
-					ans++;
-			}
-			if (c - 1 >= 0) {
-				if (grid[r][c - 1] == 0) {
-					grid[r][c - 1] = -1;
-					Q.add(new int[] { r, c - 1 });
-				} else if (grid[r][c - 1] == 1)
-					ans++;
-			}
-			if (c + 1 <= m + 1) {
-				if (grid[r][c + 1] == 0) {
-					grid[r][c + 1] = -1;
-					Q.add(new int[] { r, c + 1 });
-				} else if (grid[r][c + 1] == 1)
-					ans++;
-			}
-		}
-		return ans;
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-}
diff --git a/Problemas/Grafos/Grid/FloodFillLeetCode.java b/Problemas/Grafos/Grid/FloodFillLeetCode.java
deleted file mode 100644
index ae53dfe..0000000
--- a/Problemas/Grafos/Grid/FloodFillLeetCode.java
+++ /dev/null
@@ -1,46 +0,0 @@
-//https://leetcode.com/problems/flood-fill/description/
-import java.util.*;
-
-public class FloodFillLeetCode {
-
-	static int[][] bfs(int[][] grid, int sr, int sc, int color) {
-		if (grid[sr][sc] == color)
-			return grid;
-		Queue<int[]> Q = new LinkedList<>();
-		int n = grid.length;
-		int m = grid[0].length;
-		int pixel = grid[sr][sc];
-		boolean[][] visited = new boolean[n][m];
-		grid[sr][sc] = color;
-		visited[sr][sc] = true;
-		Q.add(new int[] { sr, sc });
-		while (!Q.isEmpty()) {
-			int[] cell = Q.poll();
-			int r = cell[0];
-			int c = cell[1];
-			if (r - 1 >= 0 && !visited[r - 1][c] && grid[r - 1][c] == pixel) {
-				visited[r - 1][c] = true;
-				grid[r - 1][c] = color;
-				Q.add(new int[] { r - 1, c });
-			}
-			if (r + 1 < n && !visited[r + 1][c] && grid[r + 1][c] == pixel) {
-				visited[r + 1][c] = true;
-				grid[r + 1][c] = color;
-				Q.add(new int[] { r + 1, c });
-			}
-			if (c - 1 >= 0 && !visited[r][c - 1] && grid[r][c - 1] == pixel) {
-				visited[r][c - 1] = true;
-				grid[r][c - 1] = color;
-				Q.add(new int[] { r, c - 1 });
-			}
-			if (c + 1 < m && !visited[r][c + 1] && grid[r][c + 1] == pixel) {
-				visited[r][c + 1] = true;
-				grid[r][c + 1] = color;
-				Q.add(new int[] { r, c + 1 });
-			}
-		}
-		return grid;
-
-	}
-
-}
diff --git a/Problemas/Grafos/Grid/Grid Kattis.java b/Problemas/Grafos/Grid/Grid Kattis.java
deleted file mode 100644
index dce21f5..0000000
--- a/Problemas/Grafos/Grid/Grid Kattis.java	
+++ /dev/null
@@ -1,90 +0,0 @@
-//https://open.kattis.com/problems/grid
-import java.io.*;
-import java.math.BigInteger;
-import java.util.*;
-
-class Main {
-
-    public static void main(String[] args) throws Exception {
-        Scanner sc = new Scanner();
-        int n=sc.nextInt(),m=sc.nextInt();
-        int[][] map=new int[n][m];
-        boolean[][] state=new boolean[n][m];
-        for (int i = 0; i < n; i++) {
-            String s=sc.next();
-            for (int j = 0; j < m; j++)
-                map[i][j]=s.charAt(j)-'0';
-
-        }
-        Edge s=new Edge(0,0,map[0][0],0);
-        Queue<Edge> q=new LinkedList<>();
-        q.add(s);
-        while (!q.isEmpty()){
-            Edge u=q.poll();
-            if(u.i==n-1 &&u.j==m-1) {
-                System.out.println(u.d);
-                return;
-            }
-            if(u.i-u.k>=0 && !state[u.i-u.k][u.j]){
-                state[u.i-u.k][u.j]=true;
-                q.add(new Edge(u.i-u.k,u.j,map[u.i-u.k][u.j],u.d+1));
-            }
-            if(u.j-u.k>=0 && !state[u.i][u.j-u.k]){
-                state[u.i][u.j-u.k]=true;
-                q.add(new Edge(u.i,u.j-u.k,map[u.i][u.j-u.k],u.d+1));
-            }
-            if(u.i+u.k<n && !state[u.i+u.k][u.j]){
-                state[u.i+u.k][u.j]=true;
-                q.add(new Edge(u.i+u.k,u.j,map[u.i+u.k][u.j],u.d+1));
-            }
-            if(u.j+u.k<m && !state[u.i][u.j+u.k]){
-                state[u.i][u.j+u.k]=true;
-                q.add(new Edge(u.i,u.j+u.k,map[u.i][u.j+u.k],u.d+1));
-            }
-        }
-        System.out.println(-1);
-    }
-    static class Edge{
-        int i,j,k,d;
-        public Edge(int a, int b,int c, int di){
-            i=a;
-            j=b;
-            k=c;
-            d=di;
-        }
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Grid/HidingPlaces.java b/Problemas/Grafos/Grid/HidingPlaces.java
deleted file mode 100644
index e37ab03..0000000
--- a/Problemas/Grafos/Grid/HidingPlaces.java
+++ /dev/null
@@ -1,152 +0,0 @@
-//https://open.kattis.com/problems/hidingplaces
-import java.io.*;
-import java.util.*;
-
-public class HidingPlaces {
-	public static void main(String[] args) throws IOException {
-		Input in = new Input(System.in);
-		BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
-		int t = in.nextInt();
-		HashMap<Character, Integer> cols = new HashMap<>();
-		char[] inv = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' };
-		cols.put('a', 0);
-		cols.put('b', 1);
-		cols.put('c', 2);
-		cols.put('d', 3);
-		cols.put('e', 4);
-		cols.put('f', 5);
-		cols.put('g', 6);
-		cols.put('h', 7);
-		while (t-- > 0) {
-			String a = in.next();
-			char[] s = a.toCharArray();
-			int i = 7 - (s[1] - '0' - 1);
-			int j = cols.get(s[0]);
-			int[][] matrix = bfs(i, j);
-			int max = -1;
-			for (int[] x : matrix)
-				for (int y : x)
-					max = Math.max(max, y);
-			out.write(max + " ");
-			for (int x = 0; x < 8; x++)
-				for (int y = 0; y < 8; y++)
-					if (matrix[x][y] == max)
-						out.write(inv[y] + "" + (8 - x) + " ");
-			out.write("\n");
-		}
-		out.flush();
-
-	}
-
-	static int[][] bfs(int sr, int sc) {
-		Queue<int[]> Q = new LinkedList<>();
-		int[][] d = new int[8][8];
-		boolean[][] visited = new boolean[8][8];
-		Q.add(new int[] { sr, sc });
-		d[sr][sc] = 0;
-		visited[sr][sc] = true;
-		while (!Q.isEmpty()) {
-			int[] e = Q.poll();
-			int r = e[0];
-			int c = e[1];
-			if (r - 2 >= 0 && c - 1 >= 0 && !visited[r - 2][c - 1]) {
-				visited[r - 2][c - 1] = true;
-				d[r - 2][c - 1] = d[r][c] + 1;
-				Q.add(new int[] { r - 2, c - 1 });
-			}
-			if (r + 2 < 8 && c - 1 >= 0 && !visited[r + 2][c - 1]) {
-				visited[r + 2][c - 1] = true;
-				d[r + 2][c - 1] = d[r][c] + 1;
-				Q.add(new int[] { r + 2, c - 1 });
-			}
-			if (r - 2 >= 0 && c + 1 < 8 && !visited[r - 2][c + 1]) {
-				visited[r - 2][c + 1] = true;
-				d[r - 2][c + 1] = d[r][c] + 1;
-				Q.add(new int[] { r - 2, c + 1 });
-			}
-			if (r + 2 < 8 && c + 1 < 8 && !visited[r + 2][c + 1]) {
-				visited[r + 2][c + 1] = true;
-				d[r + 2][c + 1] = d[r][c] + 1;
-				Q.add(new int[] { r + 2, c + 1 });
-			}
-			if (r + 1 < 8 && c - 2 >= 0 && !visited[r + 1][c - 2]) {
-				visited[r + 1][c - 2] = true;
-				d[r + 1][c - 2] = d[r][c] + 1;
-				Q.add(new int[] { r + 1, c - 2 });
-			}
-			if (r + 1 < 8 && c + 2 < 8 && !visited[r + 1][c + 2]) {
-				visited[r + 1][c + 2] = true;
-				d[r + 1][c + 2] = d[r][c] + 1;
-				Q.add(new int[] { r + 1, c + 2 });
-			}
-			if (r - 1 >= 0 && c - 2 >= 0 && !visited[r - 1][c - 2]) {
-				visited[r - 1][c - 2] = true;
-				d[r - 1][c - 2] = d[r][c] + 1;
-				Q.add(new int[] { r - 1, c - 2 });
-			}
-			if (r - 1 >= 0 && c + 2 < 8 && !visited[r - 1][c + 2]) {
-				visited[r - 1][c + 2] = true;
-				d[r - 1][c + 2] = d[r][c] + 1;
-				Q.add(new int[] { r - 1, c + 2 });
-			}
-		}
-		return d;
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-
-}
diff --git a/Problemas/Grafos/Grid/HowManyIslands.java b/Problemas/Grafos/Grid/HowManyIslands.java
deleted file mode 100644
index c780677..0000000
--- a/Problemas/Grafos/Grid/HowManyIslands.java
+++ /dev/null
@@ -1,84 +0,0 @@
-// https://vjudge.net/problem/SPOJ-COUNTISL
-import java.io.*;
-import java.util.*;
-public class Main{
-    static boolean[][] state;
-    static char[][] map;
-    static int n;
-    static int m;
-
-    public static void main(String[] args) throws IOException {
-        Scanner sc=new Scanner();
-        int t=sc.nextInt();
-        for (int times = 0; times < t; times++) {
-            n=sc.nextInt();
-            m=sc.nextInt();
-            state=new boolean[n][m];
-            map=new char[n][m];
-            for (int i = 0; i < n; i++)
-                map[i]=sc.next().toCharArray();
-            int c=0;
-            for (int i = 0; i < n; i++)
-                for (int j = 0; j <m ; j++)
-                    if(!state[i][j]&&map[i][j]=='#'){
-                        c++;
-                        bfs(i,j);
-                    }
-            System.out.println(c);
-
-        }
-    }
-    static void bfs(int a, int b){
-        int[] s={a,b};
-        Queue<int[]> q=new LinkedList<>();
-        q.add(s);
-        int[][] moves={{1,0},{0,1},{-1,0},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};
-        while (!q.isEmpty()){
-            int[] act=q.poll();
-            int i=act[0];
-            int j=act[1];
-            for (int[] mov:moves){
-                int ni=i+mov[0];
-                int nj=j+mov[1];
-                if(ni>=0&&ni<n&&nj>=0&&nj<m&&!state[ni][nj]&&map[ni][nj]=='#'){
-                    state[ni][nj]=true;
-                    q.add(new int[]{ni,nj});
-                }
-            }
-        }
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-        char nextChar(){
-            return next().charAt(0);
-        }
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-    }
-
-
-
-}
diff --git a/Problemas/Grafos/Grid/King'sPath.java b/Problemas/Grafos/Grid/King'sPath.java
deleted file mode 100644
index 536c889..0000000
--- a/Problemas/Grafos/Grid/King'sPath.java
+++ /dev/null
@@ -1,143 +0,0 @@
-//https://codeforces.com/problemset/problem/242/C
-import java.util.*;
-import java.io.*;
-
-public class KingsPath {
-
-	static HashMap<Integer, HashSet<Intervalo>> allowed;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st = new StringTokenizer(in.readLine());
-		Pair s = new Pair(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));
-		Pair t = new Pair(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));
-		int n = Integer.parseInt(in.readLine());
-		allowed = new HashMap<>();
-		for (int i = 0; i < n; i++) {
-			st = new StringTokenizer(in.readLine());
-			int row = Integer.parseInt(st.nextToken());
-			int l = Integer.parseInt(st.nextToken());
-			int r = Integer.parseInt(st.nextToken());
-			if (!allowed.containsKey(row))
-				allowed.put(row, new HashSet<>());
-			allowed.get(row).add(new Intervalo(l, r));
-		}
-		System.out.println(bfs(s, t));
-
-	}
-
-	static int bfs(Pair s, Pair t) {
-		HashMap<Pair, Integer> d = new HashMap<>();
-		HashMap<Pair, Boolean> visited = new HashMap<>();
-		Queue<Pair> Q = new LinkedList<>();
-		Q.add(s);
-		d.put(s, 0);
-		visited.put(s, true);
-		while (!Q.isEmpty()) {
-			Pair u = Q.poll();
-			int r = u.x;
-			int c = u.y;
-			if (allowed.containsKey(r - 1)) {
-				Pair v1 = new Pair(r - 1, c);
-				Pair v2 = new Pair(r - 1, c - 1);
-				Pair v3 = new Pair(r - 1, c + 1);
-				for (Intervalo i : allowed.get(r - 1)) {
-					if (isin(i.l, i.r, c) && visited.get(v1) == null) {
-						visited.put(v1, true);
-						d.put(v1, d.get(u) + 1);
-						Q.add(v1);
-					}
-					if (isin(i.l, i.r, c - 1) && visited.get(v2) == null) {
-						visited.put(v2, true);
-						d.put(v2, d.get(u) + 1);
-						Q.add(v2);
-					}
-					if (isin(i.l, i.r, c + 1) && visited.get(v3) == null) {
-						visited.put(v3, true);
-						d.put(v3, d.get(u) + 1);
-						Q.add(v3);
-					}
-				}
-			}
-			if (allowed.containsKey(r + 1)) {
-				Pair v1 = new Pair(r + 1, c);
-				Pair v2 = new Pair(r + 1, c - 1);
-				Pair v3 = new Pair(r + 1, c + 1);
-				for (Intervalo i : allowed.get(r + 1)) {
-					if (isin(i.l, i.r, c) && visited.get(v1) == null) {
-						visited.put(v1, true);
-						d.put(v1, d.get(u) + 1);
-						Q.add(v1);
-					}
-					if (isin(i.l, i.r, c - 1) && visited.get(v2) == null) {
-						visited.put(v2, true);
-						d.put(v2, d.get(u) + 1);
-						Q.add(v2);
-					}
-					if (isin(i.l, i.r, c + 1) && visited.get(v3) == null) {
-						visited.put(v3, true);
-						d.put(v3, d.get(u) + 1);
-						Q.add(v3);
-					}
-				}
-			}
-			Pair v1 = new Pair(r, c + 1);
-			Pair v2 = new Pair(r, c - 1);
-			for (Intervalo i : allowed.get(r)) {
-				if (isin(i.l, i.r, c + 1) && visited.get(v1) == null) {
-					visited.put(v1, true);
-					d.put(v1, d.get(u) + 1);
-					Q.add(v1);
-				}
-				if (isin(i.l, i.r, c - 1) && visited.get(v2) == null) {
-					visited.put(v2, true);
-					d.put(v2, d.get(u) + 1);
-					Q.add(v2);
-				}
-			}
-		}
-		return d.get(t) != null ? d.get(t) : -1;
-
-	}
-
-	static boolean isin(int l, int r, int x) {
-		return l <= x && x <= r;
-	}
-
-	static class Intervalo {
-		int l, r;
-
-		Intervalo(int l, int r) {
-			this.l = l;
-			this.r = r;
-		}
-
-		public int hashCode() {
-			return Objects.hash(l, r);
-		}
-
-		public boolean equals(Object o) {
-			Intervalo op = (Intervalo) o;
-			return r == op.r && l == op.l;
-		}
-	}
-
-	static class Pair {
-		int x, y;
-
-		Pair(int x, int y) {
-			this.x = x;
-			this.y = y;
-		}
-
-		public int hashCode() {
-			return Objects.hash(x, y);
-		}
-
-		public boolean equals(Object o) {
-			Pair op = (Pair) o;
-			return x == op.x && y == op.y;
-		}
-	}
-
-}
diff --git a/Problemas/Grafos/Grid/KnightMoves.java b/Problemas/Grafos/Grid/KnightMoves.java
deleted file mode 100644
index 4bdda54..0000000
--- a/Problemas/Grafos/Grid/KnightMoves.java
+++ /dev/null
@@ -1,145 +0,0 @@
-//https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=380
-import java.io.*;
-import java.util.*;
-
-public class KnighMoves {
-	static HashMap<Character, Integer> rows;
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		rows = new HashMap<>();
-		rows.put('a', 0);
-		rows.put('b', 1);
-		rows.put('c', 2);
-		rows.put('d', 3);
-		rows.put('e', 4);
-		rows.put('f', 5);
-		rows.put('g', 6);
-		rows.put('h', 7);
-		while (in.hasNext()) {
-			String a = in.next();
-			String b = in.next();
-			char[] s = a.toCharArray();
-			char[] t = b.toCharArray();
-			int i = rows.get(s[0]);
-			int j = s[1] - '0' - 1;
-			int k = rows.get(t[0]);
-			int l = t[1] - '0' - 1;
-			System.out.println("To get from " + a + " to " + b + " takes " + bfs(i, j)[k][l] + " knight moves.");
-
-		}
-
-	}
-
-	static int[][] bfs(int sr, int sc) {
-		Queue<int[]> Q = new LinkedList<>();
-		int[][] d = new int[8][8];
-		boolean[][] visited = new boolean[8][8];
-		Q.add(new int[] { sr, sc });
-		d[sr][sc] = 0;
-		visited[sr][sc] = true;
-		while (!Q.isEmpty()) {
-			int[] e = Q.poll();
-			int r = e[0];
-			int c = e[1];
-			if (r - 2 >= 0 && c - 1 >= 0 && !visited[r - 2][c - 1]) {
-				visited[r - 2][c - 1] = true;
-				d[r - 2][c - 1] = d[r][c] + 1;
-				Q.add(new int[] { r - 2, c - 1 });
-			}
-			if (r + 2 < 8 && c - 1 >= 0 && !visited[r + 2][c - 1]) {
-				visited[r + 2][c - 1] = true;
-				d[r + 2][c - 1] = d[r][c] + 1;
-				Q.add(new int[] { r + 2, c - 1 });
-			}
-			if (r - 2 >= 0 && c + 1 < 8 && !visited[r - 2][c + 1]) {
-				visited[r - 2][c + 1] = true;
-				d[r - 2][c + 1] = d[r][c] + 1;
-				Q.add(new int[] { r - 2, c + 1 });
-			}
-			if (r + 2 < 8 && c + 1 < 8 && !visited[r + 2][c + 1]) {
-				visited[r + 2][c + 1] = true;
-				d[r + 2][c + 1] = d[r][c] + 1;
-				Q.add(new int[] { r + 2, c + 1 });
-			}
-			if (r + 1 < 8 && c - 2 >= 0 && !visited[r + 1][c - 2]) {
-				visited[r + 1][c - 2] = true;
-				d[r + 1][c - 2] = d[r][c] + 1;
-				Q.add(new int[] { r + 1, c - 2 });
-			}
-			if (r + 1 < 8 && c + 2 < 8 && !visited[r + 1][c + 2]) {
-				visited[r + 1][c + 2] = true;
-				d[r + 1][c + 2] = d[r][c] + 1;
-				Q.add(new int[] { r + 1, c + 2 });
-			}
-			if (r - 1 >= 0 && c - 2 >= 0 && !visited[r - 1][c - 2]) {
-				visited[r - 1][c - 2] = true;
-				d[r - 1][c - 2] = d[r][c] + 1;
-				Q.add(new int[] { r - 1, c - 2 });
-			}
-			if (r - 1 >= 0 && c + 2 < 8 && !visited[r - 1][c + 2]) {
-				visited[r - 1][c + 2] = true;
-				d[r - 1][c + 2] = d[r][c] + 1;
-				Q.add(new int[] { r - 1, c + 2 });
-			}
-		}
-		return d;
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-
-}
diff --git a/Problemas/Grafos/Grid/KnightsInFEN.java b/Problemas/Grafos/Grid/KnightsInFEN.java
deleted file mode 100644
index dbb4e07..0000000
--- a/Problemas/Grafos/Grid/KnightsInFEN.java
+++ /dev/null
@@ -1,157 +0,0 @@
-//https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1363
-import java.util.*;
-import java.io.*;
-
-public class KnightsInFEN {
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		PrintWriter out = new PrintWriter(System.out);
-		int n = Integer.parseInt(in.readLine());
-		HashMap<Grid, Integer> d = bfs(new Grid(new char[][] { { '1', '1', '1', '1', '1' }, { '0', '1', '1', '1', '1' },
-				{ '0', '0', ' ', '1', '1' }, { '0', '0', '0', '0', '1' }, { '0', '0', '0', '0', '0' } }));
-		for (int i = 0; i < n; i++) {
-			char[][] grid = new char[5][5];
-			for (int j = 0; j < 5; j++)
-				grid[j] = in.readLine().toCharArray();
-			Grid t = new Grid(grid);
-			if (!d.containsKey(t) || d.get(t) > 10)
-				out.println("Unsolvable in less than 11 move(s).");
-			else
-				out.println("Solvable in " + d.get(t) + " move(s).");
-		}
-		out.flush();
-
-	}
-
-	static HashMap<Grid, Integer> bfs(Grid s) {
-		Queue<Grid> Q = new LinkedList<>();
-		HashMap<Grid, Boolean> visited = new HashMap<>();
-		HashMap<Grid, Integer> d = new HashMap<>();
-		d.put(s, 0);
-		visited.put(s, true);
-		Q.add(s);
-		while (!Q.isEmpty()) {
-			Grid u = Q.poll();
-			if (d.get(u) > 10)
-				continue;
-			for (Grid v : getVecinos(u))
-				if (visited.get(v) == null) {
-					visited.put(v, true);
-					d.put(v, d.get(u) + 1);
-					Q.add(v);
-				}
-		}
-		return d;
-	}
-
-	static ArrayList<Grid> getVecinos(Grid u) {
-		ArrayList<Grid> ans = new ArrayList<>();
-		int[] hueco = findHueco(u);
-		int i = hueco[0];
-		int j = hueco[1];
-		if (i - 2 >= 0 && j + 1 < 5) {
-			char knight = u.grid[i - 2][j + 1];
-			Grid v = copy(u);
-			v.grid[i][j] = knight;
-			v.grid[i - 2][j + 1] = ' ';
-			ans.add(v);
-		}
-		if (i - 2 >= 0 && j - 1 >= 0) {
-			char knight = u.grid[i - 2][j - 1];
-			Grid v = copy(u);
-			v.grid[i][j] = knight;
-			v.grid[i - 2][j - 1] = ' ';
-			ans.add(v);
-		}
-		if (i - 1 >= 0 && j - 2 >= 0) {
-			char knight = u.grid[i - 1][j - 2];
-			Grid v = copy(u);
-			v.grid[i][j] = knight;
-			v.grid[i - 1][j - 2] = ' ';
-			ans.add(v);
-		}
-		if (i - 1 >= 0 && j + 2 < 5) {
-			char knight = u.grid[i - 1][j + 2];
-			Grid v = copy(u);
-			v.grid[i][j] = knight;
-			v.grid[i - 1][j + 2] = ' ';
-			ans.add(v);
-		}
-		if (i + 2 < 5 && j + 1 < 5) {
-			char knight = u.grid[i + 2][j + 1];
-			Grid v = copy(u);
-			v.grid[i][j] = knight;
-			v.grid[i + 2][j + 1] = ' ';
-			ans.add(v);
-		}
-		if (i + 2 < 5 && j - 1 >= 0) {
-			char knight = u.grid[i + 2][j - 1];
-			Grid v = copy(u);
-			v.grid[i][j] = knight;
-			v.grid[i + 2][j - 1] = ' ';
-			ans.add(v);
-		}
-		if (i + 1 < 5 && j + 2 < 5) {
-			char knight = u.grid[i + 1][j + 2];
-			Grid v = copy(u);
-			v.grid[i][j] = knight;
-			v.grid[i + 1][j + 2] = ' ';
-			ans.add(v);
-		}
-		if (i + 1 < 5 && j - 2 >= 0) {
-			char knight = u.grid[i + 1][j - 2];
-			Grid v = copy(u);
-			v.grid[i][j] = knight;
-			v.grid[i + 1][j - 2] = ' ';
-			ans.add(v);
-		}
-		return ans;
-
-	}
-
-	static Grid copy(Grid a) {
-		Grid b = new Grid(new char[5][5]);
-		for (int i = 0; i < 5; i++)
-			b.grid[i] = a.grid[i].clone();
-		return b;
-	}
-
-	static int[] findHueco(Grid u) {
-		for (int i = 0; i < 5; i++)
-			for (int j = 0; j < 5; j++)
-				if (u.grid[i][j] == ' ')
-					return new int[] { i, j };
-		return new int[] {};
-	}
-
-	static class Grid {
-		char[][] grid;
-
-		Grid(char[][] g) {
-			this.grid = g;
-		}
-
-		public int hashCode() {
-			int ans = 1;
-			for (int i = 0; i < 5; i++)
-				ans = 499 * ans + Arrays.hashCode(grid[i]);
-			return ans;
-		}
-
-		public boolean equals(Object o) {
-			Grid op = (Grid) o;
-			for (int i = 0; i < 5; i++)
-				if (!Arrays.equals(grid[i], op.grid[i]))
-					return false;
-			return true;
-		}
-
-		public String toString() {
-			StringBuffer res = new StringBuffer();
-			for (char[] i : grid)
-				res.append(Arrays.toString(i) + "\n");
-			return new String(res);
-		}
-	}
-}
diff --git a/Problemas/Grafos/Grid/Labyrinth.java b/Problemas/Grafos/Grid/Labyrinth.java
deleted file mode 100644
index b6120c7..0000000
--- a/Problemas/Grafos/Grid/Labyrinth.java
+++ /dev/null
@@ -1,157 +0,0 @@
-//https://vjudge.net/problem/UVA-1193
-import java.util.*;
-import java.io.*;
-
-public class Main {
-    static int n;
-    static int m;
-    static boolean[][] state;
-    static int[][] d;
-    static char[][] map;
-    public static void main(String[] args) throws IOException {
-        Scanner sc = new Scanner();
-        n = sc.nextInt();
-        m = sc.nextInt();
-        map = new char[n][m];
-        int[] ini=new int[2];
-        int[] fin=new int[2];
-        for (int i = 0; i < n; i++) {
-            for (int j = 0; j < m; j++) {
-                map[i][j] = sc.nextChar();
-                if(map[i][j]=='A')
-                    ini=new int[]{i,j};
-                if(map[i][j]=='B')
-                    fin=new int[]{i,j};
-            }
-            sc.nextLine();
-        }
-        state=new boolean[n][m];
-        char[][]ans=bfs(ini[0],ini[1]);
-        if(!state[fin[0]][fin[1]])
-            System.out.println("NO");
-        else{
-            int i=fin[0];
-            int j=fin[1];
-            int index=d[i][j];
-            char[] r=new char[index];
-            index--;
-            while (index>=0){
-                char c=ans[i][j];
-                r[index]=c;
-                index--;
-                if(c=='U')
-                    i++;
-                else if(c=='D')
-                    i--;
-                else if(c=='R')
-                    j--;
-                else
-                    j++;
-            }
-            System.out.println("YES");
-            System.out.println(r.length);
-            System.out.println(r);
-        }
-
-    }
-    static char[][] bfs(int a, int b){
-        int[] s={a,b};
-        char[][] pi=new char[n][m];
-        d=new int[n][m];
-        pi[a][b]='+';
-        Queue<int[]> q=new LinkedList<>();
-        q.add(s);
-        while (!q.isEmpty()){
-            int[] u=q.poll();
-            int i=u[0];
-            int j=u[1];
-            if(i+1<n&&!state[i+1][j]&&map[i+1][j]!='#'){
-                state[i+1][j]=true;
-                pi[i+1][j]='D';
-                d[i+1][j]=d[i][j]+1;
-                q.add(new int[]{i+1,j});
-            }
-            if(j+1<m&&!state[i][j+1]&&map[i][j+1]!='#'){
-                state[i][j+1]=true;
-                pi[i][j+1]='R';
-                d[i][j+1]=d[i][j]+1;
-                q.add(new int[]{i,j+1});
-            }
-            if(i-1>=0&&!state[i-1][j]&&map[i-1][j]!='#'){
-                state[i-1][j]=true;
-                pi[i-1][j]='U';
-                d[i-1][j]=d[i][j]+1;
-                q.add(new int[]{i-1,j});
-            }
-            if(j-1>=0&&!state[i][j-1]&&map[i][j-1]!='#'){
-                state[i][j-1]=true;
-                pi[i][j-1]='L';
-                d[i][j-1]=d[i][j]+1;
-                q.add(new int[]{i,j-1});
-            }
-        }
-        return pi;
-    }
-    private static class Edge implements Comparable<Edge>{
-        int a;
-        char w;
-        public Edge(int u, char c){
-            a=u;
-            w=c;
-        }
-        public int compareTo(Edge o){
-            if(w<o.w)
-                return -1;
-            if(w>o.w)
-                return 1;
-            if(a<o.a)
-                return -1;
-            if(a>o.a)
-                return 1;
-            return 0;
-        }
-        public String toString() {
-            return "<"+a+", "+w+">";
-        }
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Grafos/Grid/LeetCode200 - Number Of Islands.java b/Problemas/Grafos/Grid/LeetCode200 - Number Of Islands.java
deleted file mode 100644
index 316565b..0000000
--- a/Problemas/Grafos/Grid/LeetCode200 - Number Of Islands.java	
+++ /dev/null
@@ -1,50 +0,0 @@
-// https://leetcode.com/problems/number-of-islands/
-import java.util.*;
-class Solution {
-	public static void main(String[] args) {
-		char[][] grid = { { '1', '1', '0', '0', '0' }, { '1', '1', '0', '0', '0' }, { '0', '0', '1', '0', '0' },
-				{ '0', '0', '0', '1', '1' } };
-		Solution p = new Solution();
-		System.out.println(p.numIslands(grid));
-	
-	}
-	public int numIslands(char[][] grid) {
-		boolean[][] state=new boolean[grid.length][grid[0].length];
-		int c=0;
-		for(int i=0; i<grid.length;i++){
-		    for(int j=0; j<grid[0].length;j++)
-			if(!state[i][j]&&grid[i][j]=='1'){
-			    c++;
-			    bfs(state,grid,i,j);
-			}
-		}
-		return c;
-	}
-	public void bfs(boolean[][] state,char[][] grid,int a, int b){
-		int[] s={a,b};
-		Queue<int[]> q=new LinkedList<>();
-		q.add(s);
-		while(!q.isEmpty()){
-		    int[] act=q.poll();
-		    int i=act[0];
-		    int j=act[1];
-		    if(i+1<grid.length&&grid[i+1][j]=='1'&&!state[i+1][j]){
-			state[i+1][j]=true;
-			q.add(new int[]{i+1,j});
-		    }
-		    if(j+1<grid[0].length&&grid[i][j+1]=='1'&&!state[i][j+1]){
-			state[i][j+1]=true;
-			q.add(new int[]{i,j+1});
-		    }
-		    if(i-1>=0&&grid[i-1][j]=='1'&&!state[i-1][j]){
-			state[i-1][j]=true;
-			q.add(new int[]{i-1,j});
-		    }
-		    if(j-1>=0&&grid[i][j-1]=='1'&&!state[i][j-1]){
-			state[i][j-1]=true;
-			q.add(new int[]{i,j-1});
-		    }
-		}
-	}
-
-}
diff --git a/Problemas/Grafos/Grid/Maximize the Largest Component (Easy Version).java b/Problemas/Grafos/Grid/Maximize the Largest Component (Easy Version).java
deleted file mode 100644
index 5098189..0000000
--- a/Problemas/Grafos/Grid/Maximize the Largest Component (Easy Version).java	
+++ /dev/null
@@ -1,165 +0,0 @@
-// https://codeforces.com/problemset/problem/1985/H1
-import java.io.*;
-import java.util.*;
-
-public class Main {
-    static char[][] map;
-    static boolean[][] state;
-    static int[][] group;
-    static HashMap<Integer,Integer> grupos=new HashMap<>();
-    public static void main(String[] args) throws Exception {
-        Scanner sc=new Scanner();
-        int t=sc.nextInt();
-        for (int times = 0; times < t; times++) {
-            int n=sc.nextInt();
-            int m=sc.nextInt();
-            map=new char[n][m];
-            group=new int[n][m];
-            state=new boolean[n][m];
-            for (int i = 0; i < n; i++)
-                map[i]=sc.next().toCharArray();
-            int g=1;
-            for (int i = 0; i < n; i++) {
-                for (int j = 0; j < m; j++) {
-                    if(map[i][j]=='#'&&!state[i][j]) {
-                        bfs(i, j, g);
-                        g++;
-                    }
-                }
-            }
-            int row=row();
-            int column=column();
-
-            System.out.println(Math.max(row,column));
-        }
-    }
-    static int row(){
-        int c=0;
-        for (int i = 0; i < map.length; i++) {
-            int r=0;
-            HashSet<Integer> set=new HashSet<>();
-            for (int j = 0; j < map[0].length; j++) {
-                if(map[i][j]=='.')
-                    r++;
-                else if(!set.contains(group[i][j])) {
-                    r += grupos.get(group[i][j]);
-                    set.add(group[i][j]);
-                }
-                if(i-1>=0&&map[i-1][j]=='#'&&!set.contains(group[i-1][j])){
-                    set.add(group[i-1][j]);
-                    r+=grupos.get(group[i-1][j]);
-                }
-                if(i+1<map.length&&map[i+1][j]=='#'&&!set.contains(group[i+1][j])){
-                    set.add(group[i+1][j]);
-                    r+=grupos.get(group[i+1][j]);
-                }
-            }
-            c= Math.max(c,r);
-        }
-
-
-        return c;
-    }
-    static int column(){
-        int c=0;
-        for (int i = 0; i < map[0].length; i++) {
-            int r=0;
-            HashSet<Integer> set=new HashSet<>();
-            for (int j = 0; j < map.length; j++) {
-
-                if(map[j][i]=='.')
-                    r++;
-                else if(!set.contains(group[j][i])) {
-                    r += grupos.get(group[j][i]);
-                    set.add(group[j][i]);
-                }
-
-                if(i-1>=0&&map[j][i-1]=='#'&&!set.contains(group[j][i-1])){
-                    set.add(group[j][i-1]);
-                    r+=grupos.get(group[j][i-1]);
-                }
-                if(i+1<map[0].length&&map[j][i+1]=='#'&&!set.contains(group[j][i+1])){
-                    set.add(group[j][i+1]);
-                    r+=grupos.get(group[j][i+1]);
-                }
-            }
-            c= Math.max(c,r);
-        }
-
-
-        return c;
-    }
-    static void bfs(int a, int b, int g){
-        int[] s={a,b};
-        grupos.put(g,1);
-        group[a][b]=g;
-        state[a][b]=true;
-        Queue<int[]> q=new LinkedList<>();
-        q.add(s);
-        while (!q.isEmpty()){
-            int[] u=q.poll();
-            int i=u[0];
-            int j=u[1];
-            if(i+1<map.length&&map[i+1][j]=='#'&&!state[i+1][j]){
-                state[i+1][j]=true;
-                group[i+1][j]=g;
-                grupos.put(g,grupos.get(g)+1);
-                q.add(new int[]{i+1,j});
-            }
-            if(i-1>=0&&map[i-1][j]=='#'&&!state[i-1][j]){
-                state[i-1][j]=true;
-                group[i-1][j]=g;
-                grupos.put(g,grupos.get(g)+1);
-                q.add(new int[]{i-1,j});
-            }
-            if(j+1<map[0].length&&map[i][j+1]=='#'&&!state[i][j+1]){
-                state[i][j+1]=true;
-                group[i][j+1]=g;
-                grupos.put(g,grupos.get(g)+1);
-                q.add(new int[]{i,j+1});
-            }
-            if(j-1>=0&&map[i][j-1]=='#'&&!state[i][j-1]){
-                state[i][j-1]=true;
-                group[i][j-1]=g;
-                grupos.put(g,grupos.get(g)+1);
-                q.add(new int[]{i,j-1});
-            }
-        }
-    }
-
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Grid/Monsters.java b/Problemas/Grafos/Grid/Monsters.java
deleted file mode 100644
index 1941833..0000000
--- a/Problemas/Grafos/Grid/Monsters.java
+++ /dev/null
@@ -1,335 +0,0 @@
-/*https://vjudge.net/problem/CSES-1194*/
-import java.util.*;
-import java.io.*;
-
-
-public class MonstersIan {
-	static char[][] grid;
-	static int[][] dA, dM;
-	static boolean[][] stateA, stateM;
-	static Queue<int[]> Q;
-	static int[][][] pi;
-	static int n, m;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st = new StringTokenizer(in.readLine());
-		n = Integer.parseInt(st.nextToken());
-		m = Integer.parseInt(st.nextToken());
-		grid = new char[n][m];
-		dM = new int[n][m];
-		dA = new int[n][m];
-		stateA = new boolean[n][m];
-		stateM = new boolean[n][m];
-		for (int i = 0; i < n; i++)
-			grid[i] = in.readLine().toCharArray();
-		for (int[] is : dA)
-			Arrays.fill(is, Integer.MAX_VALUE);
-		for (int[] is : dM)
-			Arrays.fill(is, Integer.MAX_VALUE);
-		int[] me = new int[2];
-		List<int[]> salidas = new ArrayList<>();
-		Q = new LinkedList<>();
-		for (int i = 0; i < n; i++)
-			for (int j = 0; j < m; j++) {
-				if (grid[i][j] == 'M') {
-					Q.add(new int[] { i, j });
-					dM[i][j] = 0;
-					stateM[i][j] = true;
-				}
-				if (grid[i][j] == 'A') {
-					me[0] = i;
-					me[1] = j;
-				}
-				if (grid[i][j] == '.' && (i == 0 || i == n - 1 || j == 0 || j == m - 1))
-					salidas.add(new int[] { i, j });
-			}
-		for (int i = 0; i < n; i++)
-			for (int j = 0; j < m; j++)
-				if (grid[i][j] == 'A' && (i == 0 || i == n - 1 || j == 0 || j == m - 1)) {
-					System.out.println("YES");
-					System.out.println(0);
-					return;
-				}
-		if (salidas.isEmpty()) {
-			System.out.println("NO");
-			return;
-		}
-		bfsM();
-		bfsA(me[0], me[1]);
-		boolean cond = false;
-		for (int[] i : salidas) {
-			int r = i[0];
-			int c = i[1];
-			if (dA[r][c] < dM[r][c]) {
-				System.out.println("YES");
-				System.out.println(dA[r][c]);
-				cond = true;
-				List<int[]> path = buildPath(r, c);
-				path.remove(0);
-				System.out.println(printPath(path, me[0], me[1]));
-				break;
-			}
-		}
-		if (!cond)
-			System.out.println("NO");
-	}
-
-	static String printPath(List<int[]> path, int si, int sj) {
-		StringBuffer buf = new StringBuffer();
-		for (int[] i : path) {
-			int r = i[0];
-			int c = i[1];
-			if (r == si)
-				buf.append(c > sj ? "R" : "L");
-			else if (c == sj)
-				buf.append(r < si ? "U" : "D");
-			else
-				buf.append(r > si ? "D" : "U");
-			si = r;
-			sj = c;
-		}
-		return new String(buf);
-
-	}
-
-	static List<int[]> buildPath(int ti, int tj) {
-		List<int[]> path = new LinkedList<>();
-		path.add(new int[] { ti, tj });
-		while (ti != -1 && tj != -1) {
-			int aux = ti;
-			ti = pi[ti][tj][0];
-			tj = pi[aux][tj][1];
-			path.add(0, new int[] { ti, tj });
-		}
-		path.remove(0);
-		return path;
-	}
-
-	static void bfsA(int i, int j) {
-		pi = new int[n][m][2];
-		for (int[][] u : pi)
-			for (int[] v : u)
-				Arrays.fill(v, -1);
-		Q = new LinkedList<>();
-		dA[i][j] = 0;
-		stateA[i][j] = true;
-		Q.add(new int[] { i, j });
-		while (!Q.isEmpty()) {
-			int[] e = Q.poll();
-			int r = e[0];
-			int c = e[1];
-			if (r - 1 >= 0 && !stateA[r - 1][c] && grid[r - 1][c] == '.') {
-				stateA[r - 1][c] = true;
-				dA[r - 1][c] = dA[r][c] + 1;
-				pi[r - 1][c] = new int[] { r, c };
-				Q.add(new int[] { r - 1, c });
-			}
-			if (r + 1 < n && !stateA[r + 1][c] && grid[r + 1][c] == '.') {
-				stateA[r + 1][c] = true;
-				dA[r + 1][c] = dA[r][c] + 1;
-				pi[r + 1][c] = new int[] { r, c };
-				Q.add(new int[] { r + 1, c });
-			}
-			if (c - 1 >= 0 && !stateA[r][c - 1] && grid[r][c - 1] == '.') {
-				stateA[r][c - 1] = true;
-				dA[r][c - 1] = dA[r][c] + 1;
-				pi[r][c - 1] = new int[] { r, c };
-				Q.add(new int[] { r, c - 1 });
-			}
-			if (c + 1 < m && !stateA[r][c + 1] && grid[r][c + 1] == '.') {
-				stateA[r][c + 1] = true;
-				dA[r][c + 1] = dA[r][c] + 1;
-				pi[r][c + 1] = new int[] { r, c };
-				Q.add(new int[] { r, c + 1 });
-			}
-		}
-	}
-
-	static void bfsM() {
-		while (!Q.isEmpty()) {
-			int[] e = Q.poll();
-			int r = e[0];
-			int c = e[1];
-			if (r - 1 >= 0 && !stateM[r - 1][c] && grid[r - 1][c] != '#') {
-				stateM[r - 1][c] = true;
-				dM[r - 1][c] = dM[r][c] + 1;
-				Q.add(new int[] { r - 1, c });
-			}
-			if (r + 1 < n && !stateM[r + 1][c] && grid[r + 1][c] != '#') {
-				stateM[r + 1][c] = true;
-				dM[r + 1][c] = dM[r][c] + 1;
-				Q.add(new int[] { r + 1, c });
-			}
-			if (c - 1 >= 0 && !stateM[r][c - 1] && grid[r][c - 1] != '#') {
-				stateM[r][c - 1] = true;
-				dM[r][c - 1] = dM[r][c] + 1;
-				Q.add(new int[] { r, c - 1 });
-			}
-			if (c + 1 < m && !stateM[r][c + 1] && grid[r][c + 1] != '#') {
-				stateM[r][c + 1] = true;
-				dM[r][c + 1] = dM[r][c] + 1;
-				Q.add(new int[] { r, c + 1 });
-			}
-		}
-	}
-}
-
-
-public class MonstersSamu {
-
-    static int[][] d;
-    static int[][] da;
-    static int n;
-    static int m;
-
-    static ArrayList<int[]> inicios=new ArrayList<>();
-    static ArrayList<int[]> mon=new ArrayList<>();
-    static char[][] map;
-    static char[][]pi;
-
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
-        String[] l1=bf.readLine().split(" ");
-        n=Integer.parseInt(l1[0]);
-        m=Integer.parseInt(l1[1]);
-        map=new char[n][m];
-        d=new int[n][m];
-        da=new int[n][m];
-        pi=new char[n][m];
-        int[] ini=new int[2];
-        for (int i = 0; i < n; i++) {
-            for (int j = 0; j < m; j++) {
-                char a= (char) bf.read();
-                map[i][j]=a;
-                if((i==0||i==n-1||j==0||j==m-1)&&(a!='#'&&a!='M'))
-                    inicios.add(new int[]{i,j});
-                if(a=='M')
-                    mon.add(new int[]{i,j});
-                if(a=='A')
-                    ini=new int[]{i,j};
-
-            }
-            bf.readLine();
-        }
-        bfs();
-        bfs2(ini);
-        //System.out.println(Arrays.deepToString(pi));
-        for (int[] x: inicios){
-            int i=x[0];
-            int j=x[1];
-            if(da[i][j]<d[i][j]){
-                System.out.println("YES");
-                System.out.println(da[i][j]);
-                char[] res=new char[da[i][j]];
-                int index=da[i][j]-1;
-                while (index>=0){
-                    char c=pi[i][j];
-                    res[index]=c;
-                    index--;
-                    //System.out.println(c);
-                    if(c=='+')
-                        break;
-                    if(c=='D')
-                        i--;
-                    else if(c=='R')
-                        j--;
-                    else if(c=='U')
-                        i++;
-                    else if(c=='L')
-                        j++;
-                }
-                System.out.println(new String(res));
-                return;
-            }
-        }
-        System.out.println("NO");
-    }
-
-    static void bfs() {
-        boolean[][] state=new boolean[n][m];
-        for (int i = 0; i < map.length; i++) {
-            for (int j = 0; j < map[0].length; j++) {
-                d[i][j]= Integer.MAX_VALUE;
-            }
-        }
-        Queue<int[]> q=new LinkedList<>();
-        for(int[] i: mon){
-            int x=i[0];
-            int y=i[1];
-            d[x][y]=0;
-            state[x][y]=true;
-            q.add(i);
-        }
-        while (!q.isEmpty()){
-            int[] a=q.poll();
-            int i=a[0];
-            int j=a[1];
-            if(i+1<n&&map[i+1][j]!='#'&&!state[i+1][j]) {
-                q.add(new int[]{i + 1, j});
-                d[i + 1][j] = d[i][j] + 1;
-                state[i+1][j]=true;
-            }
-            if(i-1>=0&&map[i-1][j]!='#'&&!state[i-1][j]) {
-                q.add(new int[]{i - 1, j});
-                d[i - 1][j] = d[i][j] + 1;
-                state[i-1][j]=true;
-            }
-            if(j+1<m&&map[i][j+1]!='#'&&!state[i][j+1]) {
-                q.add(new int[]{i , j+1});
-                d[i][j+1] =d[i][j] + 1;
-                state[i][j+1]=true;
-            }
-            if(j-1>=0&&map[i][j-1]!='#'&&!state[i][j-1]) {
-                q.add(new int[]{i , j-1});
-                d[i][j-1] =  d[i][j] + 1;
-                state[i][j-1]=true;
-            }
-        }
-    }
-    
-    static void bfs2(int[] ini) {
-        boolean[][] state=new boolean[n][m];
-        for (int i = 0; i < map.length; i++) {
-            for (int j = 0; j < map[0].length; j++) {
-                da[i][j]=Integer.MAX_VALUE;
-            }
-        }
-        Queue<int[]> q=new LinkedList<>();
-        int x=ini[0];
-        int y=ini[1];
-        pi[x][y]='+';
-        q.add(ini);
-        da[x][y]=0;
-        state[x][y]=true;
-        while (!q.isEmpty()){
-            int[] a=q.poll();
-            int i=a[0];
-            int j=a[1];
-            if(i+1<n&&map[i+1][j]!='#'&&!state[i+1][j]) {
-                q.add(new int[]{i + 1, j});
-                da[i + 1][j] = da[i][j] + 1;
-                state[i+1][j]=true;
-                pi[i+1][j]='D';
-            }
-            if(i-1>=0&&map[i-1][j]!='#'&&!state[i-1][j]) {
-                q.add(new int[]{i - 1, j});
-                da[i - 1][j] = da[i][j] + 1;
-                state[i-1][j]=true;
-                pi[i-1][j]='U';
-            }
-            if(j+1<m&&map[i][j+1]!='#'&&!state[i][j+1]) {
-                q.add(new int[]{i , j+1});
-                da[i][j+1] =da[i][j] + 1;
-                state[i][j+1]=true;
-                pi[i][j+1]='R';
-            }
-            if(j-1>=0&&map[i][j-1]!='#'&&!state[i][j-1]) {
-                q.add(new int[]{i , j-1});
-                da[i][j-1] =  da[i][j] + 1;
-                state[i][j-1]=true;
-                pi[i][j-1]='L';
-            }
-        }
-    }
-}
diff --git a/Problemas/Grafos/Grid/NumberMaze.java b/Problemas/Grafos/Grid/NumberMaze.java
deleted file mode 100644
index 879faf8..0000000
--- a/Problemas/Grafos/Grid/NumberMaze.java
+++ /dev/null
@@ -1,83 +0,0 @@
-//https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=870
-import java.util.*;
-import java.io.*;
-
-public class NumberMaze {
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		PrintWriter out = new PrintWriter(System.out);
-		StringTokenizer st;
-		int T = Integer.parseInt(in.readLine());
-		for (int i = 0; i < T; i++) {
-			int n = Integer.parseInt(in.readLine());
-			int m = Integer.parseInt(in.readLine());
-			int[][] grid = new int[n][m];
-			for (int j = 0; j < n; j++) {
-				st = new StringTokenizer(in.readLine());
-				for (int k = 0; k < m; k++)
-					grid[j][k] = Integer.parseInt(st.nextToken());
-			}
-			out.println(dijkstra(grid, n, m));
-		}
-		out.flush();
-
-	}
-
-	static int dijkstra(int[][] M, int n, int m) {
-		int[][] d = new int[n][m];
-		for (int[] i : d)
-			Arrays.fill(i, Integer.MAX_VALUE);
-		boolean[][] visited = new boolean[n][m];
-		d[0][0] = M[0][0];
-		TreeSet<Edge> Q = new TreeSet<>();
-		Q.add(new Edge(new int[] { 0, 0 }, M[0][0]));
-		while (!Q.isEmpty()) {
-			Edge e = Q.pollFirst();
-			int x = e.vertex[0];
-			int y = e.vertex[1];
-			if (visited[x][y])
-				continue;
-			visited[x][y] = true;
-			if (x - 1 >= 0 && !visited[x - 1][y] && d[x][y] + M[x - 1][y] < d[x - 1][y]) {
-				d[x - 1][y] = d[x][y] + M[x - 1][y];
-				Q.add(new Edge(new int[] { x - 1, y }, d[x - 1][y]));
-			}
-			if (x + 1 < n && !visited[x + 1][y] && d[x][y] + M[x + 1][y] < d[x + 1][y]) {
-				d[x + 1][y] = d[x][y] + M[x + 1][y];
-				Q.add(new Edge(new int[] { x + 1, y }, d[x + 1][y]));
-			}
-			if (y - 1 >= 0 && !visited[x][y - 1] && d[x][y] + M[x][y - 1] < d[x][y - 1]) {
-				d[x][y - 1] = d[x][y] + M[x][y - 1];
-				Q.add(new Edge(new int[] { x, y - 1 }, d[x][y - 1]));
-			}
-			if (y + 1 < m && !visited[x][y + 1] && d[x][y] + M[x][y + 1] < d[x][y + 1]) {
-				d[x][y + 1] = d[x][y] + M[x][y + 1];
-				Q.add(new Edge(new int[] { x, y + 1 }, d[x][y + 1]));
-			}
-		}
-		return d[n - 1][m - 1];
-
-	}
-
-	static class Edge implements Comparable<Edge> {
-		int[] vertex;
-		int weight;
-
-		Edge(int[] v, int w) {
-			this.vertex = v;
-			this.weight = w;
-		}
-
-		public int compareTo(Edge o) {
-			if (weight < o.weight)
-				return -1;
-			if (weight > o.weight)
-				return 1;
-			if (vertex[0] == o.vertex[0])
-				return vertex[1] - o.vertex[1];
-			return vertex[0] - o.vertex[0];
-		}
-	}
-
-}
diff --git a/Problemas/Grafos/Grid/RottingOranges.java b/Problemas/Grafos/Grid/RottingOranges.java
deleted file mode 100644
index 3eb7d90..0000000
--- a/Problemas/Grafos/Grid/RottingOranges.java
+++ /dev/null
@@ -1,57 +0,0 @@
-//LeetCode994
-import java.util.*;
-
-public class RottingOranges {
-
-	static int orangesRotting(int[][] grid) {
-		int n = grid.length;
-		int m = grid[0].length;
-		boolean[][] visited = new boolean[n][m];
-		int[][] d = new int[n][m];
-		Queue<int[]> Q = new LinkedList<>();
-		for (int i = 0; i < n; i++)
-			for (int j = 0; j < m; j++)
-				if (grid[i][j] == 2) {
-					Q.add(new int[] { i, j });
-					d[i][j] = 0;
-					visited[i][j] = true;
-				}
-		while (!Q.isEmpty()) {
-			int[] e = Q.poll();
-			int r = e[0];
-			int c = e[1];
-			if (r - 1 >= 0 && !visited[r - 1][c] && grid[r - 1][c] == 1) {
-				visited[r - 1][c] = true;
-				d[r - 1][c] = d[r][c] + 1;
-				Q.add(new int[] { r - 1, c });
-			}
-			if (r + 1 < n && !visited[r + 1][c] && grid[r + 1][c] == 1) {
-				visited[r + 1][c] = true;
-				d[r + 1][c] = d[r][c] + 1;
-				Q.add(new int[] { r + 1, c });
-			}
-			if (c - 1 >= 0 && !visited[r][c - 1] && grid[r][c - 1] == 1) {
-				visited[r][c - 1] = true;
-				d[r][c - 1] = d[r][c] + 1;
-				Q.add(new int[] { r, c - 1 });
-			}
-
-			if (c + 1 < m && !visited[r][c + 1] && grid[r][c + 1] == 1) {
-				visited[r][c + 1] = true;
-				d[r][c + 1] = d[r][c] + 1;
-				Q.add(new int[] { r, c + 1 });
-			}
-		}
-		for (int i = 0; i < n; i++)
-			for (int j = 0; j < m; j++)
-				if (!visited[i][j] && grid[i][j] == 1)
-					return -1;
-		int ans = 0;
-		for (int[] i : d)
-			for (int j : i)
-				ans = Math.max(ans, j);
-		return ans;
-
-	}
-
-}
diff --git a/Problemas/Grafos/Grid/SHOP_Shopping.java b/Problemas/Grafos/Grid/SHOP_Shopping.java
deleted file mode 100644
index 73ab700..0000000
--- a/Problemas/Grafos/Grid/SHOP_Shopping.java
+++ /dev/null
@@ -1,120 +0,0 @@
-//https://vjudge.net/problem/SPOJ-SHOP
-import java.io.*;
-import java.util.*;
-
-public class Main {
-
-	static int n;
-	static int m;
-	static char[][] grid;
-	static int[][] d;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st;
-		PrintWriter out = new PrintWriter(System.out);
-		boolean cond = true;
-		while (true) {
-			if (cond)
-				cond = false;
-			else
-				in.readLine();
-			st = new StringTokenizer(in.readLine());
-			m = Integer.parseInt(st.nextToken());
-			n = Integer.parseInt(st.nextToken());
-			if (n == 0 && m == 0)
-				break;
-			grid = new char[n][m];
-			d = new int[n][m];
-			int[] s = new int[2];
-			int[] t = new int[2];
-			for (int i = 0; i < n; i++) {
-				grid[i] = in.readLine().toCharArray();
-				for (int j = 0; j < m; j++)
-					if (grid[i][j] == 'S') {
-						s[0] = i;
-						s[1] = j;
-					} else if (grid[i][j] == 'D') {
-						t[0] = i;
-						t[1] = j;
-					}
-				Arrays.fill(d[i], Integer.MAX_VALUE);
-			}
-			out.println(dijkstra(s, t));
-		}
-		out.close();
-	}
-
-	static int dijkstra(int[] s, int[] t) {
-		TreeSet<int[]> Q = new TreeSet<>((e1, e2) -> {
-			for (int k = 0; k < 3; k++) {
-				if (e1[k] < e2[k])
-					return -1;
-				if (e1[k] > e2[k])
-					return 1;
-			}
-			return 0;
-		});
-		d[s[0]][s[1]] = 0;
-		boolean[][] visited = new boolean[n][m];
-		Q.add(new int[] { 0, s[0], s[1] });
-		while (!Q.isEmpty()) {
-			int[] e = Q.pollFirst();
-			int x = e[1];
-			int y = e[2];
-			if (visited[x][y])
-				continue;
-			visited[x][y] = true;
-			if (x - 1 >= 0 && !visited[x - 1][y]) {
-				char c = grid[x - 1][y];
-				if (Character.isDigit(c)) {
-					int val = Integer.parseInt(String.valueOf(c));
-					if (d[x][y] + val < d[x - 1][y]) {
-						d[x - 1][y] = d[x][y] + val;
-						Q.add(new int[] { d[x][y] + val, x - 1, y });
-					}
-				}
-				if (c == 'D' && d[x][y] < d[x - 1][y])
-					d[x - 1][y] = d[x][y];
-			}
-			if (x + 1 < n && !visited[x + 1][y]) {
-				char c = grid[x + 1][y];
-				if (Character.isDigit(c)) {
-					int val = Integer.parseInt(String.valueOf(c));
-					if (d[x][y] + val < d[x + 1][y]) {
-						d[x + 1][y] = d[x][y] + val;
-						Q.add(new int[] { d[x][y] + val, x + 1, y });
-					}
-				}
-				if (c == 'D' && d[x][y] < d[x + 1][y])
-					d[x + 1][y] = d[x][y];
-			}
-			if (y - 1 >= 0 && !visited[x][y - 1]) {
-				char c = grid[x][y - 1];
-				if (Character.isDigit(c)) {
-					int val = Integer.parseInt(String.valueOf(c));
-					if (d[x][y] + val < d[x][y - 1]) {
-						d[x][y - 1] = d[x][y] + val;
-						Q.add(new int[] { d[x][y] + val, x, y - 1 });
-					}
-				}
-				if (c == 'D' && d[x][y] < d[x][y - 1])
-					d[x][y - 1] = d[x][y];
-			}
-			if (y + 1 < m && !visited[x][y + 1]) {
-				char c = grid[x][y + 1];
-				if (Character.isDigit(c)) {
-					int val = Integer.parseInt(String.valueOf(c));
-					if (d[x][y] + val < d[x][y + 1]) {
-						d[x][y + 1] = d[x][y] + val;
-						Q.add(new int[] { d[x][y] + val, x, y + 1 });
-					}
-				}
-				if (c == 'D' && d[x][y] < d[x][y + 1])
-					d[x][y + 1] = d[x][y];
-
-			}
-		}
-		return d[t[0]][t[1]];
-	}
-}
diff --git a/Problemas/Grafos/Grid/Sakurako's Hobby b/Problemas/Grafos/Grid/Sakurako's Hobby
deleted file mode 100644
index aeacee8..0000000
--- a/Problemas/Grafos/Grid/Sakurako's Hobby	
+++ /dev/null
@@ -1,94 +0,0 @@
-//https://codeforces.com/contest/2008/problem/D
-import java.util.*;
-import java.io.*;
-
-public class Pruebas {
-    static int[] ans;
-    static boolean[] state;
-    static int[] arr;
-    static int[] index;
-    static int nodes;
-    public static void main(String[] args) {
-        Scanner sc = new Scanner();
-        PrintWriter pw=new PrintWriter(System.out);
-        int ti=sc.nextInt();
-        for (int times = 0; times < ti; times++) {
-            int n=sc.nextInt();
-            arr=new int[n];
-            index=new int[n];
-            nodes=0;
-            ans=new int[n];
-            state=new boolean[n];
-            for (int i = 0; i < n; i++)
-                arr[i]=sc.nextInt();
-            String s=sc.next();
-            for (int i = 0; i < n; i++) {
-                if(nodes==n)
-                    break;
-                if(!state[i])
-                    bfs(i,s);
-            }
-            for(int i:index)
-                pw.print(ans[i]+" ");
-            pw.println();
-        }
-        pw.close();
-    }
-    static void bfs(int s,String t){
-        state[s]=true;
-        nodes++;
-        int c=0;
-        int i=s;
-        if(t.charAt(s)=='0')
-            c++;
-        index[s]=s;
-        while (true){
-            i=arr[i]-1;
-            if(state[i])
-                break;
-            index[i]=s;
-            state[i]=true;
-            nodes++;
-            if(t.charAt(i)=='0')
-                c++;
-        }
-        ans[s]=c;
-
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Grafos/Grid/Word Search.java b/Problemas/Grafos/Grid/Word Search.java
deleted file mode 100644
index 36b6693..0000000
--- a/Problemas/Grafos/Grid/Word Search.java	
+++ /dev/null
@@ -1,30 +0,0 @@
-//https://leetcode.com/problems/word-search/?source=submission-noac
-class Solution {
-    public boolean exist(char[][] map, String word) {
-        char c=word.charAt(0);
-        int n=map.length;
-        int m=map[0].length;
-        for(int i=0;i<n;i++)
-            for(int j=0;j<m;j++)
-                if(map[i][j]==c&&dfs(map,i,j,word,0,new boolean[n][m]))
-                    return true;
-        return false;
-    }
-    public boolean dfs(char[][] map, int a, int b,String t,int i,boolean[][] state){
-        int n=map.length;
-        int m=map[0].length;
-        if(i==t.length())
-            return true;
-        if(a<0||a>=n||b<0||b>=m)
-            return false;
-        if(t.charAt(i)!=map[a][b])
-            return false;
-        if(state[a][b])
-            return false;
-        state[a][b]=true;
-        if(dfs(map,a+1,b,t,i+1,state)||dfs(map,a-1,b,t,i+1,state)||dfs(map,a,b+1,t,i+1,state)||dfs(map,a,b-1,t,i+1,state))
-            return true;
-        state[a][b]=false;
-        return false;
-    }
-}
diff --git a/Problemas/Grafos/Matching/BerSU Ball.java b/Problemas/Grafos/Matching/BerSU Ball.java
deleted file mode 100644
index 94f1eb4..0000000
--- a/Problemas/Grafos/Matching/BerSU Ball.java	
+++ /dev/null
@@ -1,93 +0,0 @@
-//https://codeforces.com/problemset/problem/489/B
-import java.util.*;
-import java.io.*;
-
-public class Main {
-    static ArrayList<Integer>[] adj;
-    static int[] mt;
-    static boolean[] state;
-    public static void main(String[] args) throws IOException {
-        Scanner sc = new Scanner();
-        PrintWriter pw=new PrintWriter(System.out);
-        int n=sc.nextInt();
-        int[] b=new int[n];
-        for (int i = 0; i < n; i++)
-            b[i]=sc.nextInt();
-        int m=sc.nextInt();
-        int[] g=new int[m];
-        for (int i = 0; i < m; i++)
-            g[i]=sc.nextInt();
-        adj=new ArrayList[n+m];
-        for (int i = 0; i < n+m; i++)
-            adj[i]=new ArrayList<>();
-        mt=new int[n+m];
-        for (int i = 0; i < n; i++)
-            for (int j = 0; j < m; j++)
-                if(Math.abs(b[i]-g[j])<=1){
-                    adj[i].add(j+n);
-                    //adj[j+n].add(i);
-                }
-        int c=0;
-        Arrays.fill(mt,-1);
-        for (int i = 0; i < n+m; i++) {
-            state=new boolean[n+m];
-            if(tryKuhn(i))
-                c++;
-        }
-        System.out.println(c);
-        //System.out.println(Arrays.toString(adj));
-        pw.close();
-    }
-    static boolean tryKuhn(int u){
-        if(state[u])
-            return false;
-        state[u]=true;
-        for (int v:adj[u])
-            if(mt[v]==-1||tryKuhn(mt[v])){
-                mt[v]=u;
-                return true;
-            }
-        return false;
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Grafos/Matching/BookClub.java b/Problemas/Grafos/Matching/BookClub.java
deleted file mode 100644
index 722dc0e..0000000
--- a/Problemas/Grafos/Matching/BookClub.java
+++ /dev/null
@@ -1,75 +0,0 @@
-//https://open.kattis.com/problems/bookclub
-import java.io.*;
-import java.util.*;
-class Ma{
-    static ArrayList<Integer>[] adj;
-    static int[] mt;
-    static boolean[] state;
-    public static void main(String[] args) throws IOException {
-        Scanner sc=new Scanner(System.in);
-        int n=sc.nextInt();
-        int m=sc.nextInt();
-        adj=new ArrayList[n];
-        mt=new int[n];
-
-        for (int i = 0; i < n; i++)
-            adj[i]=new ArrayList<>();
-        for (int i = 0; i < m; i++)
-            adj[sc.nextInt()].add(sc.nextInt());
-        Arrays.fill(mt,-1);
-        for (int i = 0; i < n; i++) {
-            state=new boolean[n];
-            tryKuhn(i);
-        }
-        int c=0;
-        for (int i:mt)
-            if(i!=-1)
-                c++;
-        if(c==n)
-            System.out.println("YES");
-        else
-            System.out.println("NO");
-
-    }
-    static boolean tryKuhn(int u){
-        if(state[u])
-            return false;
-        state[u]=true;
-        for (int v:adj[u])
-            if(mt[v]==-1||tryKuhn(mt[v])){
-                mt[v]=u;
-                return true;
-            }
-        return false;
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner(InputStream f) {
-            br = new BufferedReader(new InputStreamReader(f));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-    }
-
-
-
-}
diff --git a/Problemas/Grafos/Matching/Diverse T-Shirts.cpp b/Problemas/Grafos/Matching/Diverse T-Shirts.cpp
deleted file mode 100644
index 24e63b0..0000000
--- a/Problemas/Grafos/Matching/Diverse T-Shirts.cpp	
+++ /dev/null
@@ -1,74 +0,0 @@
-//https://codeforces.com/gym/105505/problem/D
-using namespace std;
-#include <bits/stdc++.h>
-#include <iostream>
-#include <algorithm>
-#include <climits>
-#include <cmath>
-#include <iomanip>
-#include <string>
-#define INF 1e9;
-vector<vector<int>> adj;
-vector<int> mt;
-vector<bool> used;
-bool try_kuhn(int v) {
-    if (used[v])
-        return false;
-    used[v] = true;
-    for (int to : adj[v]) {
-        if (mt[to] == -1 || try_kuhn(mt[to])) {
-            mt[to] = v;
-            return true;
-        }
-    }
-    return false;
-}
-
-int main() {
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    int n;
-    cin>>n;
-    vector<string> mp(n);
-    for(int i=0;i<n;i++)
-        cin>>mp[i];
-    vector<vector<int>> colors(n,vector<int>(2,-1));
-    vector<int> cnt(n,0);
-    int col=0;
-    for(int i=0;i<n;i++) {
-        for(int j=0;j<n;j++) {
-            if(mp[i][j]=='1') {
-                vector<int> act={i,j};
-                for(int k=0;k<n;k++) {
-                    if(k!=i&&k!=j&&mp[i][k]=='1'&&mp[j][k]=='1')
-                        act.push_back(k);
-                }
-                for(int u:act)
-                    for(int v:act)
-                        mp[u][v]=0;
-                for(int u:act)
-                    colors[u][cnt[u]++]=col;
-                col++;
-            }
-        }
-    }
-    for(int i=0;i<n;i++)
-        while(cnt[i]<2)
-            colors[i][cnt[i]++]=col++;
-    adj.assign(col,vector<int>());
-
-    for(int i=0;i<n;i++) {
-        adj[colors[i][0]].push_back(colors[i][1]);
-        adj[colors[i][1]].push_back(colors[i][0]);
-    }
-    int c=0;
-    mt.assign(col,-1);
-    for(int i=0;i<col;i++) {
-        used.assign(col,false);
-        if(try_kuhn(i))
-            c++;
-    }
-    cout<<c/2<<endl;
-
-    return 0;
-}
diff --git a/Problemas/Grafos/Matching/Dungeon of Death.java b/Problemas/Grafos/Matching/Dungeon of Death.java
deleted file mode 100644
index 5431f34..0000000
--- a/Problemas/Grafos/Matching/Dungeon of Death.java	
+++ /dev/null
@@ -1,106 +0,0 @@
-//https://vjudge.net/problem/SPOJ-QUEST4
-import java.io.*;
-import java.util.*;
-public class Main {
-    static ArrayList<Integer>[] adj;
-    static int[] mt;
-    static boolean[] state;
-
-    public static void main(String[] args) throws Exception {
-        Scanner sc = new Scanner();
-        PrintWriter out = new PrintWriter(System.out);
-        int ti = sc.nextInt();
-        for (int tim = 0; tim < ti; tim++) {
-            int m=sc.nextInt();
-            adj = new ArrayList[120];
-            mt=new int[120];
-            for (int i = 0; i < 120; i++)
-                adj[i] = new ArrayList<>();
-            for (int i = 0; i < m; i++) {
-                adj[sc.nextInt()].add(sc.nextInt());
-            }
-            int c=0;
-            Arrays.fill(mt,-1);
-            for (int i = 0; i < 120; i++) {
-                state = new boolean[120];
-                if (tryKuhn(i))
-                    c++;
-            }
-            System.out.println(c);
-
-        }
-
-
-    }
-    static boolean tryKuhn(int u){
-        if(state[u])
-            return false;
-        state[u]=true;
-        for (int v:adj[u])
-            if(mt[v]==-1||tryKuhn(mt[v])){
-                mt[v]=u;
-                return true;
-            }
-        return false;
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public void close() throws IOException {
-            br.close();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/Matching/Fast Maximum Matching.cpp b/Problemas/Grafos/Matching/Fast Maximum Matching.cpp
deleted file mode 100644
index 80f9d97..0000000
--- a/Problemas/Grafos/Matching/Fast Maximum Matching.cpp	
+++ /dev/null
@@ -1,78 +0,0 @@
-//https://vjudge.net/problem/SPOJ-MATCHING
-#include <bits/stdc++.h>
-using namespace std;
-#define MAX 150007
-#define INF (1<<28)
-
-vector< int > G[MAX];
-int n, m, match[MAX], dist[MAX];
-bool bfs() {
-    int i, u, v, len;
-    queue< int > Q;
-    for(i=1; i<=n; i++) {
-        if(match[i]==0) {
-            dist[i] = 0;
-            Q.push(i);
-        }
-        else dist[i] = INF;
-    }
-    dist[0] = INF;
-    while(!Q.empty()) {
-        u = Q.front(); Q.pop();
-        if(u!=0) {
-            len = G[u].size();
-            for(i=0; i<len; i++) {
-                v = G[u][i];
-                if(dist[match[v]]==INF) {
-                    dist[match[v]] = dist[u] + 1;
-                    Q.push(match[v]);
-                }
-            }
-        }
-    }
-    return (dist[0]!=INF);
-}
-
-bool dfs(int u) {
-    int i, v, len;
-    if(u!=0) {
-        len = G[u].size();
-        for(i=0; i<len; i++) {
-            v = G[u][i];
-            if(dist[match[v]]==dist[u]+1) {
-                if(dfs(match[v])) {
-                    match[v] = u;
-                    match[u] = v;
-                    return true;
-                }
-            }
-        }
-        dist[u] = INF;
-        return false;
-    }
-    return true;
-}
-
-int hopcroft_karp() {
-    int matching = 0, i;
-    // match[] is assumed NIL for all vertex in G
-    while(bfs())
-        for(i=1; i<=n; i++)
-            if(match[i]==0 && dfs(i))
-                matching++;
-    return matching;
-}
-int main(){
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    int edges ;
-    cin>>n>>m>>edges;
-    for(int i=0; i<edges; i++) {
-        int u, v;
-        cin>>u>>v;
-        G[u].push_back(v+n);
-        G[v+n].push_back(u);
-    }
-    cout<<hopcroft_karp();
-}
diff --git a/Problemas/Grafos/Matching/Gopher II.java b/Problemas/Grafos/Matching/Gopher II.java
deleted file mode 100644
index daddab6..0000000
--- a/Problemas/Grafos/Matching/Gopher II.java	
+++ /dev/null
@@ -1,100 +0,0 @@
-//https://open.kattis.com/problems/gopher2
-import java.io.*;
-import java.util.*;
-class Ma{
-    static ArrayList<Integer>[] adj;
-    static int[] mt;
-    static boolean[] state;
-
-    public static void main(String[] args) throws IOException {
-        Scanner sc=new Scanner(System.in);
-        while (sc.ready()){
-            int n=sc.nextInt();
-            int m=sc.nextInt();
-            int s=sc.nextInt();
-            int v=sc.nextInt();
-            adj=new ArrayList[n];
-            mt=new int[n];
-            for (int i = 0; i < n; i++)
-                adj[i]=new ArrayList<>();
-            Punto[] ratas=new Punto[n];
-            Punto[] huecos=new Punto[m];
-            for (int i = 0; i < n; i++)
-                ratas[i]=new Punto(sc.nextDouble(),sc.nextDouble());
-            for (int i = 0; i < m; i++)
-                huecos[i]=new Punto(sc.nextDouble(),sc.nextDouble());
-
-            for (int i = 0; i < n; i++) {
-                for (int j = 0; j < m; j++) {
-                    if(ratas[i].d(huecos[j])/v<=s)
-                        adj[i].add(j);
-                }
-            }
-            int c=0;
-            Arrays.fill(mt,-1);
-            for (int i = 0; i < n; i++) {
-                state=new boolean[n];
-                if(tryKuhn(i))
-                    c++;
-            }
-
-            System.out.println(n-c);
-        }
-    }
-    static boolean tryKuhn(int u){
-        if(state[u])
-            return false;
-        state[u]=true;
-        for (int v:adj[u])
-            if(mt[v]==-1||tryKuhn(mt[v])){
-                mt[v]=u;
-                return true;
-            }
-        return false;
-    }
-    static class Punto{
-        double x;
-        double y;
-        public Punto(double a, double b){
-            x=a;
-            y=b;
-        }
-        public double d(Punto p){
-            return Math.hypot(x-p.x,y-p.y);
-        }
-        public String toString(){
-            return "("+x+", "+y+")";
-        }
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner(InputStream f) {
-            br = new BufferedReader(new InputStreamReader(f));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-    }
-
-
-
-}
diff --git a/Problemas/Grafos/Matching/School Dance.java b/Problemas/Grafos/Matching/School Dance.java
deleted file mode 100644
index 7217923..0000000
--- a/Problemas/Grafos/Matching/School Dance.java	
+++ /dev/null
@@ -1,168 +0,0 @@
-//https://vjudge.net/problem/CSES-1696
-import java.io.*;
-import java.util.*;
-
-public class Main {
-    static ArrayList<Integer>[] adj;
-    static int n;
-    static final int INF = Integer.MAX_VALUE;
-    static int[][] capacity;
-    static int[][] flo;
-
-    public static void main(String[] args) {
-        Scanner sc=new Scanner();
-        PrintWriter out=new PrintWriter(System.out);
-        int boys=sc.nextInt(),girls=sc.nextInt(),m=sc.nextInt();
-        n=boys+girls+2;
-        adj=new ArrayList[n];
-        for (int i = 0; i < n; i++)
-            adj[i]=new ArrayList<>();
-        capacity=new int[n][n];
-        flo=new int[n][n];
-        for (int i = 0; i < m; i++) {
-            int u=sc.nextInt()-1,v=sc.nextInt()-1+boys;
-            adj[u].add(v);
-            adj[v].add(u);
-            capacity[u][v]=1;
-        }
-        int s=n-2,t=n-1;
-        for(int i =0;i<boys;i++){
-            adj[s].add(i);
-            adj[i].add(s);
-            capacity[s][i]=1;
-        }
-        for(int i =0;i<girls;i++){
-            adj[t].add(i+boys);
-            adj[i+boys].add(t);
-            capacity[i+boys][t]=1;
-        }
-        int flow=maxflow(s,t);
-        out.println(flow);
-        for(int i =0;i<flow;i++){
-            StringBuilder sb=new StringBuilder();
-            int k=t;
-            for(int j=0;j<n;j++){
-                if(flo[j][k]==1){
-                    flo[j][k]=0;
-                    sb.insert(0,j-boys+1);
-                    k=j;
-                    break;
-                }
-            }
-            for(int j=0;j<n;j++){
-                if(flo[j][k]==1){
-                    flo[j][k]=0;
-                    sb.insert(0,j+1+" ");
-                    k=j;
-                    break;
-                }
-            }
-            out.println(sb);
-        }
-
-        out.close();
-    }
-    static boolean bfs(int s, int t, int[] parent) {
-        boolean[] visited = new boolean[n];
-        Queue<Integer> q = new LinkedList<>();
-        q.add(s);
-        parent[s] = -1;
-        visited[s] = true;
-        while (!q.isEmpty()) {
-            int cur = q.poll();
-            for (int n : adj[cur]) {
-                if (!visited[n] && capacity[cur][n] > 0) {
-                    parent[n] = cur;
-                    visited[n] = true;
-                    q.add(n);
-                    if (n == t)
-                        return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    static int maxflow(int s, int t) {
-        int[] pi = new int[n];
-        int maxflow = 0;
-        while (bfs(s, t, pi)) {
-            int flow = INF;
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                flow = Math.min(flow, capacity[p][cur]);
-            }
-            for (int cur = t; cur != s; cur = pi[cur]) {
-                int p = pi[cur];
-                capacity[p][cur] -= flow;
-                capacity[cur][p] += flow;
-                flo[p][cur] += flow;
-                flo[cur][p] -= flow;
-            }
-
-            maxflow += flow;
-        }
-        return maxflow;
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        public String nextLine() throws Exception {
-            return br.readLine();
-        }
-
-        public void close() throws IOException {
-            br.close();
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-    }
-
-}
diff --git a/Problemas/Grafos/SCC/Calling Circles.java b/Problemas/Grafos/SCC/Calling Circles.java
deleted file mode 100644
index d0b560e..0000000
--- a/Problemas/Grafos/SCC/Calling Circles.java	
+++ /dev/null
@@ -1,106 +0,0 @@
-//https://vjudge.net/problem/UVA-247
-import java.util.*;
-import java.io.*;
-
-public class CallingCircles {
-	static int n;
-	static ArrayList<Integer>[] adj;
-	static ArrayList<Integer>[] adjT;
-	static Stack<Integer> top_sort;
-	static boolean[] state;
-	static List<List<Integer>> comps;
-
-	@SuppressWarnings("unchecked")
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st;
-		PrintWriter out = new PrintWriter(System.out);
-		int caso = 1;
-		while (true) {
-			st = new StringTokenizer(in.readLine());
-			n = Integer.parseInt(st.nextToken());
-			int m = Integer.parseInt(st.nextToken());
-			if (n == 0 && m == 0)
-				break;
-			if (caso != 1)
-				out.println();
-			HashMap<String, Integer> h = new HashMap<>();
-			HashMap<Integer, String> inv = new HashMap<>();
-			adj = new ArrayList[n];
-			adjT = new ArrayList[n];
-			for (int i = 0; i < n; i++) {
-				adj[i] = new ArrayList<>();
-				adjT[i] = new ArrayList<>();
-			}
-
-			int index = 0;
-			for (int i = 0; i < m; i++) {
-				st = new StringTokenizer(in.readLine());
-				String a = st.nextToken();
-				String b = st.nextToken();
-				if (h.get(b) == null) {
-					h.put(b, index);
-					inv.put(index, b);
-					index++;
-				}
-				if (h.get(a) == null) {
-					h.put(a, index);
-					inv.put(index, a);
-					index++;
-				}
-				adj[h.get(a)].add(h.get(b));
-				adjT[h.get(b)].add(h.get(a));
-			}
-			out.println("Calling circles for data set " + caso++ + ":");
-			get_scc();
-			if (h.isEmpty())
-				continue;
-			for (List<Integer> comp : comps) {
-				index = 0;
-				List<String> ans = new ArrayList<>();
-				for (int u : comp)
-					ans.add(inv.get(u));
-				for (String u : ans)
-					out.print(u + (index++ < comp.size() - 1 ? ", " : ""));
-				out.println();
-			}
-		}
-		out.flush();
-
-	}
-
-	static void get_scc() {
-		state = new boolean[n];
-		top_sort = new Stack<>();
-		for (int i = 0; i < n; i++)
-			if (!state[i])
-				dfs(i);
-		state = new boolean[n];
-		comps = new ArrayList<>();
-		while (!top_sort.isEmpty()) {
-			int u = top_sort.pop();
-			if (!state[u]) {
-				List<Integer> comp = new ArrayList<>();
-				dfs_kos(u, comp);
-				comps.add(comp);
-			}
-		}
-	}
-
-	static void dfs(int u) {
-		state[u] = true;
-		for (int v : adj[u])
-			if (!state[v])
-				dfs(v);
-		top_sort.push(u);
-	}
-
-	static void dfs_kos(int u, List<Integer> comp) {
-		comp.add(u);
-		state[u] = true;
-		for (int v : adjT[u])
-			if (!state[v])
-				dfs_kos(v, comp);
-	}
-
-}
diff --git a/Problemas/Grafos/SCC/Coin Collector.cpp b/Problemas/Grafos/SCC/Coin Collector.cpp
deleted file mode 100644
index b61bbd3..0000000
--- a/Problemas/Grafos/SCC/Coin Collector.cpp	
+++ /dev/null
@@ -1,112 +0,0 @@
-//https://cses.fi/problemset/task/1686/
-#include <bits/stdc++.h>
-using namespace std;
-#define dll double long
-#define ll long long
-#define Pair pair<int,int>
-#define eb emplace_back
-#define pb push_back
-#define all(x) (x).begin(), (x).end()
-#define ln "\n"
-#define mk(x,y) make_pair(x,y)
-#define For(i, a, b) for(int i = a; i < b; i++)
-#define Rfor(i, a, b) for(int i = a; i >= b; i--)
-const int INF = 1e9;
-const int MAX = 1005;
-vector<bool> visited;
-
-void dfs(int v, vector<vector<int> > const &adj, vector<int> &output) {
-    visited[v] = true;
-    for (auto u: adj[v])
-        if (!visited[u])
-            dfs(u, adj, output);
-    output.push_back(v);
-}
-
-void kosaraju(vector<vector<int> > const &adj, vector<vector<int> > &components,
-              vector<vector<int> > &adj_cond) {
-    int n = adj.size();
-    components.clear(), adj_cond.clear();
-    vector<int> order;
-    visited.assign(n, false);
-    for (int i = 0; i < n; i++)
-        if (!visited[i])
-            dfs(i, adj, order);
-    vector<vector<int> > adj_rev(n);
-    for (int v = 0; v < n; v++)
-        for (int u: adj[v])
-            adj_rev[u].push_back(v);
-    visited.assign(n, false);
-    reverse(order.begin(), order.end());
-    vector<int> roots(n, 0);
-    for (auto v: order)
-        if (!visited[v]) {
-            std::vector<int> component;
-            dfs(v, adj_rev, component);
-            components.push_back(component);
-            int root = *min_element(begin(component), end(component));
-            for (auto u: component)
-                roots[u] = root;
-        }
-    adj_cond.assign(n, {});
-    for (int v = 0; v < n; v++)
-        for (auto u: adj[v])
-            if (roots[v] != roots[u])
-                adj_cond[roots[v]].push_back(roots[u]);
-}
-
-int main() {
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    int n, m;
-    cin >> n >> m;
-    vector<vector<int> > adj(n, vector<int>());
-    vector<int> a(n);
-    vector<vector<int> > scc;
-    vector<vector<int> > adj_cond;
-    For(i, 0, n)
-        cin >> a[i];
-    For(i, 0, m) {
-        int u, v;
-        cin >> u >> v;
-        u--;
-        v--;
-        adj[u].pb(v);
-    }
-    kosaraju(adj, scc, adj_cond);
-    vector<ll> pref(scc.size(), 0);
-    unordered_map<int,int>mp;
-    For(i, 0, scc.size()) {
-        For(j, 0, scc[i].size()) {
-            mp[scc[i][j]]=i;
-            pref[i] += a[scc[i][j]];
-        }
-    }
-    vector<int> inDeg(adj_cond.size(), 0);
-    For(i, 0, adj_cond.size())
-        for (auto v: adj_cond[i])
-            inDeg[v]++;
-    queue<int> q;
-    For(i, 0, inDeg.size())
-        if (inDeg[i] == 0)
-            q.push(i);
-    vector<ll>dp(scc.size());
-    For(i,0,scc.size())
-        dp[i]=pref[i];
-    while(!q.empty()) {
-        int u = q.front();
-        q.pop();
-        for(int v: adj_cond[u]) {
-            if(dp[mp[u]]+pref[mp[v]]>dp[mp[v]]) {
-                dp[mp[v]] = dp[mp[u]]+pref[mp[v]];
-                q.push(v);
-            }
-        }
-    }
-    ll ans=*max_element(dp.begin(), dp.end());
-    cout << ans << endl;
-    return 0;
-}
-
-//freopen("socdist.in", "r",stdin);
-//fr    eopen("socdist.out", "w", stdout)
diff --git a/Problemas/Grafos/SCC/Flight Routes Check.java b/Problemas/Grafos/SCC/Flight Routes Check.java
deleted file mode 100644
index 6b9e1e5..0000000
--- a/Problemas/Grafos/SCC/Flight Routes Check.java	
+++ /dev/null
@@ -1,82 +0,0 @@
-//https://cses.fi/problemset/task/1682/
-import java.util.*;
-import java.io.*;
-
-public class Main {
-
-	static int n;
-	static ArrayList<Integer>[] adj;
-	static ArrayList<Integer>[] adjT;
-	static Stack<Integer> topsort;
-	static int nscc;
-	static int[] scc;
-	static boolean[] visited;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st;
-		PrintWriter out = new PrintWriter(System.out);
-		st = new StringTokenizer(in.readLine());
-		n = Integer.parseInt(st.nextToken());
-		int m = Integer.parseInt(st.nextToken());
-		adj = new ArrayList[n];
-		adjT = new ArrayList[n];
-		for (int i = 0; i < n; i++) {
-			adj[i] = new ArrayList<>();
-			adjT[i] = new ArrayList<>();
-		}
-		for (int i = 0; i < m; i++) {
-			st = new StringTokenizer(in.readLine());
-			int a = Integer.parseInt(st.nextToken()) - 1;
-			int b = Integer.parseInt(st.nextToken()) - 1;
-			adj[a].add(b);
-			adjT[b].add(a);
-		}
-		kosaraju();
-		if (nscc > 1) {
-			System.out.println("NO");
-			int u = 0;
-			for (int i = 1; i < n; i++)
-				if (scc[i] != scc[u]) {
-					System.out.println(scc[u] < scc[i] ? (++i) + " " + (++u) : (++u) + " " + (++i));
-					break;
-				}
-		} else
-			System.out.println("YES");
-
-	}
-
-	static void kosaraju() {
-		visited = new boolean[n];
-		topsort = new Stack<>();
-		for (int i = 0; i < n; i++)
-			if (!visited[i])
-				dfs(i);
-		nscc = 0;
-		scc = new int[n];
-		visited = new boolean[n];
-		while (!topsort.isEmpty()) {
-			int u = topsort.pop();
-			if (!visited[u])
-				dfsK(u, nscc++);
-		}
-	}
-
-	static void dfsK(int u, int N) {
-		scc[u] = N;
-		visited[u] = true;
-		for (int v : adjT[u])
-			if (!visited[v])
-				dfsK(v, N);
-
-	}
-
-	static void dfs(int u) {
-		visited[u] = true;
-		for (int v : adj[u])
-			if (!visited[v])
-				dfs(v);
-		topsort.push(u);
-	}
-
-}
diff --git a/Problemas/Grafos/SCC/Good Travles.cpp b/Problemas/Grafos/SCC/Good Travles.cpp
deleted file mode 100644
index c29fb8c..0000000
--- a/Problemas/Grafos/SCC/Good Travles.cpp	
+++ /dev/null
@@ -1,122 +0,0 @@
-//https://www.spoj.com/problems/GOODA/
-#include <bits/stdc++.h>
-using namespace std;
-#define dll double long
-#define ll long long
-#define Pair pair<ll,int>
-#define eb emplace_back
-#define pb push_back
-#define all(x) (x).begin(), (x).end()
-#define ln "\n"
-#define mk(x,y) make_pair(x,y)
-#define For(i, a, b) for(int i = a; i < b; i++)
-#define Rfor(i, a, b) for(int i = a; i >= b; i--)
-const int INF = 1e9;
-const int MAX = 1005;
-vector<bool> visited;
- 
-void dfs(int v, vector<vector<int> > const &adj, vector<int> &output) {
-    visited[v] = true;
-    for (auto u: adj[v])
-        if (!visited[u])
-            dfs(u, adj, output);
-    output.push_back(v);
-}
- 
-void kosaraju(vector<vector<int> > const &adj, vector<vector<int> > &components,
-              vector<vector<int> > &adj_cond) {
-    int n = adj.size();
-    components.clear(), adj_cond.clear();
-    vector<int> order;
-    visited.assign(n, false);
-    for (int i = 0; i < n; i++)
-        if (!visited[i])
-            dfs(i, adj, order);
-    vector<vector<int> > adj_rev(n);
-    for (int v = 0; v < n; v++)
-        for (int u: adj[v])
-            adj_rev[u].push_back(v);
-    visited.assign(n, false);
-    reverse(order.begin(), order.end());
-    vector<int> roots(n, 0);
-    for (auto v: order)
-        if (!visited[v]) {
-            std::vector<int> component;
-            dfs(v, adj_rev, component);
-            components.push_back(component);
-            int root = *min_element(begin(component), end(component));
-            for (auto u: component)
-                roots[u] = root;
-        }
-    adj_cond.assign(n, {});
-    for (int v = 0; v < n; v++)
-        for (auto u: adj[v])
-            if (roots[v] != roots[u])
-                adj_cond[roots[v]].push_back(roots[u]);
-}
-ll dijkstra(int s, int t,vector<vector<int>>&adj,vector<ll>& a) {
-    set<Pair,greater<Pair>> q;
-    vector<ll> d(a.size(),0);
-    vector<bool> state(a.size(),false);
-    d[s]=a[s];
-    q.insert({s,s});
-    while (!q.empty()) {
-        int u = (*q.begin()).second;
-        q.erase(q.begin());
-        if (state[u]) continue;
-        state[u] = true;
-        for (const int& v : adj[u]) {
-            if(!state[v]) {
-                ll w=a[v];
-                if (d[u] + w < d[v]) {
-                    d[v] = d[u] + w;
-                    q.insert({d[v], v});
-                }
-            }
-        }
-    }
-    return -d[t];
-}
-int main() {
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    int n, m, s, t;
-    cin >> n >> m >> s >> t;
-    vector<vector<int> > adj(n, vector<int>());
-    vector<int> a(n);
-    vector<vector<int> > scc;
-    vector<vector<int> > adj_cond;
-    For(i, 0, n)
-        cin >> a[i];
-    s--;t--;
-    For(i, 0, m) {
-        int u, v;
-        cin >> u >> v;
-        u--;
-        v--;
-        adj[u].pb(v);
-    }
-    kosaraju(adj, scc, adj_cond);
-    vector<ll> pref(scc.size(), 0);
-    unordered_map<int, int> mp;
-    For(i, 0, scc.size()) {
-        For(j, 0, scc[i].size()) {
-            mp[scc[i][j]] = i;
-            pref[i] += a[scc[i][j]];
-        }
-    }
-    For(i,0,pref.size())
-        pref[i]=-pref[i];
-    vector<vector<int> > adj_rev(scc.size(), vector<int>());
-    For(i, 0, adj_cond.size()) {
-        if(adj_cond[i].empty())continue;
-        for(int v:adj_cond[i])
-            adj_rev[mp[i]].pb(mp[v]);
-    }
-    cout<<dijkstra(mp[s],mp[t],adj_rev,pref)<<ln;
-    return 0;
-}
- 
-//freopen("socdist.in", "r",stdin);
-//fr    eopen("socdist.out", "w", stdout)
- 
diff --git a/Problemas/Grafos/SCC/Planets And Kingdoms.java b/Problemas/Grafos/SCC/Planets And Kingdoms.java
deleted file mode 100644
index c3cb948..0000000
--- a/Problemas/Grafos/SCC/Planets And Kingdoms.java	
+++ /dev/null
@@ -1,73 +0,0 @@
-//https://cses.fi/problemset/task/1683/
-import java.util.*;
-import java.io.*;
-
-public class Main {
-
-	static int n;
-	static ArrayList<Integer>[] adj;
-	static ArrayList<Integer>[] adjT;
-	static Stack<Integer> topsort;
-	static int nscc;
-	static int[] scc;
-	static boolean[] visited;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st;
-		PrintWriter out = new PrintWriter(System.out);
-		st = new StringTokenizer(in.readLine());
-		n = Integer.parseInt(st.nextToken());
-		int m = Integer.parseInt(st.nextToken());
-		adj = new ArrayList[n];
-		adjT = new ArrayList[n];
-		for (int i = 0; i < n; i++) {
-			adj[i] = new ArrayList<>();
-			adjT[i] = new ArrayList<>();
-		}
-		for (int i = 0; i < m; i++) {
-			st = new StringTokenizer(in.readLine());
-			int a = Integer.parseInt(st.nextToken()) - 1;
-			int b = Integer.parseInt(st.nextToken()) - 1;
-			adj[a].add(b);
-			adjT[b].add(a);
-		}
-		kosaraju();
-		out.println(nscc - 1);
-		for (int u : scc)
-			out.print(u + " ");
-		out.close();
-
-	}
-
-	static void kosaraju() {
-		visited = new boolean[n];
-		topsort = new Stack<>();
-		for (int i = 0; i < n; i++)
-			if (!visited[i])
-				dfs(i);
-		nscc = 1;
-		scc = new int[n];
-		while (!topsort.isEmpty()) {
-			int u = topsort.pop();
-			if (scc[u] == 0)
-				dfsK(u, nscc++);
-		}
-	}
-
-	static void dfsK(int u, int N) {
-		scc[u] = N;
-		for (int v : adjT[u])
-			if (scc[v] == 0)
-				dfsK(v, N);
-	}
-
-	static void dfs(int u) {
-		visited[u] = true;
-		for (int v : adj[u])
-			if (!visited[v])
-				dfs(v);
-		topsort.push(u);
-	}
-
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/ANodeTooFar.java b/Problemas/Grafos/SearchProblems/BFS,DFS/ANodeTooFar.java
deleted file mode 100644
index a14523e..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/ANodeTooFar.java
+++ /dev/null
@@ -1,73 +0,0 @@
-//https://vjudge.net/problem/UVA-336
-import java.util.*;
-
-public class Main {
-	static HashMap<Integer, List<Integer>> adjList;
-	static HashMap<Integer, Integer> signal;
-	static HashMap<Integer, Boolean> visitado;
-	static int c = 1;
-
-	public static void main(String[] args) {
-		Scanner key = new Scanner(System.in);
-		while (true) {
-			int nc = key.nextInt();
-			if (nc == 0)
-				break;
-			adjList = new HashMap<Integer, List<Integer>>();
-			for (int i = 0; i < nc; i++) {
-				int a = key.nextInt();
-				int b = key.nextInt();
-				addEdge(a, b);
-			}
-			while (true) {
-				int q1 = key.nextInt();
-				int q2 = key.nextInt();
-				if (q1 == 0 && q2 == 0)
-					break;
-				System.out.println(ans(q1, q2, c));
-				c++;
-			}
-		}
-	}
-
-	static String ans(int s, int ttl, int caso) {
-		visitado = new HashMap<Integer, Boolean>();
-		visitado.put(s, true);
-		bfs(s, ttl);
-		int k = 0;
-		for (Map.Entry<Integer, Integer> entry : signal.entrySet())
-			if (entry.getValue() >= 0)
-				k++;
-		return "Case " + caso + ": " + (adjList.keySet().size() - k) + " nodes not reachable from node " + s
-				+ " with TTL = " + ttl + ".";
-	}
-
-	static void bfs(int s, int ttl) {
-		signal = new HashMap<>();
-		if (adjList.get(s) == null)
-			return;
-		signal.put(s, ttl);
-		Queue<Integer> Q = new LinkedList<Integer>();
-		Q.add(s);
-		int new_ttl = ttl;
-		while (!Q.isEmpty()) {
-			int u = Q.poll();
-			new_ttl = signal.get(u) - 1;
-			for (int v : adjList.get(u))
-				if (visitado.get(v) == null) {
-					visitado.put(v, true);
-					signal.put(v, new_ttl);
-					Q.add(v);
-				}
-		}
-	}
-
-	static void addEdge(int a, int b) {
-		if (adjList.get(a) == null)
-			adjList.put(a, new LinkedList<Integer>());
-		if (adjList.get(b) == null)
-			adjList.put(b, new LinkedList<Integer>());
-		adjList.get(a).add(b);
-		adjList.get(b).add(a);
-	}
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/Bicolor SPOJ.java b/Problemas/Grafos/SearchProblems/BFS,DFS/Bicolor SPOJ.java
deleted file mode 100644
index 0a47b6d..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/Bicolor SPOJ.java	
+++ /dev/null
@@ -1,61 +0,0 @@
-// https://www.spoj.com/problems/BICOLOR/
-import java.io.*;
-import java.util.*;
-
-public class Bicolor {
-	static int n;
-	static ArrayList<Integer>[] adj;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		while (true) {
-			n = Integer.parseInt(in.readLine());
-			if (n == 0)
-				break;
-			adj = new ArrayList[n];
-			for (int i = 0; i < n; i++)
-				adj[i] = new ArrayList<>();
-			int m = Integer.parseInt(in.readLine());
-			StringTokenizer st;
-			for (int i = 0; i < m; i++) {
-				st = new StringTokenizer(in.readLine());
-				int a = Integer.parseInt(st.nextToken());
-				int b = Integer.parseInt(st.nextToken());
-				adj[a].add(b);
-				adj[b].add(a);
-			}
-			System.out.println(bfs() ? "BICOLORABLE" : "NOT BICOLORABLE");
-		}
-
-	}
-
-	static boolean bfs() {
-		int[] pi = new int[n];
-		Boolean[] color = new Boolean[n];
-		boolean[] visited = new boolean[n];
-		Arrays.fill(color, null);
-		Arrays.fill(pi, -1);
-		color[0] = true;
-		Queue<Integer> Q = new LinkedList<>();
-		Q.add(0);
-		while (!Q.isEmpty()) {
-			int u = Q.poll();
-			if (!visited[u]) {
-				visited[u] = true;
-				for (int v : adj[u]) {
-					if (!visited[v]) {
-						if (color[v] == null)
-							color[v] = !color[u];
-						if (color[v] == color[u])
-							return false;
-						pi[v] = u;
-						Q.add(v);
-					}
-				}
-			}
-		}
-		return true;
-
-	}
-
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/Building Teams.java b/Problemas/Grafos/SearchProblems/BFS,DFS/Building Teams.java
deleted file mode 100644
index c844c57..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/Building Teams.java	
+++ /dev/null
@@ -1,108 +0,0 @@
-//https://vjudge.net/problem/CSES-1668
-import java.util.*;
-import java.io.*;
-
-public class Main {
-    static ArrayList<Integer>[] adj;
-    static boolean[] state;
-    static int[] d,pi;
-    static int n;
-    static Boolean[] color;
-    public static void main(String[] args) {
-        Scanner sc = new Scanner();
-        PrintWriter pw = new PrintWriter(System.out);
-        n=sc.nextInt();
-        int m=sc.nextInt();
-        adj=new ArrayList[n];
-        state=new boolean[n];
-        color = new Boolean[n];
-        d=new int[n];
-        pi=new int[n];
-        Arrays.fill(pi,-1);
-        for (int i = 0; i < n; i++)
-            adj[i]=new ArrayList<>();
-        for (int i = 0; i < m; i++) {
-            int u =sc.nextInt()-1;
-            int v=sc.nextInt()-1;
-            adj[u].add(v);
-            adj[v].add(u);
-        }
-        for (int i = 0; i < n; i++) {
-            if(!state[i]){
-                if(!bfs(i)){
-                    System.out.println("IMPOSSIBLE");
-                    return;
-                }
-            }
-        }
-        for (int i = 0; i < n; i++)
-            pw.print((color[i]? 1:2)+" ");
-        pw.close();
-
-
-
-    }
-    static boolean bfs(int s) {
-        color[s] = true;
-        Queue<Integer> Q = new LinkedList<>();
-        Q.add(s);
-        while (!Q.isEmpty()) {
-            int u = Q.poll();
-            if (!state[u]) {
-                state[u] = true;
-                for (int v : adj[u]) {
-                    if (!state[v]) {
-                        if (color[v]==null)
-                            color[v] = !color[u];
-                        if (color[v] == color[u])
-                            return false;
-                        Q.add(v);
-                    }
-                }
-            }
-        }
-        return true;
-    }
-
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/ClawDescomposition.java b/Problemas/Grafos/SearchProblems/BFS,DFS/ClawDescomposition.java
deleted file mode 100644
index 2f87a0a..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/ClawDescomposition.java
+++ /dev/null
@@ -1,64 +0,0 @@
-// https://vjudge.net/problem/UVA-11396
-import java.io.*;
-import java.util.*;
-
-public class ClawDecomposition {
-	static int n;
-	static ArrayList<Integer>[] adj;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		while (true) {
-			n = Integer.parseInt(in.readLine());
-			if (n == 0)
-				break;
-			adj = new ArrayList[n];
-			for (int i = 0; i < n; i++)
-				adj[i] = new ArrayList<>();
-			while (true) {
-				StringTokenizer st = new StringTokenizer(in.readLine());
-				int a = Integer.parseInt(st.nextToken());
-				int b = Integer.parseInt(st.nextToken());
-				if (a == 0 && b == 0)
-					break;
-				a--;
-				b--;
-				adj[a].add(b);
-				adj[b].add(a);
-			}
-			System.out.println(bfs() ? "YES" : "NO");
-
-		}
-
-	}
-
-	static boolean bfs() {
-		int[] pi = new int[n];
-		Boolean[] color = new Boolean[n];
-		boolean[] visited = new boolean[n];
-		Arrays.fill(color, null);
-		Arrays.fill(pi, -1);
-		color[0] = true;
-		Queue<Integer> Q = new LinkedList<>();
-		Q.add(0);
-		while (!Q.isEmpty()) {
-			int u = Q.poll();
-			if (!visited[u]) {
-				visited[u] = true;
-				for (int v : adj[u]) {
-					if (!visited[v]) {
-						if (color[v] == null)
-							color[v] = !color[u];
-						if (color[v] == color[u])
-							return false;
-						pi[v] = u;
-						Q.add(v);
-					}
-				}
-			}
-		}
-		return true;
-
-	}
-
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/ConnectedCountry.java b/Problemas/Grafos/SearchProblems/BFS,DFS/ConnectedCountry.java
deleted file mode 100644
index 53551c4..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/ConnectedCountry.java
+++ /dev/null
@@ -1,97 +0,0 @@
-//https://vjudge.net/problem/UVA-1223
-import java.util.*;
-import java.io.*;
-
-public class Main {
-    static ArrayList<Integer>[] adj;
-    static boolean[] state;
-    static int[] d;
-    public static void main(String[] args) {
-        Scanner sc = new Scanner();
-        PrintWriter pw = new PrintWriter(System.out);
-        int n=sc.nextInt();
-        int m=sc.nextInt();
-        adj=new ArrayList[n];
-        state=new boolean[n];
-        d=new int[n];
-        for (int i = 0; i < n; i++)
-            adj[i]=new ArrayList<>();
-        for (int i = 0; i < m; i++) {
-            int u =sc.nextInt();
-            int v=sc.nextInt();
-            addEdge(u,v);
-        }
-        int c=-1;
-        for (int i = 0; i < n; i++) {
-            if(!state[i]){
-                bfs(i);
-                c++;
-            }
-        }
-        System.out.println(c);
-
-    }
-    static void bfs(int s){
-        d[s]=0;
-        state[s]=true;
-        Queue<Integer> q=new LinkedList<>();
-        q.add(s);
-        while(!q.isEmpty()){
-            int u=q.poll();
-            for(int v:adj[u]){
-                if(!state[v]){
-                    d[v]=d[u]+1;
-                    state[v]=true;
-                    q.add(v);
-                }
-            }
-        }
-    }
-    static void addEdge(int u, int v){
-        adj[u].add(v);
-        adj[v].add(u);
-    }
-
-
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/Dominator.java b/Problemas/Grafos/SearchProblems/BFS,DFS/Dominator.java
deleted file mode 100644
index 0a2fe00..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/Dominator.java
+++ /dev/null
@@ -1,119 +0,0 @@
-//https://vjudge.net/problem/UVA-11902
-import java.util.*;
-import java.io.*;
-public class Main {
-    static int n;
-    static ArrayList<Integer>[] adj;
-    static PrintWriter out = new PrintWriter(System.out);
-    public static void main(String[] args) throws IOException {
-        Scanner sc = new Scanner();
-        int ti=sc.nextInt();
-        for (int times = 1; times <= ti; times++) {
-            n=sc.nextInt();
-            adj=new ArrayList[n];
-            for (int i = 0; i < n; i++)
-                adj[i]=new ArrayList<>();
-            for (int i = 0; i < n; i++)
-                for (int j = 0; j < n; j++) {
-                    int c = sc.nextInt();
-                    if (c == 1)
-                        adj[i].add(j);
-                }
-            out.println("Case " + times + ":");
-            printFastidio();
-            boolean[] state=bfs(0,-1);
-            out.print("|");
-            for (int i = 0; i < n; i++)
-                out.print(state[i] ? "Y|" : "N|");
-            out.println();
-            printFastidio();
-            for (int i = 1; i < n; i++) {
-                out.print("|");
-                boolean[] dom;
-                if(state[i]) {
-                    dom = bfs(0, i);
-                    for (int j = 0; j < n; j++)
-                        out.print((state[j] && !dom[j]) ? "Y|" : "N|");
-                }
-                else{
-                    for (int j = 0; j < n; j++)
-                        out.print("N|");
-                }
-                out.println();
-                printFastidio();
-            }
-        }
-        out.close();
-
-    }
-    static void printFastidio() {
-        out.print("+");
-        for (int i = 0; i < 2 * n - 1; i++)
-            out.print("-");
-        out.println("+");
-    }
-
-    static boolean[] bfs(int s,int skip){
-        boolean[] state=new boolean[n];
-        state[s]=true;
-        Queue<Integer> q=new LinkedList<>();
-        q.add(s);
-        while(!q.isEmpty()){
-            int u=q.poll();
-            for (int v:adj[u]){
-                if(!state[v]&&v!=skip){
-                    state[v]=true;
-                    q.add(v);
-                }
-            }
-        }
-        return state;
-    }
-
-
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char Char() throws IOException {
-            return (char) br.read();
-        }
-
-        char nextChar() {
-            return next().charAt(0);
-        }
-
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/Find the treasure.java b/Problemas/Grafos/SearchProblems/BFS,DFS/Find the treasure.java
deleted file mode 100644
index a3a96cc..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/Find the treasure.java	
+++ /dev/null
@@ -1,65 +0,0 @@
-//https://vjudge.net/problem/SPOJ-DIGOKEYS
-import java.util.*;
-import java.io.*;
-
-public class DIGOKEYS_FindTheTreasure {
-	static int n;
-	static ArrayList<Integer>[] adj;
-	static int[] pi;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		int t = Integer.parseInt(in.readLine());
-		for (int cases = 0; cases < t; cases++) {
-			n = Integer.parseInt(in.readLine());
-			adj = new ArrayList[n];
-			for (int i = 0; i < n; i++)
-				adj[i] = new ArrayList<>();
-			for (int i = 0; i < n - 1; i++) {
-				StringTokenizer st = new StringTokenizer(in.readLine());
-				st.nextToken();
-				while (st.hasMoreTokens()) {
-					adj[i].add(Integer.parseInt(st.nextToken()) - 1);
-				}
-				Collections.sort(adj[i]);
-			}
-			if (!bfs())
-				System.out.println(-1);
-			else {
-				StringBuffer ans = new StringBuffer();
-				int s = n - 1;
-				int c = 0;
-				while (s != 0) {
-					s = pi[s];
-					c++;
-					ans.insert(0, (s + 1) + " ");
-				}
-				System.out.println(c);
-				System.out.println(ans);
-			}
-		}
-
-	}
-
-	static boolean bfs() {
-		pi = new int[n];
-		boolean[] state = new boolean[n];
-		Queue<Integer> Q = new LinkedList<>();
-		pi[0] = -1;
-		state[0] = true;
-		Q.add(0);
-		while (!Q.isEmpty()) {
-			int u = Q.poll();
-			if (u == n - 1)
-				return true;
-			for (int v : adj[u]) {
-				if (!state[v]) {
-					pi[v] = u;
-					state[v] = true;
-					Q.add(v);
-				}
-			}
-		}
-		return false;
-	}
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/FindTheTreasure.java b/Problemas/Grafos/SearchProblems/BFS,DFS/FindTheTreasure.java
deleted file mode 100644
index d254833..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/FindTheTreasure.java
+++ /dev/null
@@ -1,90 +0,0 @@
-//https://vjudge.net/problem/SPOJ-DIGOKEYS
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-public class Main {
-    static ArrayList<Integer>[] adj;
-    static boolean[] state;
-    static int[] pi;
-    public static void main(String[] args)throws IOException {
-        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
-        int t=Integer.parseInt(bf.readLine());
-        for (int times = 0; times < t; times++) {
-            int n=Integer.parseInt(bf.readLine());
-            adj=new ArrayList[n+1];
-            pi=new int[n+1];
-            state=new boolean[n+1];
-            for (int i = 0; i < n+1; i++)
-                adj[i]=new ArrayList<>();
-
-            for (int i = 1; i < n; i++) {
-                String[] l1=bf.readLine().split(" ");
-                int m=Integer.parseInt(l1[0]);
-                for (int j = 1; j <=m ; j++)
-                    adj[i].add(Integer.parseInt(l1[j]));
-            }
-            if(!bfs(1,n))
-                System.out.println(-1);
-            else {
-                StringBuffer ans = new StringBuffer();
-                int s = n ;
-                int c = 0;
-                while (s > 0) {
-                    s = pi[s];
-                    if(s<1)
-                        break;
-                    c++;
-                    ans.insert(0, (s ) + " ");
-                }
-                System.out.println(c);
-                System.out.println(ans);
-            }
-            System.out.println();
-        }
-    }
-
-    static boolean bfs(int s, int t) {
-        state[s] = true;
-        pi[s]=-1;
-        int time=0;
-        TreeSet<Key> Q = new TreeSet<>();
-        Q.add(new Key(s,time));
-        while (!Q.isEmpty()) {
-            time++;
-            int u = Q.pollFirst().n;
-            if(u==t)
-                return true;
-            for(int v : adj[u]) {
-                if (!state[v]) {
-                    state[v] =true;
-                    pi[v]=u;
-                    Q.add(new Key(v,time));
-                }
-            }
-            state[u] = true;
-        }
-        return false;
-    }
-    private static class Key implements Comparable<Key>{
-        int n;
-        int time;
-        Key(int v,int t){
-            n=v;
-            time=t;
-        }
-        public int compareTo(Key o){
-            if(time<o.time)
-                return -1;
-            if(time>o.time)
-                return 1;
-            if(n<o.n)
-                return -1;
-            if(n>o.n)
-                return 1;
-            return 0;
-        }
-
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/HotelQueries.cpp b/Problemas/Grafos/SearchProblems/BFS,DFS/HotelQueries.cpp
deleted file mode 100644
index ad4e3c7..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/HotelQueries.cpp
+++ /dev/null
@@ -1,98 +0,0 @@
-//https://cses.fi/alon/task/1143
-using namespace std;
-#include <bits/stdc++.h>
-#include <iostream>
-#include <vector>
-#include <unordered_map>
-#include <unordered_set>
-#include <map>
-#include <set>
-#include <algorithm>
-#include <climits>
-#include <cmath>
-#include <math.h>
-#include <iomanip>
-#include <deque>
-#include <queue>
-#include <stack>
-#include <string>
-#include <utility>
-#include <numeric>
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define MAXN 200001
-
-int n, t[4 * MAXN];
-int A[MAXN];
-
-void build(int a[], int v = 1, int tl = 0, int tr = n - 1)
-{
-    if (tl == tr)
-        t[v] = a[tl];
-    else
-    {
-        int tm = (tl + tr) >> 1;
-        build(a, v << 1, tl, tm);
-        build(a, (v << 1) + 1, tm + 1, tr);
-        t[v] = max(t[v << 1], t[(v << 1) + 1]);
-    }
-}
-
-void update(int v, int tl, int tr, int pos, int new_val)
-{
-    if (tl == tr)
-        t[v] = new_val;
-    else
-    {
-        int tm = (tl + tr) >> 1;
-        if (pos <= tm)
-            update(v << 1, tl, tm, pos, new_val);
-        else
-            update((v << 1) + 1, tm + 1, tr, pos, new_val);
-        t[v] = max(t[v << 1], t[(v << 1) + 1]);
-    }
-}
-
-int dfs(int q, int v, int l, int r)
-{
-    if (l == r)
-    {
-        update(1, 0, n - 1, l, t[v] - q);
-        return l + 1;
-    }
-    int left = v << 1;
-    int right = (v << 1) + 1;
-    int mid = (l + r) >> 1;
-    if (t[left] >= q)
-        return dfs(q, left, l, mid);
-    return dfs(q, right, mid + 1, r);
-}
-
-void solve()
-{
-    int m;
-    cin >> n >> m;
-    fori(i, 0, n)
-            cin >>
-        A[i];
-    build(A);
-    while (m--)
-    {
-        int val;
-        cin >> val;
-        if (t[1] < val)
-            cout << 0;
-        else
-            cout << dfs(val, 1, 0, n - 1);
-        cout << " ";
-    }
-    cout << ln;
-}
-
-int main()
-{
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    solve();
-    return 0;
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/KittenOnATree.cpp b/Problemas/Grafos/SearchProblems/BFS,DFS/KittenOnATree.cpp
deleted file mode 100644
index 8f0ccf9..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/KittenOnATree.cpp
+++ /dev/null
@@ -1,78 +0,0 @@
-//https://open.kattis.com/problems/kitten
-using namespace std;
-#include <bits/stdc++.h>
-
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-
-vector<string> split(string s, char regex) {
-    int n = s.size();
-    vector<string> ans;
-    string t;
-    for (int i = 0; i < n; i++) {
-        if (s[i] == regex) {
-            ans.push_back(t);
-            t.clear();
-            continue;
-        }
-        t += s[i];
-    }
-    ans.push_back(t);
-    return ans;
-}
-
-unordered_map<int, vector<int> > adj;
-unordered_map<int, int> pi;
-
-void dfs(int u) {
-    for (const auto &v: adj[u]) {
-        pi[v] = u;
-        dfs(v);
-    }
-}
-
-
-void solve() {
-    int K, R;
-    cin >> K;
-    bool cond = true;
-    cin.ignore();
-    while (true) {
-        string s;
-        getline(cin, s);
-        vector<string> nums = split(s, ' ');
-        int b = stoi(nums[0]);
-        if (cond) {
-            R = b;
-            cond = false;
-        }
-        if (b == -1)
-            break;
-        const int n = nums.size();
-        fori(i, 1, n) {
-            int a = stoi(nums[i]);
-            adj[a].push_back(b);
-        }
-    }
-    pi[K] = -1;
-    dfs(K);
-    vector<int> ans;
-    while (R != K) {
-        ans.push_back(R);
-        R = pi[R];
-    }
-    ans.push_back(K);
-    reverse(ans.begin(), ans.end());
-    for (const auto &i: ans)
-        cout << i << " ";
-    cout << ln;
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    //freopen("file.in", "r", stdin);
-    //freopen("file.out", "w", stdout);
-    solve();
-    return 0;
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/Knight Moves.java b/Problemas/Grafos/SearchProblems/BFS,DFS/Knight Moves.java
deleted file mode 100644
index 1cfdef4..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/Knight Moves.java	
+++ /dev/null
@@ -1,112 +0,0 @@
-//https://vjudge.net/problem/UVA-439
-import java.util.*;
-  public class Main{
-    public static void main(String args[]){
-        Main grafo=new Main();
-        for(int i=0;i<8;i++){
-            for(int j = 1; j < 9; j++) {
-                String s=(char)('a'+i)+""+j;
-                grafo.addVertex(s);
-            }
-        }
-        for(int i=0;i<8;i++){
-            for(int j = 1; j < 9; j++) {
-                String s=(char)('a'+i)+""+j;
-                grafo.addEdge(s,""+(char)('a'+i+1)+(j+2));
-                grafo.addEdge(s,""+(char)('a'+i+2)+(j+1));
-                grafo.addEdge(s,""+(char)('a'+i+2)+(j-1));
-                grafo.addEdge(s,""+(char)('a'+i+1)+(j-2));
-                grafo.addEdge(s,""+(char)('a'+i-1)+(j-2));
-                grafo.addEdge(s,""+(char)('a'+i-2)+(j-1));
-                grafo.addEdge(s,""+(char)('a'+i-2)+(j+1));
-                grafo.addEdge(s,""+(char)('a'+i-1)+(j-2));
-            }
-        }
-        Scanner tec=new Scanner(System.in);
-        while (tec.hasNext()){
-            String s=tec.nextLine();
-            String[] ss=s.split(" ");
-            System.out.println("To get from "+ss[0]+" to "+ss[1]+" takes "+(grafo.shortestPath(ss[0],ss[1]).size()-1)+" knight moves.");
-        }
-    }
-    private int n, m;
-    private Map<String, List<String>> adjList;
-
-    public Main() {
-        n = 0;
-        m = 0;
-        adjList = new HashMap<String, List<String>>();
-    }
-    public Map<String,List<String>> getAdjList(){
-        return adjList;
-    }
-    public int size(){
-        return n;
-    }
-    public Map<String, String> bfs(String s) {
-        Map<String,Integer> d = new HashMap<>();
-        Map<String,String> pi = new HashMap<>();
-        Map<String,Character> state = new HashMap<>();
-        d.put(s,0);
-        pi.put(s,null);
-        state.put(s,'D');
-        Queue<String> Q = new LinkedList<>();
-        Q.add(s);
-        while (!Q.isEmpty()) {
-            String u = Q.poll();
-            for(String v : adjList.get(u))
-                if (state.get(v) == null) {
-                    d.put(v,d.get(u)+1);
-                    pi.put(v,u);
-                    state.put(v,'D');
-                    Q.add(v);
-                }
-            state.put(u,'E');
-        }
-        return pi;
-    }
-
-
-    public List<String> shortestPath(String s, String t) {
-        Map<String,String> pi = bfs(s);
-        if (pi.get(t) == null && !Objects.equals(t, s)) return null;
-        List<String> path = new LinkedList<String>();
-        while (t!=null) {
-            path.add(0, t);
-            t = pi.get(t);
-        }
-        return path;
-    }
-    public boolean addVertex(String vertex) {
-        if (adjList.get(vertex) != null)
-            return false;
-        adjList.put(vertex, new LinkedList<String>());
-        n++;
-        return true;
-    }
-
-
-
-    public boolean addEdge(String a, String b) {
-        if (adjList.get(a) == null)
-            return false;
-        if (adjList.get(b) == null)
-            return false;
-        adjList.get(a).add(b);
-        adjList.get(b).add(a);
-        m++;
-        return true;
-    }
-
-
-
-
-    public String toString() {
-        String s = "";
-        for (String v : adjList.keySet()) {
-            s += "<" + v + ", " + adjList.get(v) + "\n";
-        }
-        return s;
-    }
-
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/Lexicographically Minimal Shortest Path.java b/Problemas/Grafos/SearchProblems/BFS,DFS/Lexicographically Minimal Shortest Path.java
deleted file mode 100644
index 19570c4..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/Lexicographically Minimal Shortest Path.java	
+++ /dev/null
@@ -1,160 +0,0 @@
-//https://codeforces.com/gym/102569/problem/D
-import java.util.*;
-import java.io.*;
-
-public class Main {
-    static boolean[] state;
-    static PrintWriter pw = new PrintWriter(System.out);
-    static int[] pi;
-    static int[] d;
-    static int n;
-    static String[] cost;
-    static ArrayList<Edge>[] adj;
-    public static void main(String[] args) {
-        Scanner sc = new Scanner();
-
-        n=sc.nextInt();
-        int m=sc.nextInt();
-        d=new int[n];
-        state=new boolean[n];
-        adj=new ArrayList[n];
-        pi=new int[n];
-        Arrays.fill(pi,-1);
-        cost=new String[n];
-
-        for (int i = 0; i < n; i++) 
-            adj[i]=new ArrayList<>();
-        for (int i = 0; i < m; i++) {
-            int u=sc.nextInt()-1;
-            int v=sc.nextInt()-1;
-            char w=sc.next().charAt(0);
-            adj[u].add(new Edge(v,w));
-            adj[v].add(new Edge(u,w));
-        }
-        ans();
-        pw.close();
-    }
-    static void ans(){
-        bfs();
-        boolean b=true;
-        LinkedList<Integer> q=new LinkedList<>();
-        q.add(0);
-        String s="";
-        while (b){
-            char min='z';
-            for (int u: q)
-                for (Edge v: adj[u])
-                    if(d[v.a]+1==d[u])
-                        min= (char)Math.min(min,v.w);
-            LinkedList<Integer> qq=new LinkedList<>();
-            for (int u:q)
-                for (Edge v:adj[u])
-                    if(d[v.a]+1==d[u]){
-                        if(pi[v.a]==-1&&v.w==min) {
-                            pi[v.a] = u;
-                            qq.add(v.a);
-                            if (v.a == n - 1)
-                                b = false;
-                        }
-                    }
-            s+=min;
-            q=qq;
-
-        }
-        int t=n-1;
-        ArrayList<Integer> path= new ArrayList<>();
-        path.add(n-1);
-        while (t>0){
-            t=pi[t];
-            if(t==-1)
-                break;
-            path.addFirst((t));
-        }
-        pw.println(path.size()-1);
-        for (int i:path)
-            pw.print((i+1)+" ");
-        pw.println();
-        pw.println(s);
-    }
-    static void bfs() {
-        d[n-1]=0;
-        state[n-1]=true;
-        Queue<Integer> q=new LinkedList<>();
-        q.add(n-1);
-        while (!q.isEmpty()){
-            int u=q.poll();
-            for (Edge v:adj[u]){
-                if(!state[v.a]){
-                    state[v.a]=true;
-                    d[v.a]=d[u]+1;
-                    q.add(v.a);
-                }
-            }
-        }
-    }
-
-
-
-    private static class Edge implements Comparable<Edge>{
-        int a;
-        char w;
-        public Edge(int u, char c){
-            a=u;
-            w=c;
-        }
-        public int compareTo(Edge o){
-            if(w<o.w)
-                return -1;
-            if(w>o.w)
-                return 1;
-            if(a<o.a)
-                return -1;
-            if(a>o.a)
-                return 1;
-            return 0;
-        }
-        public String toString() {
-            return "<"+a+", "+w+">";
-        }
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/Longest Path In a Tree.java b/Problemas/Grafos/SearchProblems/BFS,DFS/Longest Path In a Tree.java
deleted file mode 100644
index 352858e..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/Longest Path In a Tree.java	
+++ /dev/null
@@ -1,51 +0,0 @@
-/*https://vjudge.net/problem/SPOJ-PT07Z*/
-
-import java.util.*;
-import java.io.*;
-
-public class LongestPathInATree {
-	static int n;
-	static ArrayList<Integer>[] adj;
-	static boolean[] visitado;
-	static int max_prof, max_ver;
-
-	public static void main(String[] args) throws IOException {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		n = Integer.parseInt(in.readLine());
-		adj = new ArrayList[n];
-		for (int i = 0; i < n; i++)
-			adj[i] = new ArrayList<>();
-		for (int i = 0; i < n - 1; i++) {
-			StringTokenizer st = new StringTokenizer(in.readLine());
-			int a = Integer.parseInt(st.nextToken());
-			int b = Integer.parseInt(st.nextToken());
-			a--;
-			b--;
-			adj[a].add(b);
-			adj[b].add(a);
-		}
-		System.out.println(solve());
-	}
-
-	static int solve() {
-		visitado = new boolean[n];
-		max_prof = 0;
-		max_ver = 0;
-		dfs(0, 0);
-		max_prof = 0;
-		Arrays.fill(visitado, false);
-		dfs(max_ver, 0);
-		return max_prof;
-	}
-
-	static void dfs(int v, int dist) {
-		visitado[v] = true;
-		if (dist > max_prof) {
-			max_prof = dist;
-			max_ver = v;
-		}
-		for (int u : adj[v])
-			if (!visitado[u])
-				dfs(u, dist + 1);
-	}
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/Message Route.java b/Problemas/Grafos/SearchProblems/BFS,DFS/Message Route.java
deleted file mode 100644
index 2e7fdac..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/Message Route.java	
+++ /dev/null
@@ -1,104 +0,0 @@
-//https://vjudge.net/problem/CSES-1667
-import java.util.*;
-import java.io.*;
-
-public class Main {
-    static ArrayList<Integer>[] adj;
-    static boolean[] state;
-    static int[] d,pi;
-    public static void main(String[] args) {
-        Scanner sc = new Scanner();
-        PrintWriter pw = new PrintWriter(System.out);
-        int n=sc.nextInt();
-        int m=sc.nextInt();
-        adj=new ArrayList[n];
-        state=new boolean[n];
-        d=new int[n];
-        pi=new int[n];
-        Arrays.fill(pi,-1);
-        for (int i = 0; i < n; i++)
-            adj[i]=new ArrayList<>();
-        for (int i = 0; i < m; i++) {
-            int u =sc.nextInt()-1;
-            int v=sc.nextInt()-1;
-            addEdge(u,v);
-        }
-        bfs(0);
-        if(pi[n-1]==-1){
-            System.out.println("IMPOSSIBLE");
-            return;
-        }
-        LinkedList<Integer> list=new LinkedList<>();
-        for (int v=n-1;v!=0;v=pi[v])
-            list.addFirst(v);
-        pw.println(list.size()+1);
-        pw.print(1);
-        for(int i : list)
-            pw.print(" "+(i+1));
-        pw.close();
-    }
-    static void bfs(int s){
-        d[s]=0;
-        state[s]=true;
-        Queue<Integer> q=new LinkedList<>();
-        q.add(s);
-        while(!q.isEmpty()){
-            int u=q.poll();
-            for(int v:adj[u]){
-                if(!state[v]){
-                    pi[v]=u;
-                    d[v]=d[u]+1;
-                    state[v]=true;
-                    q.add(v);
-                }
-            }
-        }
-    }
-    static void addEdge(int u, int v){
-        adj[u].add(v);
-        adj[v].add(u);
-    }
-
-
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/MontescoVsCapuleto.java b/Problemas/Grafos/SearchProblems/BFS,DFS/MontescoVsCapuleto.java
deleted file mode 100644
index 9ac1a35..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/MontescoVsCapuleto.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*https://vjudge.net/problem/UVA-10505*/
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-public class MontescoVsCapuleto{
-    static int[] pi;
-    static int n, m;
-    static LinkedList<Integer>[] adjList;
-    static char[] state;
-    static int numero;
-    static boolean[] grupo;
-
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
-        int t=Integer.parseInt(bf.readLine());
-        for (int i = 0; i < t; i++) {
-            bf.readLine();
-            int n=Integer.parseInt(bf.readLine());
-            adjList=new LinkedList[n];
-            state= new char[n];
-            grupo=new boolean[n];
-            pi=new int[n];
-            numero=0;
-            Arrays.fill(state,'N');
-            for (int j = 0; j < n; j++) {
-                adjList[j]=new LinkedList<>();
-            }
-            for (int j = 0; j < n; j++) {
-                String[] l1=bf.readLine().split(" ");
-                int k=Integer.parseInt(l1[0]);
-                for (int l = 1; l < k+1; l++) {
-                    int b=Integer.parseInt(l1[l]);
-                    if(b>n)
-                        continue;
-                    addEdge(j,b-1);
-                }
-            }
-            for (int j = 0; j < n; j++) {
-                if(state[j]=='N')
-                    bfs(j);
-            }
-            //System.out.println(Arrays.toString(grupo));
-            System.out.println(numero);
-            //System.out.println(Arrays.toString(adjList));
-        }
-    }
-
-    static void bfs(int s) {
-        state[s]='D';
-        pi[s]=-1;
-        grupo[s]=true;
-        int grupo1=0;
-        int grupo2=0;
-        boolean ciclo=false;
-        Queue<Integer> Q = new LinkedList<Integer>();
-        Q.add(s);
-        while (!Q.isEmpty()) {
-            int u = Q.poll();
-            if(grupo[u])
-                grupo1++;
-            else
-                grupo2++;
-            for (int v : adjList[u]) {
-                if (state[v] == 'N') {
-                    state[v] = 'D';
-                    grupo[v] = !grupo[u];
-                    Q.add(v);
-                    pi[v] = u;
-                }
-                if (state[v] == 'D')
-                    if(pi[v]!=u)
-                        if(grupo[v]==grupo[u])
-                            ciclo=true;
-            }
-            state[u] = 'E';
-        }
-        if(!ciclo)
-            numero+=Math.max(grupo1,grupo2);
-    }
-
-    static void addEdge(int a, int b) {
-        adjList[a].add(b);
-        adjList[b].add(a);
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/PoliceStations.java b/Problemas/Grafos/SearchProblems/BFS,DFS/PoliceStations.java
deleted file mode 100644
index 93b4654..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/PoliceStations.java
+++ /dev/null
@@ -1,64 +0,0 @@
-//https://codeforces.com/problemset/problem/796/D
-import java.util.*;
-import java.awt.Point;
-import java.io.*;
-
-public class PoliceStations {
-	static int n;
-	static ArrayList<Point>[] adj;
-	static Queue<Integer> Q;
-	static boolean[] visited;
-	static boolean[] edges;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st = new StringTokenizer(in.readLine());
-		PrintWriter out = new PrintWriter(System.out);
-		n = Integer.parseInt(st.nextToken());
-		int k = Integer.parseInt(st.nextToken());
-		st.nextElement();
-		Q = new LinkedList<>();
-		visited = new boolean[n];
-		st = new StringTokenizer(in.readLine());
-		for (int i = 0; i < k; i++) {
-			int p = Integer.parseInt(st.nextToken()) - 1;
-			Q.add(p);
-			visited[p] = true;
-		}
-		adj = new ArrayList[n];
-		edges = new boolean[n - 1];
-		for (int i = 0; i < n; i++)
-			adj[i] = new ArrayList<>();
-		for (int i = 0; i < n - 1; i++) {
-			st = new StringTokenizer(in.readLine());
-			int a = Integer.parseInt(st.nextToken()) - 1;
-			int b = Integer.parseInt(st.nextToken()) - 1;
-			adj[a].add(new Point(b, i));
-			adj[b].add(new Point(a, i));
-		}
-		bfs();
-		List<Integer> ans = new ArrayList<>();
-		for (int i = 0; i < edges.length; i++)
-			if (!edges[i])
-				ans.add(i + 1);
-		out.println(ans.size());
-		ans.forEach(x -> out.print(x + " "));
-		out.flush();
-	}
-
-	static void bfs() {
-		while (!Q.isEmpty()) {
-			int u = Q.poll();
-			for (Point ee : adj[u]) {
-				int v = ee.x;
-				int index = ee.y;
-				if (!visited[v]) {
-					visited[v] = true;
-					Q.add(v);
-					edges[index] = true;
-				}
-			}
-		}
-	}
-
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/SecretChamberatMountRushmore.java b/Problemas/Grafos/SearchProblems/BFS,DFS/SecretChamberatMountRushmore.java
deleted file mode 100644
index 0966621..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/SecretChamberatMountRushmore.java
+++ /dev/null
@@ -1,73 +0,0 @@
-//https://vjudge.net/problem/Kattis-secretchamber
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.Queue;
-
-class SecretLetters {
-    static HashMap<Character,LinkedList<Character>> adj;
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf= new BufferedReader(new InputStreamReader(System.in));
-        adj=new HashMap<>();
-        String[] l1=bf.readLine().split(" ");
-        int n=Integer.parseInt(l1[0]);
-        int m=Integer.parseInt(l1[1]);
-        for (int i=0;i<n;i++){
-            String l2=bf.readLine();
-            addEdge(l2.charAt(0),l2.charAt(2));
-        }
-        //System.out.println(adj);
-        for (int i = 0; i < m; i++) {
-            String[] l2=bf.readLine().split(" ");
-            try{
-                if(solve(l2[0],l2[1]))
-                    System.out.println("yes");
-                else
-                    System.out.println("no");
-            }catch (NullPointerException e) {
-                System.out.println("no");
-            }
-        }
-    }
-
-    static boolean solve(String a, String b){
-        if(a.length()!=b.length())
-            return false;
-        for (int i = 0; i < a.length(); i++) {
-            if(a.charAt(i)==b.charAt(i))
-                continue;
-            if(!bfs(a.charAt(i),b.charAt(i)))
-                return false;
-        }
-        return true;
-    }
-    static void addEdge(char a, char b){
-        if (adj.get(a) == null)
-            adj.put(a, new LinkedList<>());
-        if (adj.get(b) == null)
-            adj.put(b, new LinkedList<>());
-        adj.get(a).add(b);
-    }
-    static boolean bfs(char s,char t) {
-        HashMap<Character,Character> state=new HashMap<>();
-        state.put(s,'D');
-        Queue<Character> Q = new LinkedList<>();
-        Q.add(s);
-        while (!Q.isEmpty()) {
-            char u = Q.poll();
-            if(u==t) {
-                return true;
-            }
-            for(char v : adj.get(u))
-                if (state.get(v)==null) {
-                    state.put(v,'D');
-                    Q.add(v);
-                }
-            state.put(u,'E');
-        }
-        return false;
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/TornToPieces.java b/Problemas/Grafos/SearchProblems/BFS,DFS/TornToPieces.java
deleted file mode 100644
index df59ccd..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/TornToPieces.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/* https://open.kattis.com/problems/torn2pieces */
-
-import java.io.*;
-import java.util.*;
-
-public class TornToPieces {
-    static HashMap<String, List<String>> adjList;
-    static Map<String,Integer> d = new HashMap<>();
-    static Map<String,String> pi = new HashMap<>();
-    static Map<String,Character> state = new HashMap<>();
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
-        int n=Integer.parseInt(bf.readLine());
-        adjList=new HashMap<>();
-        for (int i = 0; i < n; i++) {
-            String[] l1=bf.readLine().split(" ");
-            String a=l1[0];
-            for (int j = 1; j < l1.length; j++) {
-                addEdge(a,l1[j]);
-            }
-        }
-        String[] l2=bf.readLine().split(" ");
-        if(adjList.get(l2[0])==null||adjList.get(l2[1])==null){
-            System.out.println("no route found");
-            return;
-        }
-        LinkedList<String> res=shortestPath(l2[0],l2[1]);
-        if(res==null)
-            System.out.println("no route found");
-        else{
-            StringBuilder s= new StringBuilder();
-            for(String i: res)
-                s.append(i).append(" ");
-            System.out.println(s);
-        }
-    }
-    public static void bfs(String s) {
-        d.put(s,0);
-        pi.put(s,null);
-        state.put(s,'D');
-        Queue<String> Q = new LinkedList<>();
-        Q.add(s);
-        while (!Q.isEmpty()) {
-            String u = Q.poll();
-            for(String v : adjList.get(u))
-                if (state.get(v) == null) {
-                    d.put(v,d.get(u)+1);
-                    pi.put(v,u);
-                    state.put(v,'D');
-                    Q.add(v);
-                }
-            state.put(u,'E');
-        }
-    }
-
-    static LinkedList<String> shortestPath(String t, String s) {
-        bfs(s);
-        if (pi.get(t) == null && !Objects.equals(t, s)) return null;
-        LinkedList<String> path = new LinkedList<>();
-        while (t!=null) {
-            path.add(t);
-            t = pi.get(t);
-        }
-        return path;
-    }
-    static void addEdge(String a, String b) {
-        adjList.computeIfAbsent(a, k -> new LinkedList<String>());
-        adjList.computeIfAbsent(b, k -> new LinkedList<String>());
-        adjList.get(a).add(b);
-        adjList.get(b).add(a);
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/Trapped in the Witch's Labyrinth.cpp b/Problemas/Grafos/SearchProblems/BFS,DFS/Trapped in the Witch's Labyrinth.cpp
deleted file mode 100644
index 69e1ae6..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/Trapped in the Witch's Labyrinth.cpp	
+++ /dev/null
@@ -1,114 +0,0 @@
-//https://codeforces.com/contest/2034/problem/C
-#include <iostream>
-#include <vector>
-#include <unordered_map>
-#include <queue>
-using namespace std;
-
-struct pair_hash {
-    size_t operator()(const pair<int, int> &p) const {
-        return hash<int>()(p.first) ^ (hash<int>()(p.second) << 1)*31;
-    }
-};
-
-unordered_map<pair<int, int>, vector<pair<int, int>>, pair_hash> adj;
-queue<pair<int, int>> Q;
-vector<vector<bool>> visited;
-vector<vector<char>> grid;
-
-const vector<int> dx = {-1, 1, 0, 0};
-const vector<int> dy = {0, 0, -1, 1};
-
-void addEdge(pair<int, int> from, pair<int, int> to) {
-    adj[to].push_back(from);
-}
-
-
-void bfs() {
-    while (!Q.empty()) {
-        pair<int, int> e = Q.front();
-        Q.pop();
-        auto it = adj.find(e);
-        if (it != adj.end()) {
-            const vector<pair<int, int>> &neigh = it->second;
-            for (const auto &p : neigh) {
-                int x = p.first, y = p.second;
-                if (!visited[x][y] && grid[x][y] != '?') {
-                    visited[x][y] = true;
-                    Q.push({x, y});
-                }
-            }
-        }
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-
-    int t; 
-    cin >> t;
-
-    while (t--) {
-        int n, m;
-        cin >> n >> m;
-
-        grid.assign(n, vector<char>(m));
-        visited.assign(n, vector<bool>(m, false));
-        adj.clear();
-
-        for (int i = 0; i < n; i++) {
-            string s;
-            cin >> s;
-            for (int j = 0; j < m; j++) {
-                grid[i][j] = s[j];
-                char c = grid[i][j];
-                if (c == '?') continue;
-                pair<int, int> u = {i, j};
-                if (c == 'D' && i + 1 < n) addEdge(u, {i + 1, j});
-                else if (c == 'U' && i - 1 >= 0) addEdge(u, {i - 1, j});
-                else if (c == 'R' && j + 1 < m) addEdge(u, {i, j + 1});
-                else if (c == 'L' && j - 1 >= 0) addEdge(u, {i, j - 1});
-            }
-        }
-
-        for (int i = 0; i < n; i++) {
-            if (!visited[i][0] && grid[i][0] == 'L') {
-                visited[i][0] = true;
-                Q.push({i, 0});
-            }
-            if (!visited[i][m - 1] && grid[i][m - 1] == 'R') {
-                visited[i][m - 1] = true;
-                Q.push({i, m - 1});
-            }
-        }
-        for (int j = 0; j < m; j++) {
-            if (!visited[0][j] && grid[0][j] == 'U') {
-                visited[0][j] = true;
-                Q.push({0, j});
-            }
-            if (!visited[n - 1][j] && grid[n - 1][j] == 'D') {
-                visited[n - 1][j] = true;
-                Q.push({n - 1, j});
-            }
-        }
-        bfs();
-        int ans = 0;
-        for (int i = 0; i < n; i++) {
-            for (int j = 0; j < m; j++) {
-                if (visited[i][j]) continue;
-                bool cond = false;
-                for (int k = 0; k < 4; k++) {
-                    int ni = i + dx[k], nj = j + dy[k];
-                    if (ni >= 0 && ni < n && nj >= 0 && nj < m && !visited[ni][nj]) {
-                        cond = true;
-                        break;
-                    }
-                }
-                if (cond) ans++;
-            }
-        }
-        cout << ans << "\n";
-    }
-    return 0;
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/TwoFriends.java b/Problemas/Grafos/SearchProblems/BFS,DFS/TwoFriends.java
deleted file mode 100644
index 22b5856..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/TwoFriends.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/* https://codeforces.com/problemset/problem/1969/A */
-import java.io.*;
-import java.util.*;
-
-public class TwoFriends {
-    static HashSet<Integer>[] adjList;
-    static boolean[] state;
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
-        int t=Integer.parseInt(bf.readLine());
-        for (int times = 0; times < t; times++) {
-            int n=Integer.parseInt(bf.readLine());
-            adjList=new HashSet[n+1];
-            state=new boolean[n+1];
-            for (int i = 1; i <= n; i++)
-                adjList[i]=new HashSet<>();
-            String[] l1=bf.readLine().split(" ");
-            for (int i = 1; i <=n ; i++) {
-                int a=Integer.parseInt(l1[i-1]);
-                addEdge(i,a);
-            }
-            TreeSet<Integer> ans= new TreeSet<>();
-            boolean f=false;
-            for (int i = 1; i <=n ; i++) {
-                if(!state[i]){
-                    int a=bfs(i);
-                    if(a==2){
-                        System.out.println(2);
-                        f=true;
-                        break;
-                    }
-                    ans.add(a);
-                }
-            }
-            if(!f)
-                System.out.println(ans.pollFirst());
-        }
-    }
-    static int bfs(int s) {
-        state[s] = true;
-        Queue<Integer> Q = new LinkedList<Integer>();
-        Q.add(s);
-        while (!Q.isEmpty()) {
-            int u = Q.poll();
-            for(int v : adjList[u]) {
-                if(adjList[v].contains(u))
-                    return 2;
-                if (!state[v]) {
-                    state[v] =true;
-                    Q.add(v);
-                }
-            }
-            state[u] = true;
-        }
-        return 3;
-    }
-    static void addEdge(int a, int b){
-        adjList[a].add(b);
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/WheresMyInternet.java b/Problemas/Grafos/SearchProblems/BFS,DFS/WheresMyInternet.java
deleted file mode 100644
index dc39999..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/WheresMyInternet.java
+++ /dev/null
@@ -1,109 +0,0 @@
-//https://open.kattis.com/problems/wheresmyinternet
-import java.io.*;
-import java.util.*;
-
-public class WheresMyInternet {
-	static int n;
-	static ArrayList<Integer>[] adj;
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		PrintWriter out = new PrintWriter(System.out);
-		n = in.nextInt();
-		int m = in.nextInt();
-		adj = new ArrayList[n];
-		for (int i = 0; i < n; i++)
-			adj[i] = new ArrayList<>();
-		for (int i = 0; i < m; i++) {
-			int a = in.nextInt() - 1;
-			int b = in.nextInt() - 1;
-			adj[a].add(b);
-			adj[b].add(a);
-		}
-		boolean[] visited = new boolean[n];
-		dfs(0, visited);
-		boolean cond = true;
-		for (int i = 0; i < visited.length; i++)
-			if (!visited[i]) {
-				out.println(i + 1);
-				cond = false;
-			}
-		if (cond)
-			out.println("Connected");
-		out.flush();
-
-	}
-
-	static void dfs(int s, boolean[] visited) {
-		Stack<Integer> S = new Stack<>();
-		S.push(s);
-		visited[s] = true;
-		while (!S.isEmpty()) {
-			int u = S.pop();
-			for (int v : adj[u]) {
-				if (!visited[v]) {
-					visited[v] = true;
-					S.push(v);
-				}
-			}
-		}
-
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-
-}
diff --git a/Problemas/Grafos/SearchProblems/BFS,DFS/WordTransformation.java b/Problemas/Grafos/SearchProblems/BFS,DFS/WordTransformation.java
deleted file mode 100644
index a39c0ce..0000000
--- a/Problemas/Grafos/SearchProblems/BFS,DFS/WordTransformation.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/* https://vjudge.net/problem/UVA-429 */
-import java.util.*;
-import java.io.*;
-
-public class Main {
-	static int n, m;
-	static HashMap<String, HashSet<String>> adj;
-
-	public static void main(String[] args) throws IOException {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		int t = Integer.parseInt(in.readLine());
-		String line = in.readLine();
-		for (int i = 0; i < t; i++) {
-			adj = new HashMap<>();
-			HashSet<String> dicc = new HashSet<>();
-			while (true) {
-				String word = in.readLine();
-				if (word.equals("*"))
-					break;
-				dicc.add(word);
-			}
-			connectVertex(dicc);
-			while (true) {
-				String queri = in.readLine();
-				if (queri == null || queri.isEmpty())
-					break;
-				StringTokenizer st = new StringTokenizer(queri, " ");
-				String a = st.nextToken();
-				String b = st.nextToken();
-				System.out.println(a + " " + b + " " + bfs(a, b));
-			}
-			if (i != t - 1)
-				System.out.println();
-		}
-	}
-
-	static void connectVertex(HashSet<String> dicc) {
-		for (String i : dicc)
-			for (String j : dicc)
-				if (sePuede(i, j))
-					addEdge(i, j);
-	}
-
-	static boolean sePuede(String a, String b) {
-		if (a.equals(b))
-			return false;
-		if (a.length() != b.length())
-			return false;
-		int cambios = 0;
-		for (int i = 0; i < a.length(); i++) {
-			if (a.charAt(i) != b.charAt(i))
-				cambios++;
-			if (cambios > 1)
-				return false;
-		}
-		return true;
-	}
-
-	static int bfs(String s, String t) {
-		if (s.equals(t))
-			return 0;
-		HashMap<String, Integer> d = new HashMap<>();
-		HashMap<String, String> pi = new HashMap<>();
-		HashMap<String, Boolean> visitado = new HashMap<>();
-		d.put(s, 0);
-		pi.put(s, s);
-		visitado.put(s, true);
-		Queue<String> Q = new LinkedList<>();
-		Q.add(s);
-		while (!Q.isEmpty()) {
-			String u = Q.poll();
-			for (String v : adj.get(u))
-				if (visitado.get(v) == null) {
-					d.put(v, d.get(u) + 1);
-					pi.put(v, u);
-					visitado.put(v, true);
-					Q.add(v);
-				}
-		}
-		List<String> path = new LinkedList<String>();
-		while (t != s) {
-			path.add(t);
-			t = pi.get(t);
-		}
-		return path.size();
-	}
-
-	static void addEdge(String a, String b) {
-		if (adj.get(a) == null)
-			adj.put(a, new HashSet<String>());
-		if (adj.get(b) == null)
-			adj.put(b, new HashSet<String>());
-		adj.get(a).add(b);
-		adj.get(b).add(a);
-
-	}
-}
diff --git a/Problemas/Grafos/SearchProblems/Bellmand-Ford/GetShorty.java b/Problemas/Grafos/SearchProblems/Bellmand-Ford/GetShorty.java
deleted file mode 100644
index 75e1e37..0000000
--- a/Problemas/Grafos/SearchProblems/Bellmand-Ford/GetShorty.java
+++ /dev/null
@@ -1,94 +0,0 @@
-//https://open.kattis.com/problems/getshorty
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.text.DecimalFormat;
-import java.util.HashMap;
-import java.util.TreeSet;
-
-class Main {
-    static final int INF = 2147483647;
-    static ArrayList<Edge>[] adjList;
-    static char[] state;
-    static double[] d;
-    static int n;
-    static String s;
-    static int[] pi;
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
-        while(true){
-            String[] l1=bf.readLine().split(" ");
-            n=Integer.parseInt(l1[0]);
-            int m=Integer.parseInt(l1[1]);
-            if(n==0&&m==0)
-                break;
-            state=new char[n];
-            DecimalFormat formato = new DecimalFormat("#0.0000");
-            d=new double[n];
-            adjList=new ArrayList[n];
-            for (int i = 0; i < n; i++)
-                adjList[i]=new ArrayList<>();
-            for (int i = 0; i < m; i++) {
-                String[] l2=bf.readLine().split(" ");
-                int a=Integer.parseInt(l2[0]);
-                int b=Integer.parseInt(l2[1]);
-                double w=Double.parseDouble(l2[2]);
-                addEdge(a,b,w);
-            }
-
-            bellmanFord(0);
-            //System.out.println(Arrays.toString(d));
-            System.out.println(formato.format(d[n-1]));
-        }
-    }
-    public static int[] bellmanFord(int s) {
-        d[s] = 1;
-        boolean hayCambios = true;
-        while (hayCambios) {
-            hayCambios = false;
-            for(int u=0; u<n; u++) {
-                for(Edge e : adjList[u]) {
-                    int v = e.vertex;
-                    double w = e.weight;
-                    if (d[u] * w> d[v]) {
-                        d[v] = d[u] * w;
-                        hayCambios = true;
-                    }
-                }
-            }
-        }
-        return pi;
-    }
-
-
-
-    static void addEdge(int a,int b, double w){
-        adjList[a].add(new Edge(b,w));
-        adjList[b].add(new Edge(a,w));
-    }
-    private static class Edge implements Comparable<Edge> {
-        int vertex;
-        double weight;
-        Edge(int v, double w) {
-            vertex = v;
-            weight = w;
-        }
-        public boolean equals(Object o) {
-            if (o instanceof Edge)
-                return (vertex==((Edge)o).vertex && weight==((Edge)o).weight);
-            return false;
-        }
-        public int compareTo(Edge o) {
-            if (weight < o.weight) return -1;
-            if (weight > o.weight) return 1;
-            if (vertex < o.vertex) return -1;
-            if (vertex > o.vertex) return 1;
-            return 0;
-        }
-        public String toString() {
-            return "(" + vertex + ", " + weight + ")";
-        }
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/Cycles/Biketopia's Cyclic Track.java b/Problemas/Grafos/SearchProblems/Cycles/Biketopia's Cyclic Track.java
deleted file mode 100644
index 784e9fe..0000000
--- a/Problemas/Grafos/SearchProblems/Cycles/Biketopia's Cyclic Track.java	
+++ /dev/null
@@ -1,87 +0,0 @@
-//https://codeforces.com/gym/105505/problem/B
-
-import java.util.*;
-import java.io.*;
-
-public class Biketopia {
-    static ArrayList<pair>[] adj;
-    static int d[];
-    static int time;
-    static int maxTime;
-    static int U;
-    static int V;
-    static pair[] pi;
-    static int maxEdge;
-
-    public static void main(String[] args) throws Exception {
-        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(in.readLine());
-        PrintWriter out = new PrintWriter(System.out);
-        int n = Integer.parseInt(st.nextToken());
-        int m = Integer.parseInt(st.nextToken());
-        adj = new ArrayList[n];
-        for (int i = 0; i < n; i++)
-            adj[i] = new ArrayList<>();
-        for (int i = 0; i < m; i++) {
-            st = new StringTokenizer(in.readLine());
-            int a = Integer.parseInt(st.nextToken()) - 1;
-            int b = Integer.parseInt(st.nextToken()) - 1;
-            adj[a].add(new pair(b, i + 1));
-            adj[b].add(new pair(a, i + 1));
-        }
-        d = new int[n];
-        time = 1;
-        maxTime = -1;
-        pi = new pair[n];
-        maxEdge = -1;
-        dfs(0, -1, -1);
-        out.print(maxEdge + " ");
-        int i = 1;
-        while (V != U) {
-            pair e = pi[V];
-            V = e.first;
-            maxEdge = e.second;
-            i++;
-            out.print(maxEdge + " ");
-        }
-        System.out.println(i);
-        out.flush();
-    }
-
-    static void dfs(int u, int par, int edge) {
-        pi[u] = new pair(par, edge);
-        d[u] = time++;
-        for (pair ee : adj[u]) {
-            int v = ee.first;
-            int e = ee.second;
-            if (v == par)
-                continue;
-            if (d[v] == 0)
-                dfs(v, u, e);
-            else {
-                int depth = Math.min(d[u], d[v]);
-                if (depth > maxTime) {
-                    maxTime = depth;
-                    if (depth == d[u]) {
-                        U = u;
-                        V = v;
-                    } else {
-                        U = v;
-                        V = u;
-                    }
-                    maxEdge = e;
-                }
-            }
-        }
-    }
-
-    static class pair {
-        int first;
-        int second;
-
-        pair(int f, int s) {
-            this.first = f;
-            this.second = s;
-        }
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/Cycles/Find_Eventual_Safe_States.cpp b/Problemas/Grafos/SearchProblems/Cycles/Find_Eventual_Safe_States.cpp
deleted file mode 100644
index ce237fc..0000000
--- a/Problemas/Grafos/SearchProblems/Cycles/Find_Eventual_Safe_States.cpp
+++ /dev/null
@@ -1,24 +0,0 @@
-//https://leetcode.com/problems/find-eventual-safe-states/
-
-class Solution {
-public:
-    unordered_map<int, bool> safe;
-    bool dfs(int i, vector<vector<int>>& graph){
-        if (safe.find(i) != safe.end()) return safe[i];
-        safe[i] = false;
-        for (int nei : graph[i]) {
-            if (!dfs(nei, graph)) return false;
-        }
-        safe[i] = true;
-        return true;
-    }
-
-    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
-        int n = graph.size();
-        vector<int> res;
-        for (int i = 0; i < n; i++) 
-            if (dfs(i, graph)) res.push_back(i);
-
-        return res;
-    }
-};
diff --git a/Problemas/Grafos/SearchProblems/Cycles/Mad City.cpp b/Problemas/Grafos/SearchProblems/Cycles/Mad City.cpp
deleted file mode 100644
index a730e0a..0000000
--- a/Problemas/Grafos/SearchProblems/Cycles/Mad City.cpp	
+++ /dev/null
@@ -1,113 +0,0 @@
-#include <iostream>
-#include <algorithm>
-#include <cstring>
-#include <queue>
-#include <unordered_set>
-#include <vector>
-#define pb push_back
-using namespace std;
-int n;
-vector<vector<int> > adj;
-vector<bool> state;
-vector<int> pi;
-int cycle_start, cycle_end;
-
-vector<int> bfs(const int s, vector<int> d) {
-    vector<bool> st(n, false);
-    queue<int> q;
-    d[s] = 0;
-    q.push(s);
-    st[s] = true;
-    while (!q.empty()) {
-        int u = q.front();
-        q.pop();
-        for (int v: adj[u]) {
-            if (!st[v]) {
-                q.push(v);
-                st[v] = true;
-                d[v] = d[u] + 1;
-            }
-        }
-    }
-    return d;
-}
-
-bool dfs(int u, int par) {
-    state[u] = true;
-    for (int v: adj[u]) {
-        if (v == par) continue;
-        if (state[v]) {
-            cycle_end = u;
-            cycle_start = v;
-            return true;
-        }
-        pi[v] = u;
-        if (dfs(v, pi[v]))
-            return true;
-    }
-    return false;
-}
-
-unordered_set<int> find_cycle() {
-    state.assign(n, false);
-    pi.assign(n, -1);
-    cycle_start = -1;
-    for (int u = 0; u < n; u++) {
-        if (!state[u] && dfs(u, pi[u]))
-            break;
-    }
-
-    if (cycle_start == -1) {
-        unordered_set<int> cycle;
-        return cycle;
-    }
-    unordered_set<int> cycle;
-    cycle.insert(cycle_start);
-    for (int v = cycle_end; v != cycle_start; v = pi[v])
-        cycle.insert(v);
-    return cycle;
-}
-
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    int ti;
-    cin >> ti;
-    while (ti--) {
-        int a, b;
-        adj.clear();
-        state.clear();
-        pi.clear();
-        cin >> n >> a >> b;
-        adj.resize(n);
-        state.resize(n);
-        pi.resize(n);
-        for (int i = 0; i < n; i++) {
-            int u, v;
-            cin >> u >> v;
-            u--;
-            v--;
-            adj[u].pb(v);
-            adj[v].pb(u);
-        }
-        unordered_set<int> cycle = find_cycle();
-        vector<int> dm(n, 214748367);
-        vector<int> dv(n, 214748367);
-        a--;
-        b--;
-        dm=bfs(a,dm);
-        dv=bfs(b,dv);
-        bool flag=true;
-        for (int i: cycle) {
-            if (dv[i] < dm[i]) {
-                cout << "YES" << endl;
-                flag=false;
-                break;
-            }
-        }
-        if(flag)
-            cout << "NO" << endl;
-    }
-    return 0;
-}
diff --git a/Problemas/Grafos/SearchProblems/Cycles/Round Trip 2.java b/Problemas/Grafos/SearchProblems/Cycles/Round Trip 2.java
deleted file mode 100644
index 9c64fea..0000000
--- a/Problemas/Grafos/SearchProblems/Cycles/Round Trip 2.java	
+++ /dev/null
@@ -1,121 +0,0 @@
-//https://vjudge.net/problem/CSES-1678
-
-import java.util.*;
-import java.io.*;
-
-public class Main {
-    static int n;
-    static ArrayList<Integer>[] adj;
-    static int[] state;
-    static int[] pi;
-    static int cycleStart, cycleEnd;
-
-    public static void main(String[] args) {
-        Scanner sc = new Scanner();
-        PrintWriter pw = new PrintWriter(System.out);
-        n = sc.nextInt();
-        int m = sc.nextInt();
-        adj = new ArrayList[n];
-        for (int i = 0; i < n; i++)
-            adj[i] = new ArrayList<>();
-        for (int i = 0; i < m; i++) {
-            int u = sc.nextInt() - 1;
-            int v = sc.nextInt() - 1;
-            adj[u].add(v);
-        }
-        LinkedList<Integer> ans = cycle();
-        if (ans == null) {
-            System.out.println("IMPOSSIBLE");
-            return;
-        }
-        pw.println(ans.size());
-        pw.print(ans.removeLast() + 1);
-        int len=ans.size();
-        for (int i = 0; i < len; i++)
-            pw.print(" "+(ans.removeLast()+1));
-        pw.close();
-
-
-    }
-
-    static boolean dfs(int u) {
-        state[u] = 1;
-        for (int v : adj[u]) {
-            if (state[v] == 0) {
-                pi[v] = u;
-                if (dfs(v)) return true;
-            }
-            else if (state[v] == 1) {
-                cycleStart = v;
-                cycleEnd = u;
-                return true;
-            }
-        }
-        state[u] = 2;
-        return false;
-    }
-
-    static LinkedList<Integer> cycle() {
-        LinkedList<Integer> ans = new LinkedList<>();
-        state = new int[n];
-        pi = new int[n];
-        Arrays.fill(pi, -1);
-        cycleStart = -1;
-        for (int u = 0; u < n; u++)
-            if (state[u] == 0 && dfs(u))
-                break;
-        if (cycleStart == -1)
-            return null;
-        ans.add(cycleStart);
-        for (int u = cycleEnd; u != cycleStart; u = pi[u])
-            ans.add(u);
-        ans.add(cycleStart);
-        return ans;
-
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char Char() throws IOException {
-            return (char) br.read();
-        }
-
-        char nextChar() {
-            return next().charAt(0);
-        }
-
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/Cycles/Round Trip.java b/Problemas/Grafos/SearchProblems/Cycles/Round Trip.java
deleted file mode 100644
index 780fa80..0000000
--- a/Problemas/Grafos/SearchProblems/Cycles/Round Trip.java	
+++ /dev/null
@@ -1,113 +0,0 @@
-//https://vjudge.net/problem/CSES-1669
-import java.util.*;
-import java.io.*;
-public class Main {
-    static int n;
-    static ArrayList<Integer>[] adj;
-    static boolean[] state;
-    static int[] pi;
-    static int cycleStart, cycleEnd;
-    public static void main(String args[]) {
-        Scanner sc=new Scanner();
-        PrintWriter pw=new PrintWriter(System.out);
-        n=sc.nextInt();
-        int m=sc.nextInt();
-        adj=new ArrayList[n];
-        for (int i = 0; i < n; i++)
-            adj[i]=new ArrayList<>();
-        for (int i = 0; i < m; i++) {
-            int u=sc.nextInt()-1;
-            int v=sc.nextInt()-1;
-            adj[u].add(v);
-            adj[v].add(u);
-        }
-        LinkedList<Integer> ans=cycle();
-        if(ans==null){
-            System.out.println("IMPOSSIBLE");
-            return;
-        }
-        pw.println(ans.size());
-        pw.print(ans.removeFirst()+1);
-        for(int i : ans)
-            pw.print(" "+(i+1));
-        pw.close();
-
-
-    }
-    static boolean dfs(int u, int par){
-        state[u]=true;
-        for (int v:adj[u]){
-            if(v==par) continue;
-            if(state[v]){
-                cycleStart=v;
-                cycleEnd=u;
-                return true;
-            }
-            pi[v]=u;
-            if(dfs(v,u)) return true;
-        }
-        return false;
-    }
-    static LinkedList<Integer> cycle(){
-        LinkedList<Integer> ans=new LinkedList<>();
-        state=new boolean[n];
-        pi=new int[n];
-        Arrays.fill(pi,-1);
-        cycleStart=-1;
-        for (int u = 0; u < n; u++)
-            if(!state[u]&&dfs(u,pi[u]))
-                break;
-        if(cycleStart==-1)
-            return null;
-        ans.add(cycleStart);
-        for(int u=cycleEnd; u!=cycleStart; u=pi[u])
-            ans.add(u);
-        ans.add(cycleStart);
-        return ans;
-
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char Char() throws IOException {
-            return (char) br.read();
-        }
-        char nextChar(){
-            return next().charAt(0);
-        }
-
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/Dijkstra/BankRobbery.java b/Problemas/Grafos/SearchProblems/Dijkstra/BankRobbery.java
deleted file mode 100644
index 59edc76..0000000
--- a/Problemas/Grafos/SearchProblems/Dijkstra/BankRobbery.java
+++ /dev/null
@@ -1,109 +0,0 @@
-//https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=5038
-import java.io.*;
-import java.util.*;
-
-public class BankRobbery {
-	static int n;
-	static ArrayList<Edge>[] adj;
-	static int[] d;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st;
-		PrintWriter out = new PrintWriter(System.out);
-		for (int c;;) {
-			try {
-				st = new StringTokenizer(in.readLine());
-				n = Integer.parseInt(st.nextToken());
-				int m = Integer.parseInt(st.nextToken());
-				int b = Integer.parseInt(st.nextToken());
-				int p = Integer.parseInt(st.nextToken());
-				adj = new ArrayList[n];
-				d = new int[n];
-				for (int i = 0; i < n; i++) {
-					adj[i] = new ArrayList<>();
-					d[i] = Integer.MAX_VALUE;
-				}
-				for (int i = 0; i < m; i++) {
-					st = new StringTokenizer(in.readLine());
-					int u = Integer.parseInt(st.nextToken());
-					int v = Integer.parseInt(st.nextToken());
-					int w = Integer.parseInt(st.nextToken());
-					adj[u].add(new Edge(v, w));
-					adj[v].add(new Edge(u, w));
-				}
-				int[] bancos = new int[b];
-				st = new StringTokenizer(in.readLine());
-				for (int i = 0; i < b; i++)
-					bancos[i] = Integer.parseInt(st.nextToken());
-				int masLejano = -1;
-				if (p != 0) {
-					st = new StringTokenizer(in.readLine());
-					TreeSet<Edge> Q = new TreeSet<>();
-					for (int i = 0; i < p; i++) {
-						int val = Integer.parseInt(st.nextToken());
-						d[val] = 0;
-						Q.add(new Edge(val, 0));
-					}
-					dijkstra(Q);
-					for (int i : bancos)
-						masLejano = Math.max(masLejano, d[i]);
-				} else
-					masLejano = Integer.MAX_VALUE;
-				TreeSet<Integer> ans = new TreeSet<>();
-				for (int i : bancos)
-					if (d[i] == masLejano)
-						ans.add(i);
-				out.println(ans.size() + " " + (masLejano == Integer.MAX_VALUE ? "*" : masLejano));
-				c = 0;
-				for (int i : ans)
-					out.print(i + (c++ != ans.size() - 1 ? " " : ""));
-				out.println();
-			} catch (Exception e) {
-				break;
-			}
-		}
-		out.flush();
-
-	}
-
-	static void dijkstra(TreeSet<Edge> Q) {
-		boolean[] visited = new boolean[n];
-		while (!Q.isEmpty()) {
-			Edge e = Q.pollFirst();
-			int u = e.vertex;
-			if (visited[u])
-				continue;
-			visited[u] = true;
-			for (Edge ee : adj[u]) {
-				int v = ee.vertex;
-				int w = ee.weight;
-				if (!visited[v] && d[u] + w < d[v]) {
-					d[v] = d[u] + w;
-					Q.add(new Edge(v, d[v]));
-				}
-			}
-		}
-
-	}
-
-	static class Edge implements Comparable<Edge> {
-		int vertex;
-		int weight;
-
-		Edge(int v, int w) {
-			this.vertex = v;
-			this.weight = w;
-		}
-
-		public int compareTo(Edge e) {
-			if (weight < e.weight)
-				return -1;
-			if (weight > e.weight)
-				return 1;
-			return vertex - e.vertex;
-		}
-
-	}
-
-}
diff --git a/Problemas/Grafos/SearchProblems/Dijkstra/BigTruck.java b/Problemas/Grafos/SearchProblems/Dijkstra/BigTruck.java
deleted file mode 100644
index 1a274ff..0000000
--- a/Problemas/Grafos/SearchProblems/Dijkstra/BigTruck.java
+++ /dev/null
@@ -1,148 +0,0 @@
-//https://open.kattis.com/problems/bigtruck
-import java.util.*;
-import java.io.*;
-
-public class BigTruck {
-	static int n;
-	static ArrayList<Edge>[] adj;
-	static int[] items;
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		n = in.nextInt();
-		adj = new ArrayList[n];
-		for (int i = 0; i < n; i++)
-			adj[i] = new ArrayList<>();
-		items = new int[n];
-		for (int i = 0; i < n; i++)
-			items[i] = in.nextInt();
-		int m = in.nextInt();
-		for (int i = 0; i < m; i++) {
-			int a = in.nextInt() - 1;
-			int b = in.nextInt() - 1;
-			int w = in.nextInt();
-			adj[a].add(new Edge(b, w));
-			adj[b].add(new Edge(a, w));
-		}
-		int[][] ans = dijkstra();
-		if (ans[0][n - 1] == Integer.MAX_VALUE || ans[1][n - 1] == Integer.MIN_VALUE)
-			System.out.println("impossible");
-		else
-			System.out.println(ans[0][n - 1] + " " + ans[1][n - 1]);
-
-	}
-
-	static int[][] dijkstra() {
-		TreeSet<Edge> Q = new TreeSet<>();
-		int[] d = new int[n];
-		Arrays.fill(d, Integer.MAX_VALUE);
-		boolean[] visited = new boolean[n];
-		int[] item_d = new int[n];
-		Arrays.fill(item_d, Integer.MIN_VALUE);
-		Q.add(new Edge(0, 0));
-		d[0] = 0;
-		item_d[0] = items[0];
-		while (!Q.isEmpty()) {
-			Edge e = Q.pollFirst();
-			int u = e.vertex;
-			if (!visited[u]) {
-				visited[u] = true;
-				for (Edge ee : adj[u]) {
-					int v = ee.vertex;
-					int w = ee.weight;
-					if (!visited[v])
-						if (d[u] + w == d[v])
-							item_d[v] = Math.max(item_d[u] + items[v], item_d[v]);
-						else if (d[u] + w < d[v]) {
-							d[v] = d[u] + w;
-							item_d[v] = item_d[u] + items[v];
-							Q.add(new Edge(v, d[v]));
-						}
-				}
-			}
-
-		}
-		return new int[][] { d, item_d };
-
-	}
-
-	static class Edge implements Comparable<Edge> {
-		int vertex;
-		int weight;
-
-		Edge(int v, int w) {
-			this.vertex = v;
-			this.weight = w;
-		}
-
-		public int compareTo(Edge e) {
-			if (weight < e.weight)
-				return -1;
-			if (weight > e.weight)
-				return 1;
-			return Integer.compare(vertex, e.vertex);
-		}
-
-		public String toString() {
-			return "(" + vertex + ", " + weight + ")";
-		}
-
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-
-}
diff --git a/Problemas/Grafos/SearchProblems/Dijkstra/CharlyAndNito.cpp b/Problemas/Grafos/SearchProblems/Dijkstra/CharlyAndNito.cpp
deleted file mode 100644
index bd54933..0000000
--- a/Problemas/Grafos/SearchProblems/Dijkstra/CharlyAndNito.cpp
+++ /dev/null
@@ -1,94 +0,0 @@
-//https://www.spoj.com/problems/CANDN/
-using namespace std;
-#include <bits/stdc++.h>
-#include <iostream>
-#include <vector>
-#include <unordered_map>
-#include <unordered_set>
-#include <map>
-#include <set>
-#include <algorithm>
-#include <climits>
-#include <cmath>
-#include <math.h>
-#include <iomanip>
-#include <deque>
-#include <queue>
-#include <stack>
-#include <string>
-#include <utility>
-#include <numeric>
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define MAXN 1000001
-
-vector<vector<pair<int, int>>> adj;
-int n;
-const int INF = INT_MAX;
-vector<int> dijkstra(int s)
-{
-    vector<int> d(n, INF);
-    vector<bool> visited(n, false);
-    d[s] = 0;
-    set<pair<int, int>> Q;
-    Q.insert({d[s], s});
-    while (!Q.empty())
-    {
-        int u = Q.begin()->second;
-        Q.erase(Q.begin());
-        if (visited[u])
-            continue;
-        visited[u] = true;
-        for (const auto &ee : adj[u])
-        {
-            int v = ee.first;
-            int w = ee.second;
-            if (!visited[v] && d[u] + w < d[v])
-            {
-                d[v] = d[u] + w;
-                Q.insert({d[v], v});
-            }
-        }
-    }
-    return d;
-}
-
-void solve()
-{
-    while (true)
-    {
-        int B, C, N, m;
-        cin >> n >> B >> C >> N >> m;
-        if (n == -1)
-            break;
-        B--;
-        C--;
-        N--;
-        adj.assign(n, vector<pair<int, int>>());
-        fori(i, 0, m)
-        {
-            int a, b, w;
-            cin >> a >> b >> w;
-            a--;
-            b--;
-            adj[a].push_back({b, w});
-            adj[b].push_back({a, w});
-        }
-        vector<int> bar = dijkstra(B);
-        vector<int> carlos = dijkstra(C);
-        vector<int> nico = dijkstra(N);
-        int ans = 0;
-        fori(u, 0, n)
-            if (bar[u] + carlos[u] == bar[C] && bar[u] + nico[u] == bar[N])
-                ans = max(ans, bar[u]);
-        cout << ans << " " << bar[C] - ans << " " << bar[N] - ans << ln;
-    }
-}
-
-int main()
-{
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    solve();
-    return 0;
-}
diff --git a/Problemas/Grafos/SearchProblems/Dijkstra/Meeting Point.cpp b/Problemas/Grafos/SearchProblems/Dijkstra/Meeting Point.cpp
deleted file mode 100644
index de75722..0000000
--- a/Problemas/Grafos/SearchProblems/Dijkstra/Meeting Point.cpp	
+++ /dev/null
@@ -1,100 +0,0 @@
-//https://codeforces.com/gym/104736/problem/M
-#include <iostream>
-#include <vector>
-#include <queue>
-#include <limits>
-
-using namespace std;
-
-typedef unsigned int uint;
-typedef pair<uint, uint> Pair;
-
-void dijkstra2(int source, vector<vector<Pair>>& graph, vector<uint>& d,int skip) {
-    int n = graph.size();
-    d.assign(n, numeric_limits<uint>::max());
-    d[source] = 0;
-    priority_queue<Pair, vector<Pair>, greater<Pair>> pq;
-    vector<bool> state(n, false);
-    pq.push({0, source});
-    while (!pq.empty()) {
-        uint u = pq.top().second;
-        pq.pop();
-        if(u==skip)
-            continue;
-        if (state[u]) continue;
-        state[u] = true;
-        for (const Pair& edge : graph[u]) {
-            uint v = edge.first;
-            uint w = edge.second;
-            if (d[u] + w < d[v]) {
-                d[v] = d[u] + w;
-                pq.push({d[v], v});
-            }
-        }
-    }
-}
-void dijkstra(int source, vector<vector<Pair>>& graph, vector<uint>& d) {
-    int n = graph.size();
-    d.assign(n, numeric_limits<uint>::max());
-    d[source] = 0;
-    priority_queue<Pair, vector<Pair>, greater<Pair>> pq;
-    vector<bool> state(n, false);
-    pq.push({0, source});
-
-    while (!pq.empty()) {
-        uint u = pq.top().second;
-        pq.pop();
-
-        if (state[u]) continue;
-
-        state[u] = true;
-
-        for (const Pair& edge : graph[u]) {
-            uint v = edge.first;
-            uint w = edge.second;
-            if (d[u] + w < d[v]) {
-                d[v] = d[u] + w;
-                pq.push({d[v], v});
-            }
-        }
-    }
-}
-
-int main() {
-    ios::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int n, m, p, g;
-    cin >> n >> m;
-    cin >> p >> g;
-    vector<vector<Pair>> graph(n);
-
-    for (int i = 0; i < m; i++) {
-        int u, v, w;
-        cin >> u >> v >> w;
-        u--;
-        v--;
-        graph[u].push_back({v, w});
-        graph[v].push_back({u, w});
-    }
-
-    vector<uint> dist(n);
-    vector<uint> dist2(n);
-    p--;
-    dijkstra(p, graph, dist);
-    dijkstra2(p, graph, dist2,g-1);
-
-    uint num = dist[g - 1] * 2;
-    bool as = false;
-
-    for (int i = 0; i < n; i++) {
-        if (dist[i] == num && dist2[i] > num) {
-            cout << i + 1 << " ";
-            as = true;
-        }
-    }
-    if (!as) {
-        cout << "*" << endl;
-    }
-
-    return 0;
-}
diff --git a/Problemas/Grafos/SearchProblems/Dijkstra/MiceAndMaze.java b/Problemas/Grafos/SearchProblems/Dijkstra/MiceAndMaze.java
deleted file mode 100644
index aa8debe..0000000
--- a/Problemas/Grafos/SearchProblems/Dijkstra/MiceAndMaze.java
+++ /dev/null
@@ -1,92 +0,0 @@
-//https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3553
-import java.io.*;
-import java.util.*;
-
-public class MiceAndMaze {
-	static int n;
-	static ArrayList<Edge>[] adj;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st;
-		PrintWriter out = new PrintWriter(System.out);
-		int T = Integer.parseInt(in.readLine());
-		for (int cases = 0; cases < T; cases++) {
-			in.readLine();
-			n = Integer.parseInt(in.readLine());
-			int s = Integer.parseInt(in.readLine()) - 1;
-			int time = Integer.parseInt(in.readLine());
-			int m = Integer.parseInt(in.readLine());
-			adj = new ArrayList[n];
-			for (int i = 0; i < n; i++)
-				adj[i] = new ArrayList<>();
-			for (int i = 0; i < m; i++) {
-				st = new StringTokenizer(in.readLine());
-				int a = Integer.parseInt(st.nextToken()) - 1;
-				int b = Integer.parseInt(st.nextToken()) - 1;
-				int w = Integer.parseInt(st.nextToken());
-				adj[b].add(new Edge(a, w));
-			}
-			int[] d = new int[n];
-			Arrays.fill(d, Integer.MAX_VALUE);
-			dijkstra(s, d);
-			int c = 0;
-			for (int i : d)
-				if (i <= time)
-					c++;
-			out.println(c);
-			if (cases < T - 1)
-				out.println();
-		}
-		out.flush();
-
-	}
-
-	static void dijkstra(int s, int[] d) {
-		boolean[] visited = new boolean[n];
-		TreeSet<Edge> Q = new TreeSet<>();
-		d[s] = 0;
-		Q.add(new Edge(s, d[s]));
-		while (!Q.isEmpty()) {
-			int u = Q.pollFirst().vertex;
-			if (visited[u])
-				continue;
-			visited[u] = true;
-			for (Edge ee : adj[u]) {
-				int v = ee.vertex;
-				int w = ee.weight;
-				if (visited[v])
-					continue;
-				if (d[u] + w < d[v]) {
-					d[v] = d[u] + w;
-					Q.add(new Edge(v, d[v]));
-				}
-			}
-		}
-
-	}
-
-	static class Edge implements Comparable<Edge> {
-		int vertex;
-		int weight;
-
-		Edge(int v, int w) {
-			this.vertex = v;
-			this.weight = w;
-		}
-
-		public int compareTo(Edge o) {
-			if (weight < o.weight)
-				return -1;
-			if (weight > o.weight)
-				return 1;
-			return vertex - o.vertex;
-		}
-
-		public String toString() {
-			return "(" + vertex + ", " + weight + ")";
-		}
-
-	}
-
-}
diff --git a/Problemas/Grafos/SearchProblems/Dijkstra/SendingEmail.cpp b/Problemas/Grafos/SearchProblems/Dijkstra/SendingEmail.cpp
deleted file mode 100644
index 7ae882c..0000000
--- a/Problemas/Grafos/SearchProblems/Dijkstra/SendingEmail.cpp
+++ /dev/null
@@ -1,58 +0,0 @@
-//https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=1927
-#include <iostream>
-#include <vector>
-#include <set>
-#include <string>
-using namespace std;
-
-const int INF = 1000000000; 
-vector<vector<pair<int, int>>> adj;
-int n;
-
-void dijkstra(int s, vector<int>& d, vector<int>& pi) {
-    d.assign(n, INF);
-    pi.assign(n, -1);
-    d[s] = 0;
-    set<pair<int, int>> Q;
-    Q.insert({0, s});
-    while (!Q.empty()) {
-        int u = Q.begin()->second;
-        Q.erase(Q.begin());
-        for (pair<int,int> ee : adj[u]) {
-            int v = ee.first;
-            int w = ee.second;
-            if (d[u] + w < d[v]) {
-                Q.erase({d[v], v});
-                d[v] = d[u] + w;
-                pi[v] = u;
-                Q.insert({d[v], v});
-            }
-        }
-    }
-}
-
-int main() {
-    ios::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t;
-    cin >> t;
-    for (int i = 0; i < t; i++) {
-        cin >> n;
-        int m;
-        cin >> m;
-        int s, t;
-        cin >> s >> t;
-        adj.assign(n, vector<pair<int, int>>());
-        for (int j = 0; j < m; j++) {
-            int a, b, w;
-            cin >> a >> b >> w;
-            adj[a].push_back({b, w});
-            adj[b].push_back({a, w});
-        }
-        vector<int> d, pi;
-        dijkstra(s, d, pi);
-        int ans = d[t];
-        cout << "Case #" << (i + 1) << ": " << (ans == INF ? "unreachable" : to_string(ans)) << "\n";
-    }
-    return 0;
-}
diff --git a/Problemas/Grafos/SearchProblems/Dijkstra/SendingEmail.java b/Problemas/Grafos/SearchProblems/Dijkstra/SendingEmail.java
deleted file mode 100644
index 3bebadf..0000000
--- a/Problemas/Grafos/SearchProblems/Dijkstra/SendingEmail.java
+++ /dev/null
@@ -1,86 +0,0 @@
-//https://vjudge.net/problem/UVA-10986
-import java.io.*;
-import java.util.*;
-public class SendingEmail {
-	static int n;
-	static ArrayList<Edge>[] adj;
-	static final int INF = Integer.MAX_VALUE;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		int test = Integer.parseInt(in.readLine());
-		for (int i = 0; i < test; i++) {
-			StringTokenizer st = new StringTokenizer(in.readLine());
-			n = Integer.parseInt(st.nextToken());
-			int m = Integer.parseInt(st.nextToken());
-			int s = Integer.parseInt(st.nextToken());
-			int t = Integer.parseInt(st.nextToken());
-			adj = new ArrayList[n];
-			for (int j = 0; j < n; j++)
-				adj[j] = new ArrayList<>();
-			for (int j = 0; j < m; j++) {
-				st = new StringTokenizer(in.readLine());
-				int a = Integer.parseInt(st.nextToken());
-				int b = Integer.parseInt(st.nextToken());
-				int w = Integer.parseInt(st.nextToken());
-				adj[a].add(new Edge(b, w));
-				adj[b].add(new Edge(a, w));
-			}
-			int ans = dijkstra(s, t);
-			if (ans != INF)
-				System.out.println("Case #" + (i + 1) + ": " + ans);
-			else
-				System.out.println("Case #" + (i + 1) + ": " + "unreachable");
-
-		}
-	}
-
-	static int dijkstra(int s, int t) {
-		int[] d = new int[n];
-		boolean[] state = new boolean[n];
-		Arrays.fill(d, INF);
-		d[s] = 0;
-		TreeSet<Edge> Q = new TreeSet<Edge>();
-		Q.add(new Edge(s, d[s]));
-		while (!Q.isEmpty()) {
-			Edge e = Q.pollFirst();
-			int u = e.vertex;
-			if (!state[u]) {
-				state[u] = true;
-				for (Edge ee : adj[u]) {
-					int v = ee.vertex;
-					int w = ee.weight;
-					if (!state[v])
-						if (d[u] + w < d[v]) {
-							d[v] = d[u] + w;
-							Q.add(new Edge(v, d[v]));
-						}
-				}
-			}
-		}
-		return d[t];
-	}
-
-	private static class Edge implements Comparable<Edge> {
-		int vertex;
-		int weight;
-
-		public Edge(int v, int w) {
-			this.vertex = v;
-			this.weight = w;
-		}
-
-		public int compareTo(Edge o) {
-			if (weight < o.weight)
-				return -1;
-			if (weight > o.weight)
-				return 1;
-			if (vertex < o.vertex)
-				return -1;
-			if (vertex > o.vertex)
-				return 1;
-			return 0;
-		}
-	}
-
-}
diff --git a/Problemas/Grafos/SearchProblems/Dijkstra/Shopping.java b/Problemas/Grafos/SearchProblems/Dijkstra/Shopping.java
deleted file mode 100644
index af70a5b..0000000
--- a/Problemas/Grafos/SearchProblems/Dijkstra/Shopping.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/*https://vjudge.net/problem/SPOJ-SHOP*/
-
-import java.io.*;
-import java.util.*;
-
-public class Shopping {
-
-    static ArrayList<Edge>[] adjList;
-    static char[] state;
-    static int[] d;
-    static final int INF = 2147483647;
-    
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
-        while(true){
-            String[] l1=bf.readLine().split(" ");
-            int w=Integer.parseInt(l1[0]);
-            int h=Integer.parseInt(l1[1]);
-            if(w==0&&h==0)
-                break;
-            int n =w*h;
-            adjList=new ArrayList[n];
-            state=new char[n];
-            d=new int[n];
-            String s="";
-            for (int i = 0; i < n; i++)
-                adjList[i]=new ArrayList<>();
-            for (int i = 0; i < h; i++)
-                s+=bf.readLine();
-            int goal=-1;
-            int start=-1;
-            boolean cerca=false;
-            for (int i = 0; i < s.length(); i++) {
-                if(s.charAt(i)=='X')
-                    continue;
-                if(s.charAt(i)=='S'){
-                    start=i;
-                    if(i%w!=0&&s.charAt(i-1)=='D'||(i+1)%w!=0&&i+1<n&&s.charAt(i+1)=='D'||i+w<n&&s.charAt(i+w)=='D'||i-w>=0&&s.charAt(i-w)=='D'){
-                        System.out.println(0);
-                        cerca=true;
-                        break;
-                    }
-                }
-                else if(s.charAt(i)=='D'){
-                    goal=i;
-                    if(i%w!=0&&s.charAt(i-1)!='X')
-                        addEdge(i,i-1, 0);
-                    if((i+1)%w!=0&&i+1<n&&s.charAt(i+1)!='X')
-                        addEdge(i,i+1, 0);
-                    if(i+w<n&&s.charAt(i+w)!='X')
-                        addEdge(i,i+w, 0);
-                    if(i-w>=0&&s.charAt(i-w)!='X')
-                        addEdge(i,i-w, 0);
-                }
-                else {
-                    if(i%w!=0&&s.charAt(i-1)!='X')
-                        addEdge(i,i-1, s.charAt(i)-'0');
-                    if((i+1)%w!=0&&i+1<n&&s.charAt(i+1)!='X')
-                        addEdge(i,i+1, s.charAt(i)-'0');
-                    if(i+w<n&&s.charAt(i+w)!='X')
-                        addEdge(i,i+w, s.charAt(i)-'0');
-                    if(i-w>=0&&s.charAt(i-w)!='X')
-                        addEdge(i,i-w, s.charAt(i)-'0');
-                }
-            }
-            if(!cerca) {
-                dijkstra(start);
-                System.out.println(d[goal]);
-            }
-            bf.readLine();
-        }
-    }
-
-    static void addEdge(int a,int b, int w){
-        adjList[b].add(new Edge(a,w));
-    }
-    static void dijkstra(int s) {
-        Arrays.fill(d, INF);
-        Arrays.fill(state, 'N');
-        d[s] = 0; state[s] = 'D';
-        TreeSet<Edge> Q = new TreeSet<Edge>();
-        Q.add(new Edge(s, d[s]));
-        while (!Q.isEmpty()) {
-            Edge e = Q.pollFirst();
-            int u = e.vertex;
-            if (state[u] != 'E') {
-                for (Edge ee : adjList[u]) {
-                    int v = ee.vertex;
-                    int w = ee.weight;
-                    if (state[v] != 'E') {
-                        if (d[u] + w < d[v]) {
-                            d[v] = d[u] + w;
-                            state[v] = 'D';
-                            Q.add(new Edge(v, d[v]));
-                        }
-                    }
-                }
-                state[u] = 'E';
-            }
-        }
-
-    }
-
-    private static class Edge implements Comparable<Edge> {
-        int vertex;
-        int weight;
-        Edge(int v, int w) {
-            vertex = v;
-            weight = w;
-        }
-        public boolean equals(Object o) {
-            if (o instanceof Edge)
-                return (vertex==((Edge)o).vertex && weight==((Edge)o).weight);
-            return false;
-        }
-        public int compareTo(Edge o) {
-            if (weight < o.weight) return -1;
-            if (weight > o.weight) return 1;
-            if (vertex < o.vertex) return -1;
-            if (vertex > o.vertex) return 1;
-            return 0;
-        }
-        public String toString() {
-            return "(" + vertex + ", " + weight + ")";
-        }
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/Dijkstra/Shortest Routes I.cpp b/Problemas/Grafos/SearchProblems/Dijkstra/Shortest Routes I.cpp
deleted file mode 100644
index cead26e..0000000
--- a/Problemas/Grafos/SearchProblems/Dijkstra/Shortest Routes I.cpp	
+++ /dev/null
@@ -1,61 +0,0 @@
-//https://vjudge.net/problem/CSES-1671
-#include <iostream>
-#include <algorithm>
-#include <cstring>
-#include <limits>
-#include <queue>
-#include <vector>
-#define pb push_back
-using namespace std;
-typedef unsigned long long ll;
-typedef pair<ll, ll> Pair;
-ll INF=18446744073709551615;
-vector<ll> dijkstra(int source, vector<vector<Pair>>& graph, vector<ll>& d) {
-    int n = graph.size();
-    d.assign(n, numeric_limits<ll>::max());
-    d[source] = 0;
-    priority_queue<Pair, vector<Pair>, greater<Pair>> pq;
-    vector<bool> state(n, false);
-    pq.push({0, source});
-    while (!pq.empty()) {
-        ll u = pq.top().second;
-        pq.pop();
-        if (state[u]) continue;
-        state[u] = true;
-        for (const Pair& edge : graph[u]) {
-            ll v = edge.first;
-            ll w = edge.second;
-            if(!state[v]) {
-                if (d[u] + w < d[v]) {
-                    d[v] = d[u] + w;
-                    pq.push({d[v], v});
-                }
-            }
-        }
-    }
-    return d;
-}
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    int n,m;
-    cin>>n>>m;
-    vector<vector<Pair>> adj(n);
-
-    for (int i = 0; i < m; i++) {
-        int u,v;
-        ll w;
-        cin>>u>>v>>w;
-        u-=1;
-        v-=1;
-        adj[u].push_back({v, w});
-    }
-    vector<ll> a(n,INF);
-    vector<ll> d=dijkstra(0,adj,a);
-    cout<<0;
-    for(int i=1;i<n;i++)
-        cout<<" "<<d[i];
-
-    return 0;
-}
diff --git a/Problemas/Grafos/SearchProblems/Dijkstra/Subway.java b/Problemas/Grafos/SearchProblems/Dijkstra/Subway.java
deleted file mode 100644
index 97fd6d3..0000000
--- a/Problemas/Grafos/SearchProblems/Dijkstra/Subway.java
+++ /dev/null
@@ -1,122 +0,0 @@
-//https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1330
-import java.awt.Point;
-import java.io.*;
-import java.util.*;
-
-public class Subway {
-
-	static HashMap<Point, ArrayList<Edge>> adj;
-	static HashMap<Point, Double> d;
-	static HashMap<Point, Boolean> visited;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st;
-		PrintWriter out = new PrintWriter(System.out);
-		int T = Integer.parseInt(in.readLine());
-		in.readLine();
-		for (int i = 0; i < T; i++) {
-			st = new StringTokenizer(in.readLine());
-			Point s = new Point(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));
-			Point t = new Point(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));
-			adj = new HashMap<>();
-			d = new HashMap<>();
-			visited = new HashMap<>();
-			adj.put(s, new ArrayList<>());
-			adj.put(t, new ArrayList<>());
-			d.put(s, Double.POSITIVE_INFINITY);
-			d.put(t, Double.POSITIVE_INFINITY);
-			visited.put(s, false);
-			visited.put(t, false);
-			List<List<Point>> lines = new ArrayList<>();
-			List<Point> l = new ArrayList<>();
-			while (true) {
-				try {
-					st = new StringTokenizer(in.readLine());
-				} catch (Exception e) {
-					break;
-				}
-				if (!st.hasMoreTokens())
-					break;
-				while (st.hasMoreTokens()) {
-					int x = Integer.parseInt(st.nextToken());
-					int y = Integer.parseInt(st.nextToken());
-					if (x == -1 && y == -1) {
-						lines.add(l);
-						l = new ArrayList<>();
-						break;
-					}
-					Point p = new Point(x, y);
-					l.add(p);
-					adj.put(p, new ArrayList<>());
-					d.put(p, Double.MAX_VALUE);
-					visited.put(p, false);
-				}
-			}
-			for (Point p1 : adj.keySet())
-				for (Point p2 : adj.keySet())
-					addEdge(p1, p2, p1.distance(p2) / (10 / 3.6));
-
-			for (List<Point> list : lines)
-				for (int j = 0; j < list.size() - 1; j++) {
-					Point p1 = list.get(j);
-					Point p2 = list.get(j + 1);
-					addEdge(p1, p2, p1.distance(p2) / (40 / 3.6));
-				}
-
-			dijkstra(s);
-			out.println(Math.round(d.get(t) / 60));
-			if (i != T - 1)
-				out.println();
-		}
-		out.flush();
-	}
-
-	static void dijkstra(Point s) {
-		TreeSet<Edge> Q = new TreeSet<>();
-		d.put(s, 0.0);
-		Q.add(new Edge(s, 0.0));
-		while (!Q.isEmpty()) {
-			Edge e = Q.pollFirst();
-			Point u = e.vertex;
-			if (!visited.get(u)) {
-				visited.put(u, true);
-				for (Edge ee : adj.get(u)) {
-					Point v = ee.vertex;
-					double w = ee.weight;
-					double cost = d.get(u) + w;
-					if (!visited.get(v) && cost < d.get(v)) {
-						d.put(v, cost);
-						Q.add(new Edge(v, cost));
-					}
-				}
-			}
-		}
-	}
-
-	static void addEdge(Point a, Point b, double cost) {
-		adj.get(a).add(new Edge(b, cost));
-		adj.get(b).add(new Edge(a, cost));
-	}
-
-	static class Edge implements Comparable<Edge> {
-		Point vertex;
-		double weight;
-
-		Edge(Point v, double w) {
-			this.vertex = v;
-			this.weight = w;
-		}
-
-		public int compareTo(Edge e) {
-			if (weight < e.weight)
-				return -1;
-			if (weight > e.weight)
-				return 1;
-			if (vertex.x == e.vertex.x)
-				return vertex.y - e.vertex.y;
-			return vertex.x - e.vertex.x;
-		}
-
-	}
-}
diff --git a/Problemas/Grafos/SearchProblems/Floyd-Warshall/City of Blinding Lights .java b/Problemas/Grafos/SearchProblems/Floyd-Warshall/City of Blinding Lights .java
deleted file mode 100644
index 25a8902..0000000
--- a/Problemas/Grafos/SearchProblems/Floyd-Warshall/City of Blinding Lights .java	
+++ /dev/null
@@ -1,109 +0,0 @@
-//https://vjudge.net/problem/HackerRank-floyd-city-of-blinding-lights
-import java.io.*;
-import java.util.*;
-
-public class FloydCityOfBlindingLights {
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		int n = in.nextInt();
-		int m = in.nextInt();
-		double[][] adj = new double[n][n];
-		for (int i = 0; i < m; i++) {
-			int a = in.nextInt() - 1;
-			int b = in.nextInt() - 1;
-			double w = in.nextDouble();
-			adj[a][b] = w;
-		}
-		for (int i = 0; i < n; i++)
-			for (int j = 0; j < n; j++)
-				if (adj[i][j] == 0)
-					adj[i][j] = Double.MAX_VALUE;
-		double[][] ans = floydWarshall(adj);
-		int q = in.nextInt();
-		for (int i = 0; i < q; i++) {
-			int a = in.nextInt() - 1;
-			int b = in.nextInt() - 1;
-			double res = ans[a][b];
-			if (a == b)
-				System.out.println(0);
-			else if (res == Double.MAX_VALUE)
-				System.out.println(-1);
-			else
-				System.out.println((int) res);
-			
-		}
-
-	}
-
-	static double[][] floydWarshall(double[][] mAdy) {
-		int N;
-		double[][] res = new double[N = mAdy.length][N];
-		for (int i = 0; i < N; i++)
-			for (int j = 0; j < N; j++)
-				res[i][j] = mAdy[i][j];
-		for (int k = 0; k < N; k++)
-			for (int i = 0; i < N; i++)
-				for (int j = 0; j < N; j++)
-					if (res[i][k] < Double.MAX_VALUE && res[k][j] < Double.MAX_VALUE)
-						res[i][j] = Math.min(res[i][j], res[i][k] + res[k][j]);
-		return res;
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-
-}
diff --git a/Problemas/Grafos/SearchProblems/Floyd-Warshall/MiceAndMaze.java b/Problemas/Grafos/SearchProblems/Floyd-Warshall/MiceAndMaze.java
deleted file mode 100644
index 11f9a41..0000000
--- a/Problemas/Grafos/SearchProblems/Floyd-Warshall/MiceAndMaze.java
+++ /dev/null
@@ -1,51 +0,0 @@
-//https://vjudge.net/problem/UVA-1112
-import java.io.*;
-import java.util.*;
-
-public class MiceAndMaze {
-	static int n;
-	static int[][] adj;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st;
-		PrintWriter out = new PrintWriter(System.out);
-		int T = Integer.parseInt(in.readLine());
-		for (int cases = 0; cases < T; cases++) {
-			in.readLine();
-			n = Integer.parseInt(in.readLine());
-			int s = Integer.parseInt(in.readLine()) - 1;
-			int time = Integer.parseInt(in.readLine());
-			int m = Integer.parseInt(in.readLine());
-			adj = new int[n][n];
-			for (int[] i : adj)
-				Arrays.fill(i, Integer.MAX_VALUE);
-			for (int i = 0; i < m; i++) {
-				st = new StringTokenizer(in.readLine());
-				int a = Integer.parseInt(st.nextToken()) - 1;
-				int b = Integer.parseInt(st.nextToken()) - 1;
-				int w = Integer.parseInt(st.nextToken());
-				adj[a][b] = w;
-			}
-			floydWarshall();
-			int c = 0;
-			for (int i = 0; i < n; i++)
-				if (adj[i][s] <= time)
-					c++;
-			out.println(c);
-			if (cases < T - 1)
-				out.println();
-		}
-		out.flush();
-
-	}
-
-	static void floydWarshall() {
-		for (int k = 0; k < n; k++)
-			for (int i = 0; i < n; i++)
-				for (int j = 0; j < n; j++)
-					if (adj[i][k] < Integer.MAX_VALUE && adj[k][j] < Integer.MAX_VALUE)
-						adj[i][j] = Math.min(adj[i][j], adj[i][k] + adj[k][j]);
-
-	}
-}
diff --git a/Problemas/Grafos/SearchProblems/Floyd-Warshall/Shortest Routes II.cpp b/Problemas/Grafos/SearchProblems/Floyd-Warshall/Shortest Routes II.cpp
deleted file mode 100644
index bdb1c41..0000000
--- a/Problemas/Grafos/SearchProblems/Floyd-Warshall/Shortest Routes II.cpp	
+++ /dev/null
@@ -1,51 +0,0 @@
-//https://vjudge.net/problem/CSES-1672
-#include <iostream>
-#include <algorithm>
-#include <cstring>
-#include <vector>
-#define pb push_back
-using namespace std;
-typedef unsigned long long ll;
-ll INF=18446744073709551615;
-vector<vector<ll>> floydWarshall(vector<vector<ll>> madj) {
-    int n = madj.size();
-    for (int k = 0; k < n; k++)
-        for (int i = 0; i < n; i++)
-            for (int j = 0; j < n; j++)
-                if (madj[i][k] < INF && madj[k][j] < INF)
-                    madj[i][j] = min(madj[i][j], madj[i][k] + madj[k][j]);
-    return madj;
-}
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    int n,m,q;
-    cin>>n>>m>>q;
-    vector<vector<ll>> madj(n, vector<ll>(n, INF));
-    for (int i = 0; i < n; i++)
-        madj[i][i] = 0;
-    for (int i = 0; i < m; i++) {
-        int u,v;
-        ll w;
-        cin>>u>>v>>w;
-        u-=1;
-        v-=1;
-        madj[u][v] = min(madj[u][v], w);
-        madj[v][u] = min(madj[v][u], w);
-    }
-    madj=floydWarshall(madj);
-    for (int i = 0; i < q; i++) {
-        int u,v;
-        cin>>u>>v;
-        u-=1;
-        v-=1;
-        if(madj[u][v]==INF)
-            cout<<"-1"<<endl;
-        else
-            cout<<madj[u][v]<<endl;
-    }
-
-
-    return 0;
-}
diff --git a/Problemas/Grafos/SearchProblems/Floyd-Warshall/String Problem.java b/Problemas/Grafos/SearchProblems/Floyd-Warshall/String Problem.java
deleted file mode 100644
index a82a6dd..0000000
--- a/Problemas/Grafos/SearchProblems/Floyd-Warshall/String Problem.java	
+++ /dev/null
@@ -1,109 +0,0 @@
-//https://codeforces.com/contest/33/problem/B
-import java.util.*;
-import java.io.*;
-public class Main {
-    public static void main(String args[]) {
-        Scanner sc=new Scanner();
-        String s=sc.next();
-        String t=sc.next();
-        int m=sc.nextInt();
-        int[][] madj=new int[26][26];
-        for(int[] i:madj)
-            Arrays.fill(i,Integer.MAX_VALUE);
-        for(int i =0; i<26;i++)
-            madj[i][i]=0;
-        for(int i =0;i<m;i++){
-            int u=sc.nextChar()-'a';
-            int v=sc.nextChar()-'a';
-            int w=sc.nextInt();
-            madj[u][v]=Math.min(madj[u][v],w);
-        }
-        if(s.length()!=t.length()){
-            System.out.println(-1);
-            return;
-        }
-        floydWarshall(madj);
-        StringBuilder ans= new StringBuilder();
-        int c=0;
-        for(int i =0;i<s.length();i++){
-            int u = s.charAt(i)-'a';
-            int v = t.charAt(i)-'a';
-            if(u==v) {
-                ans.append(s.charAt(i));
-                continue;
-            }
-            int w=Integer.MAX_VALUE;
-            int k=-1;
-            for (int j = 0; j < 26; j++) {
-                if(madj[u][j]!=Integer.MAX_VALUE&&madj[v][j]!=Integer.MAX_VALUE&&madj[u][j]+madj[v][j]<w){
-                    w=Math.min(w,madj[u][j]+madj[v][j]);
-                    k=j;
-                }
-            }
-            if(w==Integer.MAX_VALUE){
-                System.out.println(-1);
-                return;
-            }
-            ans.append((char) (k + 'a'));
-            c+=w;
-        }
-        System.out.println(c);
-        System.out.println(ans);
-
-
-    }
-    static void floydWarshall(int[][] res) {
-        int N=res.length;
-        for (int k = 0; k < N; k++)
-            for (int i = 0; i < N; i++)
-                for (int j = 0; j < N; j++)
-                    if (res[i][k] < Integer.MAX_VALUE && res[k][j] < Integer.MAX_VALUE)
-                        res[i][j] = Math.min(res[i][j], res[i][k] + res[k][j]);
-
-    }
-
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char Char() throws IOException {
-            return (char) br.read();
-        }
-        char nextChar(){
-            return next().charAt(0);
-        }
-
-    }
-}
diff --git a/Problemas/Grafos/SearchProblems/Others/CompleteGraph.java b/Problemas/Grafos/SearchProblems/Others/CompleteGraph.java
deleted file mode 100644
index bd5e72a..0000000
--- a/Problemas/Grafos/SearchProblems/Others/CompleteGraph.java
+++ /dev/null
@@ -1,89 +0,0 @@
-import java.io.*;
-import java.util.*;
-
-public class CompleteGraph {
-	static int n;
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		n = in.nextInt();
-		int m = in.nextInt();
-		int[][] matrix = new int[n][n];
-		for (int i = 0; i < m; i++) {
-			int a = in.nextInt() - 1;
-			int b = in.nextInt() - 1;
-			matrix[a][b] = matrix[b][a] = 1;
-		}
-		System.out.println(solve(matrix) ? "YES" : "NO");
-
-	}
-
-	static boolean solve(int[][] m) {
-		for (int i = 0; i < n; i++)
-			for (int j = 0; j < n; j++) {
-				if (i == j && m[i][j] != 0)
-					return false;
-				if (m[i][j] != 1 && i != j)
-					return false;
-			}
-		return true;
-	}
-
-	static class Input {
-
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-
-}
diff --git "a/Problemas/Grafos/SearchProblems/Others/L\303\241szl\303\263 Babai.java" "b/Problemas/Grafos/SearchProblems/Others/L\303\241szl\303\263 Babai.java"
deleted file mode 100644
index 03de559..0000000
--- "a/Problemas/Grafos/SearchProblems/Others/L\303\241szl\303\263 Babai.java"	
+++ /dev/null
@@ -1,108 +0,0 @@
-import java.io.*;
-import java.util.*;
-
-public class LszlBabai {
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		int t = in.nextInt();
-		for (int cases = 0; cases < t; cases++) {
-			ArrayList<Integer>[] adj1 = new ArrayList[3];
-			for (int i = 0; i < 3; i++)
-				adj1[i] = new ArrayList<>();
-			int m1 = in.nextInt();
-			for (int i = 0; i < m1; i++) {
-				int a = in.nextInt() - 1;
-				int b = in.nextInt() - 1;
-				adj1[a].add(b);
-				adj1[b].add(a);
-			}
-			ArrayList<Integer>[] adj2 = new ArrayList[3];
-			for (int i = 0; i < 3; i++)
-				adj2[i] = new ArrayList<>();
-			int m2 = in.nextInt();
-			for (int i = 0; i < m2; i++) {
-				int a = in.nextInt() - 1;
-				int b = in.nextInt() - 1;
-				adj2[a].add(b);
-				adj2[b].add(a);
-			}
-			if (m1 != m2) {
-				System.out.println("no");
-				continue;
-			}
-			int[] g1 = new int[3];
-			int[] g2 = new int[3];
-			for (int i = 0; i < 3; i++)
-				g1[i] = adj1[i].size();
-
-			for (int i = 0; i < 3; i++)
-				g2[i] = adj2[i].size();
-
-			Arrays.sort(g1);
-			Arrays.sort(g2);
-			if (Arrays.equals(g1, g2))
-				System.out.println("yes");
-			else
-				System.out.println("no");
-
-		}
-
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-}
diff --git a/Problemas/Grafos/SearchProblems/Others/MilkFactory.cpp b/Problemas/Grafos/SearchProblems/Others/MilkFactory.cpp
deleted file mode 100644
index 13bd52a..0000000
--- a/Problemas/Grafos/SearchProblems/Others/MilkFactory.cpp
+++ /dev/null
@@ -1,75 +0,0 @@
-//https://vjudge.net/problem/USACO-940
-using namespace std;
-#include <bits/stdc++.h>
-#include <iostream>
-#include <vector>
-#include <unordered_map>
-#include <unordered_set>
-#include <algorithm>
-#include <climits>
-#include <cmath>
-#include <math.h>
-#include <iomanip>
-#include <set>
-#include <deque>
-#include <queue>
-#include <stack>
-#include <string>
-#include <utility>
-#define fori(i, k, n) for (int i = k; i < (n); i++)
-#define MAXN 50000
-
-vector<vector<int>> adj;
-vector<bool> visited;
-int n;
-
-void dfs(int u)
-{
-    visited[u] = true;
-    for (int v : adj[u])
-        if (!visited[v])
-            dfs(v);
-}
-
-void solve()
-{
-
-    cin >> n;
-    adj.assign(n, vector<int>());
-    fori(i, 0, n - 1)
-    {
-        int a, b;
-        cin >> a >> b;
-        a--;
-        b--;
-        adj[b].push_back(a);
-    }
-    fori(i, 0, n)
-    {
-        visited.assign(n, false);
-        dfs(i);
-        bool ans = true;
-        for (const auto &e : visited)
-            if (!e)
-            {
-                ans = false;
-                break;
-            }
-        if (ans)
-        {
-            cout << ++i << "\n";
-            return;
-        }
-    }
-    cout << -1 << "\n";
-}
-
-int main()
-{
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    freopen("factory.in", "r", stdin);
-    freopen("factory.out", "w", stdout);
-    solve();
-    return 0;
-}
diff --git a/Problemas/Grafos/SearchProblems/Others/TravelingSalesmanProblem.java b/Problemas/Grafos/SearchProblems/Others/TravelingSalesmanProblem.java
deleted file mode 100644
index 9101ab3..0000000
--- a/Problemas/Grafos/SearchProblems/Others/TravelingSalesmanProblem.java
+++ /dev/null
@@ -1,102 +0,0 @@
-import java.io.*;
-import java.util.*;
-
-public class TSP {
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		int n = in.nextInt();
-		int m = in.nextInt();
-		double[][] adm = new double[n][n];
-		for (int i = 0; i < adm.length; i++)
-			Arrays.fill(adm[i], Double.MAX_VALUE);
-		for (int i = 0; i < m; i++) {
-			int a = in.nextInt();
-			int b = in.nextInt();
-			double w = in.nextDouble();
-			adm[a][b] = w;
-		}
-		double ans = Double.MAX_VALUE;
-		for (int i = 0; i < n; i++)
-			ans = Math.min(ans, tsp(adm, i));
-		System.out.println(ans == Double.MAX_VALUE ? -1 : (long) ans);
-
-	}
-
-	static double tsp(double[][] mAdy, int v) {
-		int n = mAdy.length, t = 1 << n;
-		double mem[][] = new double[t][n];
-		for (double[] arr : mem)
-			Arrays.fill(arr, -1d);
-		return tsp(mAdy, n, v, v, 1 << v, mem);
-	}
-
-	static double tsp(double[][] mAdy, int n, int v1, int v2, int visitados, double[][] mem) {
-		if (mem[visitados][v1] >= 0d)
-			return mem[visitados][v1];
-		if (visitados == (1 << n) - 1)
-			return mem[visitados][v1] = mAdy[v1][v2];
-		double min = Double.POSITIVE_INFINITY, d;
-		for (int e = visitados, j = 0; j < n; j++, e >>>= 1)
-			if ((e & 1) == 0 && (d = mAdy[v1][j]) < min)
-				min = Math.min(min, d + tsp(mAdy, n, j, v2, visitados | (1 << j), mem));
-		return mem[visitados][v1] = min;
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-
-}
diff --git a/Problemas/Grafos/SearchProblems/Others/WeakVertices.java b/Problemas/Grafos/SearchProblems/Others/WeakVertices.java
deleted file mode 100644
index 68c150a..0000000
--- a/Problemas/Grafos/SearchProblems/Others/WeakVertices.java
+++ /dev/null
@@ -1,132 +0,0 @@
-import java.io.*;
-import java.util.*;
-
-public class WeakVertices {
-
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		while (true) {
-			int n = in.nextInt();
-			if (n == -1)
-				break;
-			long[][] adm = new long[n][n];
-			for (int i = 0; i < adm.length; i++)
-				for (int j = 0; j < adm.length; j++)
-					adm[i][j] = in.nextLong();
-			long[][] ans = matrixPower(adm, 3);
-			for (int i = 0; i < ans.length; i++)
-				for (int j = 0; j < ans.length; j++)
-					if (i == j && ans[i][j] == 0)
-						System.out.print(i + " ");
-			System.out.println(" ");
-
-		}
-
-	}
-
-//Author: William Fiset
-	static long[][] matrixPower(long[][] matrix, long p) {
-		if (p < 0)
-			return null;
-		final int N = matrix.length;
-		long[][] newMatrix = null;
-		if (p == 0) {
-			newMatrix = new long[N][N];
-			for (int i = 0; i < N; i++)
-				newMatrix[i][i] = 1L;
-		} else {
-
-			long[][] P = matrixDeepCopy(matrix);
-
-			while (p > 0) {
-
-				if ((p & 1L) == 1L) {
-					if (newMatrix == null)
-						newMatrix = matrixDeepCopy(P);
-					else
-						newMatrix = squareMatrixMult(newMatrix, P);
-				}
-				P = squareMatrixMult(P, P);
-				p >>= 1L;
-			}
-		}
-
-		return newMatrix;
-	}
-
-	static long[][] squareMatrixMult(long[][] m1, long[][] m2) {
-		final int N = m1.length;
-		long[][] newMatrix = new long[N][N];
-		for (int i = 0; i < N; i++)
-			for (int j = 0; j < N; j++)
-				for (int k = 0; k < N; k++)
-					newMatrix[i][j] = newMatrix[i][j] + m1[i][k] * m2[k][j];
-
-		return newMatrix;
-	}
-
-	static long[][] matrixDeepCopy(long[][] M) {
-		final int N = M.length;
-		long[][] newMatrix = new long[N][N];
-		for (int i = 0; i < N; i++)
-			newMatrix[i] = M[i].clone();
-		return newMatrix;
-	}
-
-	static class Input {
-
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-}
diff --git a/Problemas/Grafos/TopologicalSort/Dominos b/Problemas/Grafos/TopologicalSort/Dominos
deleted file mode 100644
index 1b8f683..0000000
--- a/Problemas/Grafos/TopologicalSort/Dominos
+++ /dev/null
@@ -1,90 +0,0 @@
-// https://vjudge.net/problem/UVA-11504
-import java.io.*;
-import java.util.*;
-public class Main{
-    static ArrayList<Integer>[] adjList;
-    static int[] d,t;
-    static int time;
-    static int contador;
-    static int N;
-    static char[] state;
-    static Stack<Integer> tsort;
-    public static void main (String[] args) throws IOException {
-        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
-        int cases=Integer.parseInt(bf.readLine());
-        for(int i =0;i<cases;i++){
-            String[] l1=bf.readLine().split(" ");
-            contador=0;
-            N=Integer.parseInt(l1[0]);
-            adjList=new ArrayList[N];
-            d=new int[N];
-            state=new char[N];
-            t=new int[N];
-            Arrays.fill(state,'N');
-            int m=Integer.parseInt(l1[1]);
-            for (int j = 0; j < N; j++)
-                adjList[j]=new ArrayList<>();
-            for (int j = 0; j < m; j++) {
-                String[] l2=bf.readLine().split(" ");
-                int a=Integer.parseInt(l2[0])-1;
-                int b=Integer.parseInt(l2[1])-1;
-                addEdge(a,b);
-            }
-            int[] arr=top_sort();
-            int index=0;
-            for (int j = 0; j < arr.length; j++)
-                if(state[arr[j]]=='N'){
-                    contador++;
-                    bfs(arr[j]);
-                }
-            System.out.println(contador);
-
-
-        }
-    }
-
-    static char[] bfs(int s) {
-        state[s] = 'D';
-        Queue<Integer> Q = new LinkedList<Integer>();
-        Q.add(s);
-        while (!Q.isEmpty()) {
-            int u = Q.poll();
-            for(int v : adjList[u])
-                if (state[v] == 'N') {
-                    state[v] = 'D';
-                    Q.add(v);
-                }
-            state[u] = 'E';
-        }
-        return state;
-    }
-    static void addEdge(int a, int b){
-        if(adjList[a]==null)
-            adjList[a]=new ArrayList<>();
-        adjList[a].add(b);
-    }
-    static void dfs(int u) {
-        d[u] = time++;
-        for(int v:adjList[u]) {
-            if (d[v]!=0) continue;
-            dfs(v);
-        }
-        t[u] = time++;
-        tsort.add(u);
-    }
-
-    static int[] top_sort() {
-        d = new int[N];
-        t = new int[N];
-        time = 1;
-        tsort = new Stack<>();
-        for(int u=0; u<N; u++) {
-            if (d[u] == 0) dfs(u);
-        }
-        int[] tsort_arr = new int[N];
-        for (int i = 0; i < N; i++)
-            tsort_arr[i] = tsort.pop();
-        return tsort_arr;
-    }
-
-}
diff --git a/Problemas/Grafos/TopologicalSort/Find the Permutation.cpp b/Problemas/Grafos/TopologicalSort/Find the Permutation.cpp
deleted file mode 100644
index 73d5788..0000000
--- a/Problemas/Grafos/TopologicalSort/Find the Permutation.cpp	
+++ /dev/null
@@ -1,81 +0,0 @@
-//https://codeforces.com/contest/2056/problem/B
-using namespace std;
-#include <bits/stdc++.h>
-#include <iostream>
-#include <vector>
-#include <unordered_map>
-#include <unordered_set>
-#include <map>
-#include <set>
-#include <algorithm>
-#include <climits>
-#include <cmath>
-#include <math.h>
-#include <iomanip>
-#include <deque>
-#include <queue>
-#include <stack>
-#include <string>
-#include <utility>
-#include <numeric>
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define MAXN 100000
-
-vector<vector<int>> adj;
-stack<int> Q;
-vector<int> Toposort;
-vector<bool> visited;
-
-void dfs(int u)
-{
-    visited[u] = true;
-    for (const auto &v : adj[u])
-        if (!visited[v])
-            dfs(v);
-    Q.push(u);
-}
-
-void solve()
-{
-    int t;
-    cin >> t;
-    while (t--)
-    {
-        int n;
-        cin >> n;
-        adj.assign(n, vector<int>());
-        fori(i, 0, n)
-        {
-            string s;
-            cin >> s;
-            fori(j, 0, n)
-            {
-                if (s[j] == '1' && j > i)
-                    adj[i].push_back(j);
-            }
-        }
-        visited.assign(n, false);
-        fori(u, 0, n)
-          if (!visited[u])
-            dfs(u);
-        while (!Q.empty())
-        {
-            Toposort.push_back(Q.top());
-            Q.pop();
-        }
-
-        for (const auto &i : Toposort)
-            cout << i+1 << " ";
-        Toposort.clear();
-        cout << ln;
-    }
-}
-
-int main()
-{
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    solve();
-    return 0;
-}
diff --git a/Problemas/Grafos/TopologicalSort/LongestPathDAG.java b/Problemas/Grafos/TopologicalSort/LongestPathDAG.java
deleted file mode 100644
index 18f21f1..0000000
--- a/Problemas/Grafos/TopologicalSort/LongestPathDAG.java
+++ /dev/null
@@ -1,52 +0,0 @@
-//https://atcoder.jp/contests/dp/tasks/dp_g?lang=en
-import java.io.*;
-import java.util.*;
-
-public class LongestPathInDAG {
-	static ArrayList<Integer>[] adj;
-	static int n;
-	static int[] in_deg;
-
-	@SuppressWarnings("unchecked")
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st = new StringTokenizer(in.readLine());
-		n = Integer.parseInt(st.nextToken());
-		int m = Integer.parseInt(st.nextToken());
-		adj = new ArrayList[n];
-		for (int i = 0; i < n; i++)
-			adj[i] = new ArrayList<>();
-		in_deg = new int[n];
-		for (int i = 0; i < m; i++) {
-			st = new StringTokenizer(in.readLine());
-			int a = Integer.parseInt(st.nextToken()) - 1;
-			int b = Integer.parseInt(st.nextToken()) - 1;
-			adj[a].add(b);
-			in_deg[b]++;
-		}
-		System.out.println(kahn());
-
-	}
-
-	static int kahn() {
-		Queue<Integer> Q = new LinkedList<>();
-		for (int i = 0; i < n; i++)
-			if (in_deg[i] == 0)
-				Q.add(i);
-		int res = -1;
-		while (!Q.isEmpty()) {
-			int level = Q.size();
-			for (int i = 0; i < level; i++) {
-				int u = Q.poll();
-				for (int v : adj[u]) {
-					in_deg[v]--;
-					if (in_deg[v] == 0)
-						Q.add(v);
-				}
-			}
-			res++;
-		}
-		return res;
-	}
-
-}
diff --git a/Problemas/Grafos/TopologicalSort/MouseHunt.java b/Problemas/Grafos/TopologicalSort/MouseHunt.java
deleted file mode 100644
index 188e41f..0000000
--- a/Problemas/Grafos/TopologicalSort/MouseHunt.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*https://codeforces.com/problemset/problem/1027/D*/
-
-import java.io.*;
-import java.util.*;
-
-public class MouseHunt {
-	static int n;
-	static ArrayList<Integer>[] adj;
-	static boolean[] state;
-	static Stack<Integer> Toposort;
-
-	public static void MouseHunt(String[] args) throws Exception {
-		Input in = new Input(System.in);
-		n = in.nextInt();
-		int[] costos = new int[n];
-		for (int i = 0; i < n; i++)
-			costos[i] = in.nextInt();
-		adj = new ArrayList[n];
-		for (int i = 0; i < n; i++)
-			adj[i] = new ArrayList<>();
-		for (int i = 0; i < n; i++)
-			adj[i].add(in.nextInt() - 1);
-		System.out.println(solve(costos));
-	}
-
-	static int solve(int[] costos) {
-		int ans = 0;
-		boolean[] visited = new boolean[n];
-		for (int i : TopSort()) {
-			int min = Integer.MAX_VALUE;
-			if (!visited[i]) {
-				ArrayList<Integer> cost = bfs(i, visited);
-				if (!cost.isEmpty()) {
-					for (int j : cost)
-						min = Math.min(min, costos[j]);
-					ans += min;
-				}
-			}
-		}
-		return ans;
-	}
-
-	static ArrayList<Integer> bfs(int s, boolean[] visited) {
-		ArrayList<Integer> ciclos = new ArrayList<>();
-		Queue<Integer> Q = new LinkedList<>();
-		Stack<Integer> S = new Stack<>();
-		Q.add(s);
-		visited[s] = true;
-		while (!Q.isEmpty()) {
-			int u = Q.poll();
-			S.push(u);
-			for (int v : adj[u])
-				if (!visited[v]) {
-					visited[v] = true;
-					Q.add(v);
-				} else if (S.contains(v)) {
-					int t = S.pop();
-					ciclos.add(t);
-					while (t != v) {
-						t = S.pop();
-						ciclos.add(t);
-					}
-				}
-		}
-		return ciclos;
-	}
-
-	static void dfs(int s) {
-		state[s] = true;
-		for (int v : adj[s])
-			if (!state[v])
-				dfs(v);
-		Toposort.add(s);
-	}
-
-	static int[] TopSort() {
-		state = new boolean[n];
-		Toposort = new Stack<>();
-		for (int i = 0; i < n; i++)
-			if (!state[i])
-				dfs(i);
-		int ans[] = new int[n];
-		for (int i = 0; i < n; i++)
-			ans[i] = Toposort.pop();
-		return ans;
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-	}
-}
diff --git a/Problemas/Grafos/TopologicalSort/OrderingTask.java b/Problemas/Grafos/TopologicalSort/OrderingTask.java
deleted file mode 100644
index f8ad603..0000000
--- a/Problemas/Grafos/TopologicalSort/OrderingTask.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/* https://vjudge.net/problem/UVA-10305 */
-
-import java.io.*;
-import java.util.*;
-
-public class OrderingTasks {
-
-    static int n;
-    static int time;
-    static ArrayList<Integer>[] adj;
-    static boolean[] state;
-    static int[] d; //tiempo descubrimiento de cada vertice
-    static int[] t; //tiempo de finalizacion de cada vertice(vecinos ya visitads del vertice actual)
-    static  Stack<Integer>Toposort;
-
-    public static void main(String[] args) throws IOException {
-        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-        while (true){
-            StringTokenizer st = new StringTokenizer(in.readLine());
-            n = Integer.parseInt(st.nextToken());
-            int m = Integer.parseInt(st.nextToken());
-            if(n==0 && m ==0) break;
-            adj = new ArrayList[n];
-            for (int i = 0; i < n; i++)
-                adj[i] = new ArrayList<>();
-            for (int i = 0; i < m; i++) {
-                st = new StringTokenizer(in.readLine());
-                int a = Integer.parseInt(st.nextToken()) -1;
-                int b = Integer.parseInt(st.nextToken()) -1;
-                adj[a].add(b);
-            }
-            System.out.println(String.join(" ",TopSort()));
-
-        }
-    }
-
-    static void dfs(int s){
-        d[s] = time;
-        time++;
-        state[s] = true;
-        for(int v: adj[s])
-            if(!state[v])
-                dfs(v);
-        t[s] = time;
-        time++;
-        Toposort.push(s);
-    }
-
-    static String[] TopSort() {
-        time = 1;
-        d = new int[n];
-        t = new int[n];
-        state = new boolean[n];
-        Toposort = new Stack<>();
-        for (int i = 0; i < n; i++)
-            if (!state[i]) dfs(i);
-        String[] ans = new String[n];
-        for (int i = 0;i<n;i++)
-            ans[i] = String.valueOf(Toposort.pop() + 1);
-        return ans;
-    }
-}
diff --git a/Problemas/Grafos/TopologicalSort/PickUpSticks.java b/Problemas/Grafos/TopologicalSort/PickUpSticks.java
deleted file mode 100644
index b13ccd8..0000000
--- a/Problemas/Grafos/TopologicalSort/PickUpSticks.java
+++ /dev/null
@@ -1,98 +0,0 @@
-import java.io.*;
-import java.util.*;
-
-public class PickUpSticks {
-	static ArrayList<Integer>[] adj;
-	static int n;
-
-	@SuppressWarnings("unchecked")
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		n = in.nextInt();
-		adj = new ArrayList[n];
-		for (int i = 0; i < n; i++)
-			adj[i] = new ArrayList<>();
-		int m = in.nextInt();
-		for (int i = 0; i < m; i++)
-			adj[in.nextInt() - 1].add(in.nextInt() - 1);
-		if (isDag())
-			for (int i : topoSort())
-				System.out.println(i+1);
-		else
-			System.out.println("IMPOSSIBLE");
-
-	}
-
-	static int[] topoSort() {
-		int state[] = new int[n];
-		List<Integer> r = new ArrayList<Integer>();
-		for (int v = 0; v < n; v++)
-			if (state[v] == 0 && !dfsTS(v, state, r))
-				return null;
-		int t = r.size(), a[] = new int[t], i;
-		for (i = 0; i < t; i++)
-			a[i] = r.get(t - 1 - i);
-		return a;
-
-	}
-
-	static boolean isDag() {
-		return topoSort() != null;
-	}
-
-	static boolean dfsTS(int v, int[] state, List<Integer> r) {
-		state[v] = 1;
-		for (int w : adj[v])
-			if (state[w] == 1 || (state[w] == 0 && !dfsTS(w, state, r)))
-				return false;
-		state[v] = 2;
-		r.add(v);
-		return true;
-
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-	}
-
-}
diff --git a/Problemas/Grafos/Trees/LCA/LowestCommonAncestor.java b/Problemas/Grafos/Trees/LCA/LowestCommonAncestor.java
deleted file mode 100644
index 5d5d511..0000000
--- a/Problemas/Grafos/Trees/LCA/LowestCommonAncestor.java
+++ /dev/null
@@ -1,225 +0,0 @@
-//https://www.spoj.com/problems/LCASQ/
-import java.util.*;
-import java.io.*;
-
-public class LowestCommonAncestor {
-	@SuppressWarnings("unchecked")
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		int n = in.nextInt();
-		ArrayList<Integer>[] adj = new ArrayList[n];
-		for (int i = 0; i < n; i++)
-			adj[i] = new ArrayList<Integer>();
-		for (int i = 0; i < n; i++) {
-			int m = in.nextInt();
-			for (int j = 0; j < m; j++)
-				adj[i].add(in.nextInt());
-		}
-		LCA me = new LCA(adj, 0);
-		int q = in.nextInt();
-		for (int i = 0; i < q; i++)
-			System.out.println(me.getLCA(in.nextInt(), in.nextInt()));
-
-	}
-
-	static class LCA {
-		int[] H, E, L;
-		SegmentTreeArray tree;
-
-		int getLCA(int a, int b) {
-			int ma = Math.min(H[a], H[b]);
-			int mb = H[a] + H[b] - ma;
-			int pos = tree.getPosMin(ma, mb);
-			return E[pos];
-		}
-
-		LCA(ArrayList<Integer>[] adjList, int raiz) {
-			int n = adjList.length;
-			ArrayList<Integer> EL = new ArrayList<Integer>();
-			ArrayList<Integer> LL = new ArrayList<Integer>();
-			H = new int[n];
-			Arrays.fill(H, -1);
-			preprocess(EL, LL, H, adjList, raiz, 0);
-			E = new int[EL.size()];
-			L = new int[LL.size()];
-			int k = 0;
-			for (Integer x : EL) {
-				E[k] = x;
-				k++;
-			}
-			k = 0;
-			for (Integer x : LL) {
-				L[k] = x;
-				k++;
-			}
-			tree = new SegmentTreeArray(L);
-		}
-
-		void preprocess(ArrayList<Integer> EL, ArrayList<Integer> LL, int[] H, ArrayList<Integer>[] adjList, int raiz,
-				int nivel) {
-			EL.add(raiz);
-			if (H[raiz] == -1)
-				H[raiz] = EL.size() - 1;
-			LL.add(nivel);
-			for (Integer s : adjList[raiz]) {
-				preprocess(EL, LL, H, adjList, s, nivel + 1);
-				EL.add(raiz);
-				LL.add(nivel);
-			}
-		}
-
-	}
-
-	static class SegmentTreeArray {
-		int[] start, end, posMin, A;
-		int n;
-
-		public SegmentTreeArray(int[] A) {
-			this.A = A;
-			n = A.length;
-			start = new int[4 * n];
-			end = new int[4 * n];
-			posMin = new int[4 * n];
-			// start[i] == -1 significa que no existe el nodo
-			Arrays.fill(start, -1);
-			initSegmentTree(A);
-		}
-
-		void initSegmentTree(int[] A) {
-			createTree(0, 0, n - 1);
-			computePosMin(A, 0);
-		}
-
-		int computePosMin(int[] A, int node) {
-			if (start[node] == -1)
-				return -1;
-			if (start[node] == end[node]) {
-				posMin[node] = start[node];
-				return posMin[node];
-			}
-			if (A[computePosMin(A, 2 * node + 1)] < A[computePosMin(A, 2 * node + 2)])
-				posMin[node] = computePosMin(A, 2 * node + 1);
-			else
-				posMin[node] = computePosMin(A, 2 * node + 2);
-			return posMin[node];
-		}
-
-		void createTree(int node, int s, int e) {
-			if (s > e)
-				return;
-			start[node] = s;
-			end[node] = e;
-			if (s == e) {
-				return;
-			}
-			int mid = (s + e) / 2;
-			createTree(2 * node + 1, s, mid);
-			createTree(2 * node + 2, mid + 1, e);
-		}
-
-		void set(int pos, int value) {
-			set(pos, value, 0);
-		}
-
-		void set(int pos, int value, int node) {
-			if (start[node] == -1 || start[node] > pos || end[node] < pos)
-				return;
-			if (start[node] == end[node]) {
-				posMin[node] = start[node];
-				A[posMin[node]] = value;
-				return;
-			}
-			int mid = (start[node] + end[node]) / 2;
-			if (pos <= mid)
-				set(pos, value, 2 * node + 1);
-			else
-				set(pos, value, 2 * node + 2);
-			if (A[posMin[2 * node + 1]] < A[posMin[2 * node + 2]])
-				posMin[node] = posMin[2 * node + 1];
-			else
-				posMin[node] = posMin[2 * node + 2];
-		}
-
-		int getPosMin(int low, int high) {
-			return getPosMin(low, high, 0);
-		}
-
-		int getPosMin(int low, int high, int node) {
-			if (start[node] == -1)
-				return -1;
-			if (low == start[node] && high == end[node]) {
-				return posMin[node];
-			}
-			int mid = (start[node] + end[node]) / 2;
-			if (high <= mid)
-				return getPosMin(low, high, 2 * node + 1);
-			if (low > mid)
-				return getPosMin(low, high, 2 * node + 2);
-			int p, q;
-			p = getPosMin(low, mid, 2 * node + 1);
-			q = getPosMin(mid + 1, high, 2 * node + 2);
-			if (A[p] < A[q])
-				return p;
-			else
-				return q;
-		}
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		long nextLong() {
-			return Long.parseLong(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public String nextLine() throws Exception {
-			return br.readLine();
-		}
-
-		public void close() throws IOException {
-			br.close();
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-		public boolean ready() throws IOException {
-			return br.ready();
-		}
-
-	}
-
-}
-
diff --git a/Problemas/Grafos/Trees/MinimunSpanningTree/AFeastForCast.java b/Problemas/Grafos/Trees/MinimunSpanningTree/AFeastForCast.java
deleted file mode 100644
index ccdf8e8..0000000
--- a/Problemas/Grafos/Trees/MinimunSpanningTree/AFeastForCast.java
+++ /dev/null
@@ -1,94 +0,0 @@
-//https://open.kattis.com/problems/cats
-import java.io.*;
-import java.util.*;
-class AFeastForCats {
-    static ArrayList<Edge>[] adjList;
-    static char[] state;
-    static int[] d;
-    static final int INF = 2147483647;
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
-        int t=bf.read()-'0';
-        bf.readLine();
-        for (int times = 0; times < t; times++) {
-            String[] l1=bf.readLine().split(" ");
-            int milk=Integer.parseInt(l1[0]);
-            int n=Integer.parseInt(l1[1]);
-            state=new char[n];
-            d=new int[n];
-            adjList=new ArrayList[n];
-            for (int i = 0; i < n; i++)
-                adjList[i]=new ArrayList<>();
-            int size=(n*(n-1))/2;
-            for (int i = 0; i < size; i++) {
-                String[] l2=bf.readLine().split(" ");
-                int a=Integer.parseInt(l2[0]);
-                int b=Integer.parseInt(l2[1]);
-                int w=Integer.parseInt(l2[2]);
-                addEdge(a,b,w);
-            }
-            dijkstra(0);
-            int c=0;
-            for (int i:d)
-                c+=1+i;
-            if(c<=milk)
-                System.out.println("yes");
-            else
-                System.out.println("no");
-        }
-    }
-    static void addEdge(int a,int b, int w){
-        adjList[a].add(new Edge(b,w));
-        adjList[b].add(new Edge(a,w));
-    }
-    static void dijkstra(int s) {
-        Arrays.fill(d, INF);
-        Arrays.fill(state, 'N');
-        d[s] = 0; state[s] = 'D';
-        TreeSet<Edge> Q = new TreeSet<Edge>();
-        Q.add(new Edge(s, d[s]));
-        while (!Q.isEmpty()) {
-            Edge e = Q.pollFirst();
-            int u = e.vertex;
-            if (state[u] != 'E') {
-                for (Edge ee : adjList[u]) {
-                    int v = ee.vertex;
-                    int w = ee.weight;
-                    if (state[v] != 'E') {
-                        if (w < d[v]) {
-                            d[v] = w;
-                            state[v] = 'D';
-                            Q.add(new Edge(v, d[v]));
-                        }
-                    }
-                }
-                state[u] = 'E';
-            }
-        }
-
-    }
-
-    private static class Edge implements Comparable<Edge> {
-        int vertex;
-        int weight;
-        Edge(int v, int w) {
-            vertex = v;
-            weight = w;
-        }
-        public boolean equals(Object o) {
-            if (o instanceof Edge)
-                return (vertex==((Edge)o).vertex && weight==((Edge)o).weight);
-            return false;
-        }
-        public int compareTo(Edge o) {
-            if (weight < o.weight) return -1;
-            if (weight > o.weight) return 1;
-            if (vertex < o.vertex) return -1;
-            if (vertex > o.vertex) return 1;
-            return 0;
-        }
-        public String toString() {
-            return "(" + vertex + ", " + weight + ")";
-        }
-    }
-}
diff --git a/Problemas/Grafos/Trees/MinimunSpanningTree/GettingOverIt.java b/Problemas/Grafos/Trees/MinimunSpanningTree/GettingOverIt.java
deleted file mode 100644
index edc206a..0000000
--- a/Problemas/Grafos/Trees/MinimunSpanningTree/GettingOverIt.java
+++ /dev/null
@@ -1,80 +0,0 @@
-//Private contest
-import java.util.*;
-import java.io.*;
-import java.awt.Point;
-
-public class GettingOverIt {
-	static List<Point> puntos;
-	static HashMap<Point, Double> d;
-	static HashMap<Point, Boolean> visited;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st;
-		int n = Integer.parseInt(in.readLine());
-		puntos = new ArrayList<>();
-		d = new HashMap<>();
-		visited = new HashMap<>();
-		Point s = new Point(0, 0);
-		puntos.add(s);
-		d.put(s, 0d);
-		visited.put(s, false);
-		for (int i = 0; i < n; i++) {
-			st = new StringTokenizer(in.readLine());
-			int x = Integer.parseInt(st.nextToken());
-			int y = Integer.parseInt(st.nextToken());
-			Point p = new Point(x, y);
-			puntos.add(p);
-			d.put(p, Double.POSITIVE_INFINITY);
-			visited.put(p, false);
-		}
-		prim(s);
-		long ans = 0;
-		for (double cost : d.values())
-			ans += cost;
-		System.out.println(ans);
-
-	}
-
-	static void prim(Point s) {
-		TreeSet<Edge> Q = new TreeSet<>();
-		Q.add(new Edge(s, 0d));
-		while (!Q.isEmpty()) {
-			Edge e = Q.pollFirst();
-			Point u = e.vertex;
-			if (!visited.get(u)) {
-				visited.put(u, true);
-				for (Point v : puntos) {
-					if (visited.get(v))
-						continue;
-					double w = Math.pow(u.x - v.x, 2) + Math.pow(u.y - v.y, 2);
-					if (w < d.get(v)) {
-						d.put(v, w);
-						Q.add(new Edge(v, w));
-					}
-				}
-			}
-		}
-	}
-
-	static class Edge implements Comparable<Edge> {
-		Point vertex;
-		double weight;
-
-		Edge(Point v, double w) {
-			this.vertex = v;
-			this.weight = w;
-		}
-
-		public int compareTo(Edge e) {
-			if (weight < e.weight)
-				return -1;
-			if (weight > e.weight)
-				return 1;
-			if (vertex.x == e.vertex.x)
-				return vertex.y - e.vertex.y;
-			return vertex.x - e.vertex.x;
-		}
-	}
-
-}
diff --git a/Problemas/Grafos/Trees/MinimunSpanningTree/MinCostToConnectAllPoints.java b/Problemas/Grafos/Trees/MinimunSpanningTree/MinCostToConnectAllPoints.java
deleted file mode 100644
index 20c2b77..0000000
--- a/Problemas/Grafos/Trees/MinimunSpanningTree/MinCostToConnectAllPoints.java
+++ /dev/null
@@ -1,90 +0,0 @@
-//LeetCode1584
-import java.util.*;
-
-public class MinCostToConnectAllPoints {
-
-	static int minCostConnectPoints(int[][] points) {
-		return prim(points);
-	}
-
-	static int prim(int[][] points) {
-		HashMap<Point, Integer> d = new HashMap<>();
-		HashMap<Point, Boolean> visited = new HashMap<>();
-		TreeSet<Edge> Q = new TreeSet<>();
-		Point s = new Point(points[0][0], points[0][1]);
-		d.put(s, 0);
-		Q.add(new Edge(s, 0));
-		while (!Q.isEmpty()) {
-			Edge e = Q.pollFirst();
-			Point u = e.vertex;
-			int ru = u.x;
-			int cu = u.y;
-			if (visited.get(u) == null) {
-				visited.put(u, true);
-				for (int[] ee : points) {
-					Point v = new Point(ee[0], ee[1]);
-					if (u.equals(v) || visited.get(v) != null)
-						continue;
-					int rv = v.x;
-					int cv = v.y;
-					int w = cost(ru, cu, rv, cv);
-					if (d.get(v) == null || w < d.get(v)) {
-						d.put(v, w);
-						Q.add(new Edge(v, w));
-					}
-				}
-			}
-
-		}
-		int ans = 0;
-		for (int w : d.values())
-			ans += w;
-		return ans;
-	}
-
-	static int cost(int x1, int y1, int x2, int y2) {
-		return Math.abs(x1 - x2) + Math.abs(y1 - y2);
-	}
-
-	static class Point {
-		int x;
-		int y;
-
-		Point(int x, int y) {
-			this.x = x;
-			this.y = y;
-		}
-
-		public int hashCode() {
-			return Objects.hash(x, y);
-		}
-
-		public boolean equals(Object o) {
-			Point op = (Point) o;
-			return x == op.x && y == op.y;
-		}
-	}
-
-	static class Edge implements Comparable<Edge> {
-		Point vertex;
-		int weight;
-
-		Edge(Point p, int w) {
-			this.vertex = p;
-			this.weight = w;
-		}
-
-		public int compareTo(Edge o) {
-			if (weight < o.weight)
-				return -1;
-			if (weight > o.weight)
-				return 1;
-			if (vertex.y == o.vertex.y)
-				return Integer.compare(vertex.x, o.vertex.x);
-			return Integer.compare(vertex.y, o.vertex.y);
-
-		}
-
-	}
-
-}
diff --git a/Problemas/Grafos/Trees/MinimunSpanningTree/NatureReserve.java b/Problemas/Grafos/Trees/MinimunSpanningTree/NatureReserve.java
deleted file mode 100644
index 7eb6e90..0000000
--- a/Problemas/Grafos/Trees/MinimunSpanningTree/NatureReserve.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*https://open.kattis.com/problems/naturereserve*/
-
-import java.io.*;
-import java.util.*;
-
-public class NautureDeserve {
-	
-	static int n;
-	static ArrayList<Edge>[] adj;
-	static TreeSet<Edge> Q;
-	static long[] d;
-
-	@SuppressWarnings("unchecked")
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st;
-		int t = Integer.parseInt(in.readLine());
-		for (int cases = 0; cases < t; cases++) {
-			st = new StringTokenizer(in.readLine());
-			n = Integer.parseInt(st.nextToken());
-			adj = new ArrayList[n];
-			for (int i = 0; i < n; i++)
-				adj[i] = new ArrayList<>();
-			int m = Integer.parseInt(st.nextToken());
-			int l = Integer.parseInt(st.nextToken());
-			int s = Integer.parseInt(st.nextToken());
-			Q = new TreeSet<Edge>();
-			d = new long[n];
-			Arrays.fill(d, Integer.MAX_VALUE);
-			st = new StringTokenizer(in.readLine());
-			for (int i = 0; i < s; i++) {
-				int v = Integer.parseInt(st.nextToken()) - 1;
-				Q.add(new Edge(v, 0));
-				d[v] = 0;
-			}
-			for (int i = 0; i < m; i++) {
-				st = new StringTokenizer(in.readLine());
-				int a = Integer.parseInt(st.nextToken()) - 1;
-				int b = Integer.parseInt(st.nextToken()) - 1;
-				long w = Long.parseLong(st.nextToken());
-				adj[a].add(new Edge(b, w + l));
-				adj[b].add(new Edge(a, w + l));
-			}
-			prim();
-			System.out.println(Arrays.stream(d).sum());
-			//Also works:
-			//System.out.println(Arrays.stream(d).sum() + (n - s) * l);
-			//This way we don't need to add l to the weight of each edge but n,s and l must be long.
-		}
-	}
-
-	static void prim() {
-		boolean[] state = new boolean[n];
-		while (!Q.isEmpty()) {
-			Edge e = Q.pollFirst();
-			int u = e.vertex;
-			if (!state[u]) {
-				state[u] = true;
-				for (Edge ee : adj[u]) {
-					int v = ee.vertex;
-					long w = ee.weight;
-					if (!state[v] && w < d[v]) {
-						d[v] = w;
-						Q.add(new Edge(v, d[v]));
-					}
-				}
-			}
-		}
-	}
-
-	static class Edge implements Comparable<Edge> {
-		int vertex;
-		long weight;
-
-		Edge(int v, long w) {
-			this.vertex = v;
-			this.weight = w;
-		}
-
-		public int compareTo(Edge o) {
-			if (weight < o.weight)
-				return -1;
-			if (weight > o.weight)
-				return 1;
-			if (vertex < o.vertex)
-				return -1;
-			if (vertex > o.vertex)
-				return 1;
-			return 0;
-		}
-	}
-}
diff --git a/Problemas/Grafos/Trees/MinimunSpanningTree/RoadReparation.cpp b/Problemas/Grafos/Trees/MinimunSpanningTree/RoadReparation.cpp
deleted file mode 100644
index 5d07ce7..0000000
--- a/Problemas/Grafos/Trees/MinimunSpanningTree/RoadReparation.cpp
+++ /dev/null
@@ -1,101 +0,0 @@
-//https://cses.fi/problemset/task/1675/
-using namespace std;
-#include <bits/stdc++.h>
-#include <iostream>
-#include <vector>
-#include <unordered_map>
-#include <unordered_set>
-#include <algorithm>
-#include <climits>
-#include <cmath>
-#include <math.h>
-#include <iomanip>
-#include <set>
-#include <deque>
-#include <queue>
-#include <stack>
-#include <string>
-#include <utility>
-#include <numeric>
-#define PI acos(-1)
-#define toRadians(angle) PI *angle / 180
-#define toDegree(angle) (180 * angle) / PI
-#define fori(i, k, n) for (int i = k; i < (n); i++)
-#define MAXN 200000
-#define ln "\n"
-
-struct point
-{
-    long long x, y;
-    point() {}
-    point(long long x, long long y) : x(x), y(y) {}
-};
-
-const long long INF = LONG_MAX;
-vector<vector<pair<int, long long>>> adj;
-vector<bool> visited;
-int n;
-
-long long prim(int s)
-{
-    vector<long long> d(n, INF);
-    visited.assign(n, false);
-    d[s] = 0;
-    set<pair<long long, int>> Q;
-    Q.insert({d[s], s});
-    while (!Q.empty())
-    {
-        int u = Q.begin()->second;
-        Q.erase(Q.begin());
-        if (visited[u])
-            continue;
-        visited[u] = true;
-        for (auto ee : adj[u])
-        {
-            int v = ee.first;
-            long long w = ee.second;
-            if (!visited[v] && w < d[v])
-            {
-                d[v] = w;
-                Q.insert({d[v], v});
-            }
-        }
-    }
-    long long total_cost = 0;
-    for (const auto &c : d)
-        total_cost += c;
-    return total_cost;
-}
-
-void solve()
-{
-    int m;
-    cin >> n >> m;
-    adj.assign(n, vector<pair<int, long long>>());
-    fori(i, 0, m)
-    {
-        int a, b;
-        long long w;
-        cin >> a >> b >> w;
-        a--;
-        b--;
-        adj[a].push_back({b, w});
-        adj[b].push_back({a, w});
-    }
-    long long cost = prim(0);
-    for (const auto &i : visited)
-        if (!i)
-        {
-            cout << "IMPOSSIBLE" << ln;
-            return;
-        }
-    cout << cost << ln;
-}
-
-int main()
-{
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    solve();
-    return 0;
-}
diff --git a/Problemas/Maths/Combinatories/Christmas Party.cpp b/Problemas/Maths/Combinatories/Christmas Party.cpp
deleted file mode 100644
index 9b8620b..0000000
--- a/Problemas/Maths/Combinatories/Christmas Party.cpp	
+++ /dev/null
@@ -1,73 +0,0 @@
-//https://cses.fi/problemset/task/1717/
-#include <bits/stdc++.h>
-using namespace std;
-#define dll double long
-#define ll long long
-#define Pair pair<int,int>
-#define eb emplace_back
-#define pb push_back
-#define all(x) (x).begin(), (x).end()
-#define ln "\n"
-#define mk(x,y) make_pair(x,y)
-#define For(i, a, b) for(int i = a; i < b; i++)
-#define Rfor(i, a, b) for(int i = a; i >= b; i--)
-const int INF = 1e9;
-const int MAX = 1005;
-const int MOD=1e9+7;
-vector<ll> fact;
-vector<ll> invFact;
-
-ll modPow(ll base, ll exp, int mod) {
-    ll res = 1, x = base % mod;
-    while (exp > 0) {
-        if (exp & 1)
-            res = res * x % mod;
-        x = (x * x) % mod;
-        exp >>= 1;
-    }
-    return res;
-}
-void getFactorials(int n) {
-    fact.resize(n + 1);
-    invFact.resize(n + 1);
-    fact[0] = invFact[0] = 1;
-    for (int i = 1; i <= n; i++) {
-        fact[i] = fact[i - 1] * i % MOD;
-    }
-    invFact[n] = modPow(fact[n], MOD - 2, MOD);
-    for (int i = n - 1; i >= 1; i--) {
-        invFact[i] = invFact[i + 1] * (i + 1) % MOD;
-    }
-}
-ll ncr(int n, int r) {
-    if (r > n || r < 0)
-        return 0;
-    return fact[n] * invFact[r] % MOD * invFact[n - r] % MOD;
-}
-ll add(ll a, ll b) {
-    a+=b;
-    if (a>=MOD)
-        a-=MOD;
-    else if(a<0)
-        return MOD+a;
-    return a;
-}
-int main() {
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    int n;
-    cin>>n;
-    getFactorials(n);
-    ll ans=fact[n];
-    ll sign=-1;
-    For(i,1,n+1) {
-        ll val=sign*ncr(n,i)*fact[n-i]%MOD;
-        ans=add(ans%MOD,val);
-        sign*=-1;
-    }
-    cout<<ans<<endl;
-    return 0;
-}
-
-//freopen("socdist.in", "r",stdin);
-//fr    eopen("socdist.out", "w", stdout)
diff --git a/Problemas/Maths/Combinatories/Count Good Numbers.cpp b/Problemas/Maths/Combinatories/Count Good Numbers.cpp
deleted file mode 100644
index ae534af..0000000
--- a/Problemas/Maths/Combinatories/Count Good Numbers.cpp	
+++ /dev/null
@@ -1,27 +0,0 @@
-//https://leetcode.com/problems/count-good-numbers/description/
-class Solution {
-public:
-    long long binpow(long long a, long long b, long long m) {
-        a %= m;
-        long long res = 1;
-        while (b > 0) {
-            if (b & 1)
-                res = res * a % m;
-            a = a * a % m;
-            b >>= 1;
-        }
-        return res;
-    }
-
-    long long countGoodNumbers(long long n) {
-        const int MOD = 1e9 + 7;
-        long long evenCount = (n + 1) >> 1;
-        long long oddCount = n >> 1;
-
-        long long fivePow = binpow(5, evenCount, MOD);
-        long long fourPow = binpow(4, oddCount, MOD);
-
-        long long ans = (fivePow * fourPow) % MOD;
-        return ans;
-    }
-};
diff --git a/Problemas/Maths/NumberTheory/AddDigits.cpp b/Problemas/Maths/NumberTheory/AddDigits.cpp
deleted file mode 100644
index 8f4640b..0000000
--- a/Problemas/Maths/NumberTheory/AddDigits.cpp
+++ /dev/null
@@ -1,26 +0,0 @@
-#https://leetcode.com/problems/add-digits/?envType=problem-list-v2&envId=number-theory
-
-# use congruence formula:  https://en.wikipedia.org/wiki/Digital_root
-class Solution {
-public:
-    int addDigits(int num) {
-        return (num == 0) ? 0:1 +(num - 1) % 9;
-    }
-};
-
-#iterative version:
-class Solution {
-public:
-    int addDigits(int num) {
-        int dig=0;
-        while(num!=0){
-            dig=dig+num%10;
-            num/=10;
-            if(num==0 && dig>=10){
-                num=dig;
-                dig=0;
-            }
-            }
-            return dig;
-        }  
-};
diff --git a/Problemas/Maths/NumberTheory/CommonDivisors.cpp b/Problemas/Maths/NumberTheory/CommonDivisors.cpp
deleted file mode 100644
index 424e64c..0000000
--- a/Problemas/Maths/NumberTheory/CommonDivisors.cpp
+++ /dev/null
@@ -1,59 +0,0 @@
-//https://cses.fi/problemset/task/1081
-
-#include <iostream>
-#include <vector>
-#include <algorithm>
-#include <unordered_set>
-using namespace std;
- 
-vector<int> get_divisors(int n){
-    vector<int> divisors;
-    for (int i = 1; i * i <= n; i++){
-        if (n % i == 0){
-            divisors.push_back(i);
-            if (i != n / i){
-                divisors.push_back(n / i);
-            }
-        }
-    }
-    return divisors;    
-} 
- 
-int main() {
-    ios::sync_with_stdio(0);
-    cin.tie(0);
- 
-    int n;
-    cin >> n;
- 
-    vector<int> arr(n, 0);
-    unordered_set<int>arrSet;
-    int maxi = 0;
-    for (int i = 0; i < n; i++){
-        cin >> arr[i];
-        if (arrSet.find(arr[i]) == arrSet.end()) 
-            arrSet.insert(arr[i]); 
-        else{
-            maxi = max(maxi, arr[i]); //para numeros repetidos, puede que el gcd entre dos numeros sean ellos mismos
-        }
-    }
-    sort(arr.begin(), arr.end());
-    unordered_set<int>div;
-      
-    for (int i = n - 1; i >= 0; i--){
-        vector<int> divisors = get_divisors(arr[i]);
-        if (arr[i] / 2 < maxi && i == n - 1) // si ya tenemos un numero guardado en maxi, verificamos si el divisisor siguiente mas grande es menor a nuestro maximo, el divisor siguiente mas grande posible es el numero mas grande del arreglo divido en 2, esto evita hacer iteraciones innecesarias.
-            break;
-        sort(divisors.begin(), divisors.end(), greater<int>());
-        for (int divisor : divisors){
-            if (div.find(divisor) == div.end())
-                div.insert(divisor);
-            else{
-                maxi = max(maxi, divisor);
-                break;
-            }
-        }
-    }
-    cout << maxi << endl;
-    return 0;
-}
diff --git a/Problemas/Maths/NumberTheory/CountPrimes.cpp b/Problemas/Maths/NumberTheory/CountPrimes.cpp
deleted file mode 100644
index c5d3565..0000000
--- a/Problemas/Maths/NumberTheory/CountPrimes.cpp
+++ /dev/null
@@ -1,31 +0,0 @@
-// https://leetcode.com/problems/count-primes/description/?envType=problem-list-v2&envId=number-theory&difficulty=MEDIUM
-
-#include <iostream>
-#include <vector>
-using namespace std;
-
-class Solution {
-public:
-    int countPrimes(int n) {
-        if (n <= 2) return 0;
-
-        vector<bool> isPrime(n, true);
-        isPrime[0] = isPrime[1] = false;
-
-        for ( int i = 2; i*i < n; i++){
-            if (isPrime[i]){
-                for (int j = i*i; j < n; j += i){ // Marca todos los mltiplos de i como no primos
-                    isPrime[j] = false;
-                }
-            }
-        }
-
-        int count = 0;
-        for (int i = 2; i < n; i++){
-            if (isPrime[i]){
-                count++;
-            }
-        }
-        return count;
-    }
-};
diff --git a/Problemas/Maths/NumberTheory/PrimeFactors.cpp b/Problemas/Maths/NumberTheory/PrimeFactors.cpp
deleted file mode 100644
index ff55e92..0000000
--- a/Problemas/Maths/NumberTheory/PrimeFactors.cpp
+++ /dev/null
@@ -1,51 +0,0 @@
-//https://vjudge.net/problem/EOlymp-8930
-using namespace std;
-#include <iostream>
-#include <vector>
-
-vector<int> primos;
-
-vector<int> sieve(int n)
-{
-    vector<bool> is_prime(n + 1, true);
-    is_prime[0] = is_prime[1] = false;
-    for (int i = 2; i <= n; i++)
-        if (is_prime[i] && (long long)i * i <= n)
-            for (int j = i * i; j <= n; j += i)
-                is_prime[j] = false;
-    vector<int> ans;
-    for (int i = 2; i < n + 1; i++)
-        if (is_prime[i])
-            ans.push_back(i);
-    return ans;
-}
-
-vector<int> solve(int n)
-{
-    vector<int> ans;
-    for (int i : primos)
-    {
-        if ((long long)i * i > n)
-            break;
-        while (n % i == 0)
-        {
-            ans.push_back(i);
-            n /= i;
-        }
-    }
-    if (n > 1)
-        ans.push_back(n);
-    return ans;
-}
-
-int main()
-{
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    primos = sieve(1 << 13);
-    int n;
-    cin >> n;
-    for (const auto &i : solve(n))
-        cout << i << "\n";
-    return 0;
-}
diff --git a/Problemas/Maths/NumberTheory/PrimeFactorsUVA.cpp b/Problemas/Maths/NumberTheory/PrimeFactorsUVA.cpp
deleted file mode 100644
index 2075385..0000000
--- a/Problemas/Maths/NumberTheory/PrimeFactorsUVA.cpp
+++ /dev/null
@@ -1,69 +0,0 @@
-//https://vjudge.net/problem/UVA-583
-using namespace std;
-#include <bits/stdc++.h>
-#define all(A) A.begin(), A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define ll long long
-#define ull unsigned long long
-
-vector<ll> primos;
-
-void precompute() {
-    int n = 46341; //El factor primo ms grande un nmero ser como mximo la raiz cuadrada de ese nmero,46341=sqrt((2^31)-1)
-    primos.assign(4792, 0); //El nmero de primos entre 2 y (2^31)-1 es 4792
-    int c = 1;
-    primos[0] = 2;
-    vector<bool> is_prime(n, true);
-    is_prime[0] = is_prime[1] = false;
-    for (ll i = 3; i <= n; i += 2) {
-        if (is_prime[i]) {
-            for (ll j = i * i; j <= n; j += i)
-                is_prime[j] = false;
-            primos[c++] = i;
-        }
-    }
-}
-
-void solve() {
-    precompute();
-    while (true) {
-        ll n;
-        cin >> n;
-        if (n == 0)
-            break;
-        cout << n << " = ";
-        if (n < 0) {
-            cout << "-1 x ";
-            n *= -1;
-        }
-        vector<string> ans;
-        for (const auto &i: primos) {
-            if (i > n)
-                break;
-            while (n % i == 0) {
-                ans.push_back(to_string(i));
-                ans.emplace_back(" x ");
-                n /= i;
-            }
-        }
-
-        if (ans.empty())
-            cout << n;
-        else {
-            ans.pop_back();
-            for (const auto &s: ans)
-                cout << s;
-        }
-        cout << ln;
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t = 1;
-    while (t--)
-        solve();
-    return 0;
-}
diff --git a/Problemas/Maths/NumberTheory/PrimePalindrome.cpp b/Problemas/Maths/NumberTheory/PrimePalindrome.cpp
deleted file mode 100644
index e8b038b..0000000
--- a/Problemas/Maths/NumberTheory/PrimePalindrome.cpp
+++ /dev/null
@@ -1,41 +0,0 @@
-// https://leetcode.com/problems/prime-palindrome/description/?envType=problem-list-v2&envId=number-theory&difficulty=MEDIUM
-
-#include <string>
-using namespace std;
-
-class Solution {
-public:
-    bool is_prime(int num){
-        if (num < 2) return false;
-        for (int i = 2; i*i <= num; ++i){
-            if ( num % i == 0) return false;
-        }
-        return true;
-    }
-    bool palindrome(int num){
-        string s = to_string(num);
-        int l = 0;
-        int r = s.size()-1;
-        while (l < r){
-            if (s[l] != s[r]) return false;
-            l++;
-            r--;
-        }
-        return true;
-    }
-    int primePalindrome(int n) {
-        n = max(n, 2);
-        while (true){
-            // Saltar rangos especficos
-            if ((n > 1e3 && n < 1e4) || 
-                (n > 1e5 && n < 1e6) || 
-                (n > 1e7 && n < 1e8)) {
-                n = pow(10, ceil(log10(n))); //Saltar al siguiente rango
-                continue;
-            }
-
-            if (is_prime(n) && palindrome(n)) return n;
-            n++;
-        }
-    }
-};
diff --git a/Problemas/Maths/NumberTheory/ThreeDivisors.py b/Problemas/Maths/NumberTheory/ThreeDivisors.py
deleted file mode 100644
index 54dcfdb..0000000
--- a/Problemas/Maths/NumberTheory/ThreeDivisors.py
+++ /dev/null
@@ -1,12 +0,0 @@
-#https://leetcode.com/problems/three-divisors/?envType=problem-list-v2&envId=number-theory&difficulty=EASY
-class Solution:
-    def isThree(self, n: int) -> bool:
-        def get_divisors(n):
-            divisors = []
-            for a in range(1, int(n**0.5) + 1):
-                if n % a == 0:
-                    divisors.append(a)
-                    if a != n // a:
-                        divisors.append(n // a)
-            return divisors
-        return len(get_divisors(n)) == 3
diff --git a/Problemas/Maths/NumberTheory/ValidSquare.cpp b/Problemas/Maths/NumberTheory/ValidSquare.cpp
deleted file mode 100644
index 3bbd2ae..0000000
--- a/Problemas/Maths/NumberTheory/ValidSquare.cpp
+++ /dev/null
@@ -1,38 +0,0 @@
-// https://leetcode.com/problems/valid-square/?envType=problem-list-v2&envId=geometry&difficulty=MEDIUM
-
-#include <iostream>
-#include <cmath>
-#include <vector>
-#include <set>
-
-class Solution {
-public:
-    bool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {
-        
-        vector<Point> points = {
-        Point (p1[0], p1[1]),
-        Point (p2[0], p2[1]),
-        Point (p3[0], p3[1]),
-        Point (p4[0], p4[1])
-        };
-
-        set<double> distances;
-        for (size_t i = 0; i < points.size() - 1; i++){
-            for (size_t j = i + 1; j < points.size(); j++){
-                double distance = points[i].distanceTo(points[j]);
-                distances.insert(distance);
-            }
-        }
-        return distances.size() == 2 && (*distances.begin() != 0);
-    }
-    class Point{
-        public:
-            double x;
-            double y;
-
-            Point(double xCoord, double yCoord) : x(xCoord), y(yCoord){}
-            double distanceTo(const Point& other) const{
-                return sqrt(pow(other.x - x, 2) + pow(other.y - y, 2));
-            }
-    };
-};
diff --git a/Problemas/Maths/NumberTheory/xOfAKindInADeckOfCards.cpp b/Problemas/Maths/NumberTheory/xOfAKindInADeckOfCards.cpp
deleted file mode 100644
index dd1e79b..0000000
--- a/Problemas/Maths/NumberTheory/xOfAKindInADeckOfCards.cpp
+++ /dev/null
@@ -1,28 +0,0 @@
-//https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/?envType=problem-list-v2&envId=number-theory&difficulty=EASY
-
-#include <iostream>
-#include <vector>
-#include <unordered_map>
-#include <numeric>
-using namespace std;
-
-class Solution {
-public:
-    bool hasGroupsSizeX(vector<int>& deck) {
-        if (deck.size() == 1){
-            return false;
-        }                
-
-        unordered_map<int, int> countMap;
-        for (int num: deck){
-            countMap[num]++;
-        }
-
-        int gcdValue = 0;
-        for (const auto& pair: countMap){
-            gcdValue = gcd(gcdValue, pair.second);
-        }
-
-        return gcdValue > 1;
-    }
-};
diff --git a/Problemas/Maths/NumericalMethods/PolynomialRoots.java b/Problemas/Maths/NumericalMethods/PolynomialRoots.java
deleted file mode 100644
index e395745..0000000
--- a/Problemas/Maths/NumericalMethods/PolynomialRoots.java
+++ /dev/null
@@ -1,49 +0,0 @@
-//https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=871
-import java.util.*;
-import java.io.*;
-
-public class PolynomialRoots {
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st;
-		int k = Integer.parseInt(in.readLine());
-		for (int i = 0; i < k; i++) {
-			int n = Integer.parseInt(in.readLine());
-			double[] f = new double[n + 1];
-			st = new StringTokenizer(in.readLine());
-			for (int j = f.length - 1; j >= 0; j--)
-				f[j] = Double.parseDouble(st.nextToken());
-			double[] conocidas = new double[n - 2];
-			st = new StringTokenizer(in.readLine());
-			for (int j = 0; j < conocidas.length; j++)
-				conocidas[j] = Double.parseDouble(st.nextToken());
-			for (double d : conocidas)
-				f = div(f, d);
-			double[] ans = bashkara(f);
-			for (double d : ans)
-				System.out.println(String.format("%.1f", d));
-		}
-
-	}
-
-	static double[] bashkara(double[] f) {
-		double a = f[2];
-		double b = f[1];
-		double c = f[0];
-		double x1 = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
-		double x2 = (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);
-		return new double[] { x1, x2 };
-
-	}
-
-	static double[] div(double[] f, double x) {
-		double[] ans = new double[f.length - 1];
-		for (int i = f.length - 1; i >= 1; i--) {
-			ans[i - 1] = f[i];
-			f[i - 1] += x * f[i];
-		}
-		return ans;
-	}
-
-}
diff --git a/Problemas/Maths/NumericalMethods/SolveIt.py b/Problemas/Maths/NumericalMethods/SolveIt.py
deleted file mode 100644
index 7c9a5c8..0000000
--- a/Problemas/Maths/NumericalMethods/SolveIt.py
+++ /dev/null
@@ -1,35 +0,0 @@
-#https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=1282
-from math import e,sin,cos,tan
-
-def f(x,p,q,r,s,t,u):
-    return p*e**(-x)+q*sin(x)+r*cos(x)+s*tan(x)+t*x**2+u
-
-def biseccion(f,p,q,r,s,t,u,a,b): 
-    for _ in range(100):
-        if f(a,p,q,r,s,t,u)==0:
-            return f"{a:.4f}"
-        
-        if f(b,p,q,r,s,t,u)==0:
-            return f"{b:.4f}"
-        
-        if f(a,p,q,r,s,t,u) * f(b,p,q,r,s,t,u) < 0:
-            mid = (a+b) / 2
-            if f(mid,p,q,r,s,t,u) == 0:
-                return f"{mid:.4f}"
-            else:
-                if f(a,p,q,r,s,t,u) * f(mid,p,q,r,s,t,u) < 0:
-                    b = mid
-                else:
-                    a = mid
-        else:
-            return "No solution"
-        
-    return f"{mid:.4f}"
-
-
-while True:
-    try:
-        p, q, r, s, t ,u = [int(i) for i in input().split()]
-        print(biseccion(f,p,q,r,s,t,u,0,1))
-    except:
-        break
diff --git a/Problemas/Maths/NumericalMethods/SquareRoot.py b/Problemas/Maths/NumericalMethods/SquareRoot.py
deleted file mode 100644
index fa06dfe..0000000
--- a/Problemas/Maths/NumericalMethods/SquareRoot.py
+++ /dev/null
@@ -1,25 +0,0 @@
-#https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=964
-def biseccion(n,low,high):
-    if low**2==n:
-        return low
-    if high**2==n:
-        return high
-    mid = n
-    while low<=high:
-        mid = (high+low)//2
-        if mid**2==n:
-            return mid
-        if mid**2>n:
-            high = mid-1
-        else:
-            low = mid+1
-    return mid
-
-t = int(input())
-input()
-for i in range(t):
-    n = int(input())
-    print(biseccion(n,0,n))
-    if i<t-1:
-        print()
-        input()
diff --git a/Problemas/Maths/NumericalMethods/TheRoots.java b/Problemas/Maths/NumericalMethods/TheRoots.java
deleted file mode 100644
index 5fca909..0000000
--- a/Problemas/Maths/NumericalMethods/TheRoots.java
+++ /dev/null
@@ -1,110 +0,0 @@
-//https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1369
-import java.util.*;
-import java.io.*;
-
-public class TheRoots {
-
-	public static void main(String[] args) throws Exception {
-		Input in = new Input(System.in);
-		int caso = 1;
-		while (true) {
-			int n = in.nextInt();
-			if (n == 0)
-				break;
-			double[] f = new double[n + 1];
-			for (int i = f.length - 1; i >= 0; i--)
-				f[i] = in.nextDouble();
-			double inicial = Math.pow(2, Integer.bitCount(n) / 2);
-			double[] ans = new double[n];
-			for (int i = 0; i < n; i++) {
-				inicial = newton(f, inicial);
-				ans[i] = inicial;
-				f = div(f, inicial);
-			}
-			Arrays.sort(ans);
-			System.out.print("Equation " + caso + ": ");
-			for (int i = 0; i < ans.length; i++) {
-				if (i < ans.length - 1)
-					System.out.print(String.format("%.4f ", ans[i]));
-				else
-					System.out.print(String.format("%.4f", ans[i]));
-			}
-			System.out.println();
-			caso++;
-
-		}
-
-	}
-
-	static double[] div(double[] f, double x) {
-		double[] ans = new double[f.length - 1];
-		for (int i = f.length - 1; i >= 1; i--) {
-			ans[i - 1] = f[i];
-			f[i - 1] += x * f[i];
-		}
-		return ans;
-	}
-
-	static double eval(double[] f, double x) {
-		double ans = 0;
-		for (int i = 0; i < f.length; i++)
-			ans += f[i] * Math.pow(x, i);
-		return ans;
-	}
-
-	static double[] f_prima(double[] f, int n) {
-		double[] derivada = new double[n - 1];
-		derivada[0] = f[1];
-		for (int i = 1; i < n - 1; i++)
-			derivada[i] = f[i + 1] * (i + 1);
-		return derivada;
-
-	}
-
-	static double newton(double[] f, double x) {
-		while (Math.abs(eval(f, x)) >= 1e-7)
-			x = x - eval(f, x) / eval(f_prima(f, f.length), x);
-		return x;
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-	}
-
-}
diff --git a/Problemas/Maths/Problems/ATrivialProblem.java b/Problemas/Maths/Problems/ATrivialProblem.java
deleted file mode 100644
index 8beac25..0000000
--- a/Problemas/Maths/Problems/ATrivialProblem.java
+++ /dev/null
@@ -1,32 +0,0 @@
-import java.util.LinkedList;
-import java.util.Scanner;
-
-public class ATrivialProblem {
-    public static void main(String[] args) {
-        Scanner tec=new Scanner(System.in);
-        LinkedList<Integer> nums=new LinkedList<>();
-        int n=tec.nextInt();
-        boolean c=false;
-        for (int i = 1; i <=n*10; i++) {
-            if(findTrailingZeros(i)==n) {
-                nums.add(i);
-                c=true;
-            }
-            else if(c)
-                break;
-
-        }
-        System.out.println(nums.size());
-        if(!nums.isEmpty())
-            for (int i : nums)
-                System.out.print(i+" ");
-
-    }
-    static int findTrailingZeros(int n) {
-        int count = 0;
-        for (int i = 5; n / i >= 1; i *= 5)
-            count += n / i;
-
-        return count;
-    }
-}
diff --git a/Problemas/Maths/Problems/EbonyAndEvory.py b/Problemas/Maths/Problems/EbonyAndEvory.py
deleted file mode 100644
index c582aa4..0000000
--- a/Problemas/Maths/Problems/EbonyAndEvory.py
+++ /dev/null
@@ -1,17 +0,0 @@
-a,b,n=[int(i) for i in input().split()]
-x=max(a,b)
-y=min(a,b)
-if(n%x==0 or n%y==0):
-    print("Yes")
-else:
-    kill=False
-    for i in range(1,n):
-        aux=n-y*i
-        if(aux<0):
-            break
-        if(aux%x==0):
-            print("Yes")
-            kill=True
-            break
-    if(not kill):
-        print("No")
diff --git a/Problemas/Maths/Problems/GoldBach'sConjecture.java b/Problemas/Maths/Problems/GoldBach'sConjecture.java
deleted file mode 100644
index a2fe565..0000000
--- a/Problemas/Maths/Problems/GoldBach'sConjecture.java
+++ /dev/null
@@ -1,40 +0,0 @@
-//https://vjudge.net/problem/UVA-543
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.io.IOException;
-
-public class GoldbachConjecture {
-	static int n;
-
-	public static void main(String[] args) throws IOException {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		while (true) {
-			n = Integer.parseInt(in.readLine());
-			if (n < 2)
-				break;
-			for (int i = 2; i < n; i++)
-				if (isPrime(i))
-					if (isPrime(n - i)) {
-						System.out.println(n + " = " + i + " + " + (n - i));
-						break;
-					}
-
-		}
-
-	}
-
-	private static boolean isPrime(int n) {
-		if (n <= 1)
-			return false;
-		if (n <= 3)
-			return true;
-		if (n % 2 == 0 || n % 3 == 0)
-			return false;
-		for (int i = 5; i * i <= n; i += 6)
-			if (n % i == 0 || n % (i + 2) == 0)
-				return false;
-		return true;
-
-	}
-
-}
diff --git a/Problemas/Maths/Problems/ProductsDigits.py b/Problemas/Maths/Problems/ProductsDigits.py
deleted file mode 100644
index 8b9ae83..0000000
--- a/Problemas/Maths/Problems/ProductsDigits.py
+++ /dev/null
@@ -1,36 +0,0 @@
-#El problema es sacar el numero menor de la multiplicacion de sus digitos, es decir si es 64: 88, porque 8 divide a 64 y 88 
-#va a ser el menor numero, no queremos un 222222, que es muy grande, por eso se resuelve dejando los digitos mas grandes 
-#arriba en donde estan los condicionales, esto garantiza que se divida primero por los numeros grandes, y si se repiten que siga el ciclo
-
-import sys 
-def digitosdivisores(N):
-    res = []
-    lista = reversed([i for i in range(2,10)])
-    while(N != 1):
-        num = N
-        for i in lista:
-            if N%i==0:
-                while N%i==0:
-                    N//=i
-                    res.append(i)
-        if N==num:
-# Se crea la variable num y se guarda el N del comienzo, para ver si ha surgido un cambio en N, si despues de pasar todos no ha cambiado, significa que sus divisores son mas grandes que 9
-            res.append(-1)
-            return res
-    return res
-
-n = int(sys.stdin.readline())
-for i in range(n):
-    N = int(sys.stdin.readline())
-    if N==0:
-        print(0)
-        continue
-    if N==1:
-        print(1)
-        continue
-    res = digitosdivisores(N)
-    res.sort()
-    if res[0] == -1:
-        print(-1)
-    else:
-        print("".join(map(str, res)))
diff --git a/Problemas/Maths/Problems/Taxes.java b/Problemas/Maths/Problems/Taxes.java
deleted file mode 100644
index f60b166..0000000
--- a/Problemas/Maths/Problems/Taxes.java
+++ /dev/null
@@ -1,63 +0,0 @@
-//https://codeforces.com/contest/736/problem/B
-import java.util.*;
-import java.io.*;
-
-public class Pruebas {
-    public static void main(String[] args) {
-        Scanner sc = new Scanner();
-        int n=sc.nextInt();
-        if(isPrime(n))
-            System.out.println(1);
-        else if(n%2==0||isPrime(n-2))
-            System.out.println(2);
-        else
-            System.out.println(3);
-    }
-    static boolean isPrime(int n){
-        if(n<2)
-            return false;
-        if(n<4)
-            return true;
-        for (int i = 2; i*i <=n ; i++)
-            if(n%i==0)
-                return false;
-
-        return true;
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Problems/Berland Regional.cpp b/Problemas/Problems/Berland Regional.cpp
deleted file mode 100644
index a279df3..0000000
--- a/Problemas/Problems/Berland Regional.cpp	
+++ /dev/null
@@ -1,55 +0,0 @@
-//https://codeforces.com/contest/1519/problem/C
-#include <bits/stdc++.h>
-using namespace std;
-#define ll long long
-const int MAXN = 3e5 + 5;
-const int MOD = 1e9 + 7;
-
-void solve() {
-    int t;
-    cin >> t;
-    while (t--) {
-        int n;
-        cin >> n;
-
-        vector<int> u(n);
-        for (int i = 0; i < n; i++)
-            cin >> u[i];
-
-        vector<int> s(n);
-        for (int i = 0; i < n; i++)
-            cin >> s[i];
-
-        vector<vector<ll>> un(n);
-        for (int i = 0; i < n; i++)
-            un[u[i] - 1].push_back(s[i]);
-
-
-        for (int i = 0; i < n; i++)
-            sort(un[i].rbegin(), un[i].rend());
-
-        vector<ll> ans(n, 0);
-        for (int u = 0; u < n; u++) {
-            int l = un[u].size();
-            vector<ll> p(l + 1, 0);
-
-            for (int i = 0; i < l; i++)
-                p[i + 1] = un[u][i] + p[i];
-
-            for (int k = 1; k <= l; k++)
-                ans[k - 1] += p[(l / k) * k];
-        }
-
-
-        for (int i = 0; i < n; i++)
-            cout << ans[i] << " ";
-        cout << endl;
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git a/Problemas/Problems/Bingo!.java b/Problemas/Problems/Bingo!.java
deleted file mode 100644
index a4bf252..0000000
--- a/Problemas/Problems/Bingo!.java
+++ /dev/null
@@ -1,56 +0,0 @@
-//https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3391
-import java.util.*;
-import java.io.*;
-
-public class Bingo {
-
-	static HashSet<Integer> h;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st;
-		while (true) {
-			st = new StringTokenizer(in.readLine());
-			int n = Integer.parseInt(st.nextToken());
-			int b = Integer.parseInt(st.nextToken());
-			if (n == 0 && b == 0)
-				break;
-			int[] arr = new int[b];
-			st = new StringTokenizer(in.readLine());
-			h = new HashSet<>();
-			for (int i = 0; i < arr.length; i++) {
-				arr[i] = Integer.parseInt(st.nextToken());
-				h.add(arr[i]);
-			}
-			Arrays.sort(arr);
-			System.out.println(solve(n, arr) ? "Y" : "N");
-		}
-
-	}
-
-	static boolean solve(int n, int[] A) {
-		int j = 0;
-		for (int i = 0; i < A.length; i++) {
-			if (A[i] != j) {
-				if (!find(j, A))
-					return false;
-				i--;
-			}
-			j++;
-		}
-		if (j >= n + 1)
-			return true;
-		return false;
-	}
-
-	static boolean find(int x, int[] A) {
-		if (x == 0 && !h.contains(x))
-			return false;
-		for (int i = 0; i < A.length; i++)
-			if (h.contains(A[i] + x))
-				return true;
-		return false;
-
-	}
-
-}
diff --git a/Problemas/Problems/DominoEffect.java b/Problemas/Problems/DominoEffect.java
deleted file mode 100644
index 8a6d346..0000000
--- a/Problemas/Problems/DominoEffect.java
+++ /dev/null
@@ -1,54 +0,0 @@
-//https://codeforces.com/problemset/problem/405/B
-import java.util.*;
-import java.io.*;
-
-public class DominoEffect {
-	static HashSet<Integer> mid;
-
-	public static void main(String[] args) throws Exception {
-		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-		in.readLine();
-		String s = in.readLine();
-		mid = new HashSet<>();
-		find(s);
-		int c = 0;
-		for (char k : solve(s))
-			if (k == Character.MIN_VALUE)
-				c++;
-		System.out.println(c);
-
-	}
-
-	static void find(String s) {
-		int n = s.length();
-		for (int i = 0; i < n; i++)
-			if (s.charAt(i) == 'R')
-				for (int j = i + 1; j < n; j++)
-					if (s.charAt(j) == 'L') {
-						int val = j - i - 1;
-						if (val % 2 != 0)
-							mid.add(i + val / 2 + 1);
-						break;
-					}
-
-	}
-
-	static char[] solve(String s) {
-		int n = s.length();
-		char[] state = new char[n];
-		for (int i = 0; i < n; i++)
-			if (s.charAt(i) == 'L') {
-				int j = i;
-				while (j >= 0 && s.charAt(j) != 'R' && !mid.contains(j))
-					state[j--] = 'L';
-
-			} else if (s.charAt(i) == 'R') {
-				int j = i;
-				while (j < n && s.charAt(j) != 'L' && !mid.contains(j))
-					state[j++] = 'R';
-
-			}
-		return state;
-	}
-
-}
diff --git a/Problemas/Problems/GlobalRainingAtBididibus.java b/Problemas/Problems/GlobalRainingAtBididibus.java
deleted file mode 100644
index 9e551bd..0000000
--- a/Problemas/Problems/GlobalRainingAtBididibus.java
+++ /dev/null
@@ -1,64 +0,0 @@
-import java.util.*;
-import java.io.*;
-
-public class Bididibus {
-	public static void main(String[] args) {
-		Input in = new Input(System.in);
-		int t = in.nextInt();
-		for (int cases = 0; cases < t; cases++) {
-			String s = in.next();
-			Stack<Integer> stack = new Stack<>();
-			int ans = 0;
-			for (int i = 0; i < s.length(); i++) {
-				if (s.charAt(i) == '/' && stack.isEmpty())
-					continue;
-				if (s.charAt(i) == '\\')
-					stack.push(i);
-				else if (s.charAt(i) == '/')
-					ans += i - stack.pop();
-			}
-			System.out.println(ans);
-		}
-	}
-
-	static class Input {
-		BufferedReader br;
-		StringTokenizer st;
-
-		public Input(InputStream f) {
-			br = new BufferedReader(new InputStreamReader(f));
-		}
-
-		String next() {
-			while (st == null || !st.hasMoreTokens()) {
-				try {
-					st = new StringTokenizer(br.readLine());
-				} catch (IOException e) {
-					e.printStackTrace();
-				}
-			}
-			return st.nextToken();
-		}
-
-		int nextInt() {
-			return Integer.parseInt(next());
-		}
-
-		double nextDouble() {
-			return Double.parseDouble(next());
-		}
-
-		public boolean hasNext() {
-			try {
-				while (st == null || !st.hasMoreTokens())
-					st = new StringTokenizer(br.readLine());
-
-			} catch (Exception e) {
-				return false;
-			}
-			return true;
-		}
-
-	}
-
-}
diff --git a/Problemas/Problems/JudgingTroubles.py b/Problemas/Problems/JudgingTroubles.py
deleted file mode 100644
index 7d8d9b8..0000000
--- a/Problemas/Problems/JudgingTroubles.py
+++ /dev/null
@@ -1,21 +0,0 @@
-n = int(input())
-dom = {}
-for _ in range(n):
-    val = input()
-    if val in dom:
-        dom[val]+=1
-    else:
-        dom[val] = 1
-kattis = {}
-for _ in range(n):
-    val = input()
-    if val in kattis:
-        kattis[val]+=1
-    else:
-        kattis[val] = 1
-ans = 0 
-for k,v in dom.items():
-    if k in kattis:
-        ans+=min(v,kattis[k])
-print(ans)
-    
diff --git "a/Problemas/Problems/L\303\246g\303\260YfirLandinu.cpp" "b/Problemas/Problems/L\303\246g\303\260YfirLandinu.cpp"
deleted file mode 100644
index 001c4f5..0000000
--- "a/Problemas/Problems/L\303\246g\303\260YfirLandinu.cpp"
+++ /dev/null
@@ -1,30 +0,0 @@
-//https://open.kattis.com/problems/laegdyfirlandinu
-#include <iostream>
-#include<vector>
-using namespace std;
-
-bool cond(vector<vector<int>> grid, int r, int c) {
-	return grid[r - 1][c] > grid[r][c] && grid[r + 1][c] > grid[r][c] && grid[r][c - 1] > grid[r][c] && grid[r][c + 1] > grid[r][c];
-}
-
-string solve(vector<vector<int>> grid, int n, int m) {
-	for (int i = 1; i < n-1; i++)
-		for (int j = 1; j < m-1; j++) 
-			if (cond(grid, i, j))
-				return "Jebb";
-	return "Neibb";
-}
-int main() {
-	int n;
-	cin >> n;
-	int m;
-	cin >> m;
-	vector<vector<int>> grid(n,vector<int>(m,0));
-	for (int i = 0; i < n; i++)
-		for (int j = 0; j < m; j++) {
-			int k; cin >> k;
-			grid[i][j] = k;
-		}
-	cout << solve(grid, n, m);
-	return 0;
-}
diff --git a/Problemas/Problems/PizzaCutting.py b/Problemas/Problems/PizzaCutting.py
deleted file mode 100644
index d1c5ffe..0000000
--- a/Problemas/Problems/PizzaCutting.py
+++ /dev/null
@@ -1,6 +0,0 @@
-res = lambda x: ((x*(x+1))//2)+1
-while True:
-    n = int(input())
-    if n<0:
-        break
-    print(res(n))
diff --git a/Problemas/Problems/Shortest path of the king.cpp b/Problemas/Problems/Shortest path of the king.cpp
deleted file mode 100644
index 41f8a26..0000000
--- a/Problemas/Problems/Shortest path of the king.cpp	
+++ /dev/null
@@ -1,66 +0,0 @@
-//https://codeforces.com/contest/3/problem/A
-using namespace std;
-#include <bits/stdc++.h>
-
-#define all(A) A.begin(), A.end()
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define ll long long
-#define ull unsigned long long
-
-#define conv(a) (9-a)
-
-void solve() {
-    string a, b;
-    cin >> a >> b;
-    pair<int, int> s = {conv((a[1] - '0')), a[0] - 'a' + 1};
-    pair<int, int> t = {conv((b[1] - '0')), b[0] - 'a' + 1};
-    int d = max(abs(s.first - t.first), abs(s.second - t.second));
-    cout << d << ln;
-    pair<int, int> cur = {s.first - t.first, s.second - t.second};
-    while (d--) {
-        int dx = cur.first;
-        int dy = cur.second;
-        if (dx < 0 && dy < 0) {
-            cout << "RD" << ln;
-            dx++;
-            dy++;
-        } else if (dx > 0 && dy > 0) {
-            dx--;
-            dy--;
-            cout << "LU" << ln;
-        } else if (dx > 0 && dy < 0) {
-            dx--;
-            dy++;
-            cout << "RU" << ln;
-        } else if (dx < 0 && dy > 0) {
-            dx++;
-            dy--;
-            cout << "LD" << ln;
-        } else if (dx > 0) {
-            dx--;
-            cout << "U" << ln;
-        } else if (dx < 0) {
-            dx++;
-            cout << "D" << ln;
-        } else if (dy > 0) {
-            dy--;
-            cout << "L" << ln;
-        } else {
-            dy++;
-            cout << "R" << ln;
-        }
-        cur.first = dx;
-        cur.second = dy;
-    }
-}
-
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    int t = 1;
-    while (t--)
-        solve();
-    return 0;
-}
diff --git a/Problemas/Problems/Static Range Sum Queries.cpp b/Problemas/Problems/Static Range Sum Queries.cpp
deleted file mode 100644
index eeee2b4..0000000
--- a/Problemas/Problems/Static Range Sum Queries.cpp	
+++ /dev/null
@@ -1,34 +0,0 @@
-//https://cses.fi/problemset/task/1646
-#include <bits/stdc++.h>
-using namespace std;
-using ll = long long;
-
-void solve() {
-    int n, q;
-    cin >> n >> q;
-    vector<ll> a(n);
-    vector<ll> prefixSum(n);
-    for (int i = 0; i < n; i++) {
-        cin >> a[i];
-        if (i == 0)
-            prefixSum[i] = a[i];
-        else
-            prefixSum[i] = prefixSum[i - 1] + a[i];
-    }
-    for (int i = 0; i < q; i++) {
-        int l, r;
-        cin >> l >> r;
-        l--, r--;
-        if (l == 0)
-            cout << prefixSum[r] << endl;
-        else
-            cout << prefixSum[r] - prefixSum[l - 1] << endl;
-    }
-}
-
-int main() {
-    ios_base::sync_with_stdio(false);
-    cin.tie(nullptr);
-    solve();
-    return 0;
-}
diff --git a/Problemas/Problems/Stern Brocot Tree.py b/Problemas/Problems/Stern Brocot Tree.py
deleted file mode 100644
index e1784d0..0000000
--- a/Problemas/Problems/Stern Brocot Tree.py	
+++ /dev/null
@@ -1,30 +0,0 @@
-class Node:
-    def __init__(self,num,den):
-        self.num = num
-        self.den = den
-    
-    def __str__(self):
-        return f"{self.num}/{self.den}"
-
-def addNodes(node1, node2):
-    return Node(node1.num+node2.num,node1.den+node2.den)
-
-t = int(input())
-for _ in range(t):
-    left = Node(0,1)
-    right = Node(1,0)
-    root = Node(1,1)
-    path = input()
-    ans = None
-    for i in path:
-        if i=="R":
-            ans = addNodes(root,right)
-            left = root
-            root = ans
-        else:
-            ans = addNodes(left,root)
-            right = root
-            root = ans
-    print(ans)
-            
-        
diff --git a/Problemas/Problems/The Trail.cpp b/Problemas/Problems/The Trail.cpp
deleted file mode 100644
index 65974c1..0000000
--- a/Problemas/Problems/The Trail.cpp	
+++ /dev/null
@@ -1,85 +0,0 @@
-//https://codeforces.com/contest/2055/problem/C
-using namespace std;
-#include <bits/stdc++.h>
-#include <iostream>
-#include <vector>
-#include <unordered_map>
-#include <unordered_set>
-#include <map>
-#include <set>
-#include <algorithm>
-#include <climits>
-#include <cmath>
-#include <math.h>
-#include <iomanip>
-#include <deque>
-#include <queue>
-#include <stack>
-#include <string>
-#include <utility>
-#include <numeric>
-#define fori(i, k, n) for (int i = k; i < n; i++)
-#define ln "\n"
-#define MAXN 1000001
-
-struct Point
-{
-    int x, y;
-};
-
-void solve()
-{
-    int t;
-    cin >> t;
-    while (t--)
-    {
-        int n, m;
-        cin >> n >> m;
-        vector<vector<long long>> A(n, vector<long long>(m));
-        string s;
-        cin >> s;
-        vector<long long> row(n, 0);
-        vector<long long> col(m, 0);
-        fori(i, 0, n)
-            fori(j, 0, m)
-        {
-            cin >> A[i][j];
-            row[i] += A[i][j];
-            col[j] += A[i][j];
-        }
-        Point p = {0, 0};
-        for (char c : s)
-            if (c == 'D')
-            {
-                A[p.x][p.y] = -row[p.x];
-                row[p.x] += A[p.x][p.y];
-                col[p.y] += A[p.x][p.y];
-                p.x++;
-            }
-            else
-            {
-                A[p.x][p.y] = -col[p.y];
-                row[p.x] += A[p.x][p.y];
-                col[p.y] += A[p.x][p.y];
-                p.y++;
-            }
-
-        A[n - 1][m - 1] = -row[n - 1];
-        fori(i, 0, n)
-        {
-            fori(j, 0, m)
-                    cout
-                << A[i][j] << " ";
-            cout << ln;
-        }
-    }
-}
-
-int main()
-{
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    solve();
-    cout.flush();
-    return 0;
-}
diff --git a/Problemas/Strings/Deciphering WordWhiz.py b/Problemas/Strings/Deciphering WordWhiz.py
deleted file mode 100644
index 955f953..0000000
--- a/Problemas/Strings/Deciphering WordWhiz.py	
+++ /dev/null
@@ -1,21 +0,0 @@
-n=int(input())
-words=[input() for i in range(n)]
-g=int(input())
-guesses=[input() for i in range(g)]
-key=words[0]
-def guess(key,word):
-    s=""
-    for i in range(5):
-        if(word[i]==key[i]):
-            s+="*"
-        elif(word[i] in key):
-            s+="!"
-        else:
-            s+="X"
-    return s
-for i in range(g):
-    c=0
-    for word in words:
-        if(guess(key,word)==guesses[i]):
-            c+=1
-    print(c)
diff --git a/Problemas/Strings/Decode The Tape.java b/Problemas/Strings/Decode The Tape.java
deleted file mode 100644
index a9b0ff6..0000000
--- a/Problemas/Strings/Decode The Tape.java	
+++ /dev/null
@@ -1,71 +0,0 @@
-//https://vjudge.net/problem/UVA-10878
-import java.util.*;
-import java.io.*;
-public class Main {
-    static int[] pi;
-    static int[] size;
-    public static void main(String[] args) throws IOException {
-        Scanner sc = new Scanner();
-        PrintWriter out = new PrintWriter(System.out);
-        sc.nextLine();
-        while (true){
-            String s=sc.nextLine();
-            if(s.charAt(0)=='_')
-                break;
-            String ans="";
-            for (int i = 0; i < s.length(); i++) {
-                if(s.charAt(i)==' ')
-                    ans+='0';
-                else if (s.charAt(i)=='o')
-                    ans+='1';
-            }
-            out.print((char)Integer.parseInt(ans,2));
-        }
-        out.close();
-
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char Char() throws IOException {
-            return (char) br.read();
-        }
-
-        char nextChar() {
-            return next().charAt(0);
-        }
-
-    }
-}
diff --git a/Problemas/Strings/Haiku Review.java b/Problemas/Strings/Haiku Review.java
deleted file mode 100644
index 30a5b56..0000000
--- a/Problemas/Strings/Haiku Review.java	
+++ /dev/null
@@ -1,63 +0,0 @@
-// https://vjudge.net/problem/UVA-576
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-
-public class Main {
-    public static void main(String[] args)throws Exception {
-        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
-        while (true){
-            String s=bf.readLine();
-            if(s.equals("e/o/i"))
-                break;
-            String[] l=s.split("/");
-            String[] l1=l[0].split("\\s+");
-            String[] l2=l[1].split("\\s+");
-            String[] l3=l[2].split("\\s+");
-            int c1=0;
-            int c2=0;
-            int c3=0;
-            for (String string : l1) {
-                boolean vowel = false;
-                for (int j = 0; j < string.length(); j++) {
-                    if (!vowel && (string.charAt(j) == 'a' || string.charAt(j) == 'e' || string.charAt(j) == 'i' || string.charAt(j) == 'o' || string.charAt(j) == 'u' || string.charAt(j) == 'y')) {
-                        vowel = true;
-                        c1++;
-                    } else if (string.charAt(j) != 'a' && string.charAt(j) != 'e' && string.charAt(j) != 'i' && string.charAt(j) != 'o' && string.charAt(j) != 'u' && string.charAt(j) != 'y')
-                        vowel = false;
-                }
-            }
-            for (String string : l2) {
-                boolean vowel = false;
-                for (int j = 0; j < string.length(); j++) {
-                    if (!vowel && (string.charAt(j) == 'a' || string.charAt(j) == 'e' || string.charAt(j) == 'i' || string.charAt(j) == 'o' || string.charAt(j) == 'u' || string.charAt(j) == 'y')) {
-                        vowel = true;
-                        c2++;
-                    } else if (string.charAt(j) != 'a' && string.charAt(j) != 'e' && string.charAt(j) != 'i' && string.charAt(j) != 'o' && string.charAt(j) != 'u' && string.charAt(j) != 'y')
-                        vowel = false;
-                }
-            }
-            for (String string : l3) {
-                boolean vowel = false;
-                for (int j = 0; j < string.length(); j++) {
-                    if (!vowel && (string.charAt(j) == 'a' || string.charAt(j) == 'e' || string.charAt(j) == 'i' || string.charAt(j) == 'o' || string.charAt(j) == 'u' || string.charAt(j) == 'y')) {
-                        vowel = true;
-                        c3++;
-                    } else if (string.charAt(j) != 'a' && string.charAt(j) != 'e' && string.charAt(j) != 'i' && string.charAt(j) != 'o' && string.charAt(j) != 'u' && string.charAt(j) != 'y')
-                        vowel = false;
-                }
-            }
-            if(c1==5&&c2==7&&c3==5)
-                System.out.println("Y");
-            else if(c1!=5)
-                System.out.println(1);
-            else if (c2!=7)
-                System.out.println(2);
-            else
-                System.out.println(3);
-
-
-
-
-        }
-    }
-}
diff --git a/Problemas/Strings/Homework Checker.java b/Problemas/Strings/Homework Checker.java
deleted file mode 100644
index 978aaa9..0000000
--- a/Problemas/Strings/Homework Checker.java	
+++ /dev/null
@@ -1,40 +0,0 @@
-// https://vjudge.net/problem/UVA-11878
-import java.util.Scanner;
-
-public class Main {
-    public static void main(String[] args)throws Exception {
-        Scanner tec=new Scanner(System.in);
-        int sum=0;
-        while (tec.hasNext()){
-            String s=tec.nextLine();
-            if(s.charAt(s.length()-1)=='?')
-                continue;
-            int a=-1;
-            int b=-1;
-            int c=-1;
-            int i=0;
-            while (s.charAt(i)!='+'&&s.charAt(i)!='-')
-                i++;
-            int j=i;
-            while (s.charAt(j)!='=')
-                j++;
-            a=Integer.parseInt(s.substring(0,i));
-            b=Integer.parseInt(s.substring(i+1,j));
-            c=Integer.parseInt(s.substring(j+1));
-            
-          
-            if(s.charAt(i)=='+')
-                if(a+b==c){
-                    sum++;
-                    continue;
-                }
-            if (a-b==c){
-                sum++;
-               
-            }
-           
-
-        }
-        System.out.println(sum);
-    }
-}
diff --git a/Problemas/Strings/KMP/File_Recover_Testing.cpp b/Problemas/Strings/KMP/File_Recover_Testing.cpp
deleted file mode 100644
index 35fd375..0000000
--- a/Problemas/Strings/KMP/File_Recover_Testing.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-//https://www.spoj.com/problems/FILRTEST/en/
-#include <iostream>
-#include <vector>
-#include <string>
-#include <algorithm>
-#include <iomanip>
-#include <set>
-#include <climits>
-using namespace std;
-
-void fast() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0), cout.tie(0);
-}
-
-int computeLPSArray(string &pat, int M, vector<int> &lps) {
-    int len = 0;
-    lps[0] = 0;
-    int i = 1;
-    while (i < M) {
-        if (pat[i] == pat[len]) {
-            len++;
-            lps[i] = len;
-            i++;
-        } else {
-            if (len != 0) {
-                len = lps[len - 1];
-            } else{
-
-                lps[i] = 0;
-                i++;
-            }
-        }
-    }
-    return lps[M - 1]; 
-}
-
-void solve() {
-    while(true){
-        int n; string s; cin >> n >> s;
-        if (n == -1  && s == "*")
-            return;
-        if (n < s.size()){
-            cout << 0 << "\n";
-            continue;
-        }
-        vector<int> lps(s.size());
-        int aux = computeLPSArray(s, s.size(), lps);
-        int patternLength = s.size() - aux;
-        
-        cout << 1 + (n - s.size()) / patternLength << "\n";
-    }
-        
-}
-
-int main() {
-    fast();
-    solve();
-    return 0;
-}
diff --git a/Problemas/Strings/KMP/Quite a problem.java b/Problemas/Strings/KMP/Quite a problem.java
deleted file mode 100644
index 1f00b8b..0000000
--- a/Problemas/Strings/KMP/Quite a problem.java	
+++ /dev/null
@@ -1,115 +0,0 @@
-//https://open.kattis.com/problems/quiteaproblem
-import java.io.*;
-import java.util.*;
-class Main {
-    static ArrayList<Integer>[] adj;
-    static boolean[] state;
-
-    public static void main(String[] args) throws Exception{
-        Scanner sc=new Scanner();
-        PrintWriter out=new PrintWriter(System.out);
-        String t="problem";
-        while (true){
-            String s=sc.nextLine();
-            if(s==null)
-                return;
-            if(s.length()<t.length())
-                System.out.println("no");
-            else {
-                s = s.toLowerCase();
-                System.out.println(KMP(s, t) ? "yes" : "no");
-            }
-        }
-
-    }
-    static int[] table(String pattern){
-        int size=pattern.length();
-        int APL=0;
-        int[] table=new int[size];
-        if(size==1)
-            return table;
-        for(int i=1;i<size;i++){
-            while(APL>0 && pattern.charAt(APL)!= pattern.charAt(i))
-                APL=table[APL-1];
-            if(pattern.charAt(APL)==pattern.charAt(i))
-                APL++;
-            table[i]=APL;
-        }
-        return table;
-    }
-
-    static boolean KMP(String text, String pattern){
-        int[] table=table(pattern);
-        LinkedList<Integer> res=new LinkedList<>();
-        int textSize=text.length();
-        int patternSize= pattern.length();
-        int index=0;
-        int strIndex=0;
-        int patIndex=0;
-        while((textSize-index)>patternSize){
-            while(patIndex<patternSize && text.charAt(strIndex)==pattern.charAt(patIndex)){
-                strIndex++;
-                patIndex++;
-            }
-            if(patIndex>=patternSize)
-                return true;
-
-            if(patIndex>0&&table[patIndex-1]>0){
-                index=strIndex-table[patIndex-1];
-                patIndex=table[patIndex-1];
-            }
-            else{
-                if(strIndex==index)
-                    strIndex++;
-                index=strIndex;
-                if(patIndex>0)
-                    patIndex=table[patIndex-1];
-            }
-
-        }
-        index=textSize-patternSize;
-        int c=0;
-        for (int i = 0; i < patternSize; i++) {
-            if(text.charAt(index+i)==pattern.charAt(i))
-                c++;
-        }
-        return c == patternSize;
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-
-}
diff --git a/Problemas/Strings/KMP/Secret Word.cpp b/Problemas/Strings/KMP/Secret Word.cpp
deleted file mode 100644
index 1aaa0f9..0000000
--- a/Problemas/Strings/KMP/Secret Word.cpp	
+++ /dev/null
@@ -1,49 +0,0 @@
-//https://vjudge.net/problem/UVA-12467
-using namespace std;
-#include <bits/stdc++.h>
-#define ll long long
-#define Pair pair<int,int>
-#define eb emplace_back
-#define all(x) (x).begin(), (x).end()
-#define ln "\n"
-#define For(i, a, b) for(int i = a; i < b; i++)
-#define Rfor(i, a, b) for(int i = a; i >= b; i--)
-const ll inf = 1e18;
-const ll mod = 998244353;
-const int N = 100001;
-vector<int> prefix_function(string s) {
-    int n = (int)s.length();
-    vector<int> pi(n);
-    for (int i = 1; i < n; i++) {
-        int j = pi[i-1];
-        while (j > 0 && s[i] != s[j])
-            j = pi[j-1];
-        if (s[i] == s[j])
-            j++;
-        pi[i] = j;
-    }
-    return pi;
-}
-int main() {
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    //freopen("socdist.in", "r",stdin);
-    //freopen("socdist.out", "w", stdout)
-    int ti;cin>>ti;
-    while(ti--) {
-        string s; cin>>s;
-        int n = s.length();
-        string t=s;
-        reverse(all(t));
-        auto table = prefix_function(s+"$"+t);
-        int ans=0;
-        For(i,n,table.size())
-            ans=max(ans, table[i]);
-        string solve=s.substr(0,ans);
-        reverse(all(solve));
-        cout<<solve<<ln;
-    }
-    return 0;
-}
-
-
diff --git a/Problemas/Strings/KMP/String Matching.java b/Problemas/Strings/KMP/String Matching.java
deleted file mode 100644
index 1ed4f0a..0000000
--- a/Problemas/Strings/KMP/String Matching.java	
+++ /dev/null
@@ -1,78 +0,0 @@
-// https://open.kattis.com/problems/stringmatching
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.LinkedList;
-
-class KMP {
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
-        while(true){
-            String pattern=bf.readLine();
-            if(pattern==null||pattern.length() == 0)
-                return;
-            String text=bf.readLine();
-            
-            LinkedList<Integer> res=KMP(text,pattern);
-            for (int i:res)
-                System.out.print(i+" ");
-            System.out.println();
-        }
-    }
-
-    static int[] table(String pattern){
-        int size=pattern.length();
-        int APL=0;
-        int[] table=new int[size];
-        if(size==1)
-            return table;
-        for(int i=1;i<size;i++){
-            while(APL>0 && pattern.charAt(APL)!= pattern.charAt(i))
-                APL=table[APL-1];
-            if(pattern.charAt(APL)==pattern.charAt(i))
-                APL++;
-            table[i]=APL;
-        }
-        return table;
-    }
-
-    static LinkedList<Integer> KMP(String text, String pattern){
-        int[] table=table(pattern);
-        LinkedList<Integer> res=new LinkedList<>();
-        int textSize=text.length();
-        int patternSize= pattern.length();
-        int index=0;
-        int strIndex=0;
-        int patIndex=0;
-        while((textSize-index)>patternSize){
-            while(patIndex<patternSize && text.charAt(strIndex)==pattern.charAt(patIndex)){
-                strIndex++;
-                patIndex++;
-            }
-            if(patIndex>=patternSize)
-                res.add(index);
-
-            if(patIndex>0&&table[patIndex-1]>0){
-                index=strIndex-table[patIndex-1];
-                patIndex=table[patIndex-1];
-            }
-            else{
-                if(strIndex==index)
-                    strIndex++;
-                index=strIndex;
-                if(patIndex>0)
-                    patIndex=table[patIndex-1];
-            }
-
-        }
-        index=textSize-patternSize;
-        int c=0;
-        for (int i = 0; i < patternSize; i++) {
-            if(text.charAt(index+i)==pattern.charAt(i))
-                c++;
-        }
-        if(c==patternSize)
-            res.add(index);
-        return  res;
-    }
-}
diff --git a/Problemas/Strings/LCS/Advanced Fruits.cpp b/Problemas/Strings/LCS/Advanced Fruits.cpp
deleted file mode 100644
index 8b79942..0000000
--- a/Problemas/Strings/LCS/Advanced Fruits.cpp	
+++ /dev/null
@@ -1,69 +0,0 @@
-//https://vjudge.net/problem/SPOJ-ADFRUITS
-#include <bits/stdc++.h>
-using namespace std;
-#define ll long long
-#define Pair pair<int,int>
-#define eb emplace_back
-#define all(x) (x).begin(), (x).end()
-#define ln "\n"
-#define mk(x,y) make_pair(x,y)
-#define For(i, a, b) for(int i = a; i < b; i++)
-#define Rfor(i, a, b) for(int i = a; i >= b; i--)
-const ll inf = 1e18;
-const int MOD = 998244353;
-string LCS(string s1, string s2) {
-    int m = s1.length();
-    int k = s2.length();
-    vector<vector<int>> dp(m+1,vector<int>(k+1,0));
-    for (int i = 1; i <= m; i++) {
-        for (int j = 1; j <= k; j++) {
-            if (s1[i-1]==s2[j-1]) {
-                dp[i][j] = dp[i - 1][j - 1] + 1;
-            } else {
-                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
-            }
-        }
-    }
-    int index = dp[m][k];
-    string lcs(index,'#');
-    int i = m, j = k;
-    while (i > 0 && j > 0) {
-        if (s1[i-1]==s2[j-1])  {
-            lcs[--index] = s1[i-1];
-            i--;
-            j--;
-        } else if (dp[i - 1][j] > dp[i][j - 1]) {
-            i--;
-        } else {
-            j--;
-        }
-    }
-    return lcs;
-}
-int main() {
-    ios::sync_with_stdio(0);
-    cin.tie(0);
-    string s,t;
-    while (cin>>s>>t) {
-        string u=LCS(s,t);
-        int i=0,j=0;
-        For(k,0,u.length()) {
-            while (s[i]!=u[k])
-                cout<<s[i++];
-            while (t[j]!=u[k])
-                cout<<t[j++];
-            cout<<u[k];
-            i++;
-            j++;
-        }
-        For(l,i,s.length())
-            cout<<s[l];
-        For(l,j,t.length())
-            cout<<t[l];
-        cout<<ln;
-    }
-    return 0;
-}
-
-//freopen("socdist.in", "r",stdin);
-//freopen("socdist.out", "w", stdout)
diff --git a/Problemas/Strings/LCS/Compromise.java b/Problemas/Strings/LCS/Compromise.java
deleted file mode 100644
index a32fd5b..0000000
--- a/Problemas/Strings/LCS/Compromise.java
+++ /dev/null
@@ -1,104 +0,0 @@
-//https://vjudge.net/problem/UVA-531
-import java.io.*;
-import java.util.*;
-public class Main{
-    static double[][] dp;
-    static double[] p;
-    public static void main(String[] args) throws IOException {
-        Scanner sc = new Scanner();
-        while (true) {
-            String s = sc.nextLine();
-            if (s == null || s.isEmpty())
-                return;
-            while (true){
-                String r=sc.nextLine();
-                if(r.equals("#"))
-                    break;
-                s+=" "+r;
-            }
-            String t=sc.nextLine();
-            while (true){
-                String r=sc.nextLine();
-                if(r.equals("#"))
-                    break;
-                t+=" "+r;
-            }
-            String[] s1=s.split(" ");
-            String[] s2=t.split(" ");
-            String[] ans=findLCS(s1,s2);
-            for (int i = 0; i < ans.length; i++) {
-                if(i==0)
-                    System.out.print(ans[i]);
-                else
-                    System.out.print(" "+ans[i]);
-            }
-            System.out.println();
-        }
-    }
-    public static String[] findLCS(String[] s1, String[] s2) {
-        int m = s1.length;
-        int k = s2.length;
-        int[][] dp = new int[m + 1][k + 1];
-        for (int i = 1; i <= m; i++) {
-            for (int j = 1; j <= k; j++) {
-                if (s1[i - 1].equals(s2[j - 1])) {
-                    dp[i][j] = dp[i - 1][j - 1] + 1;
-                } else {
-                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
-                }
-            }
-        }
-        int index = dp[m][k];
-        String[] lcs = new String[index];
-        int i = m, j = k;
-
-        while (i > 0 && j > 0) {
-            if (s1[i - 1].equals(s2[j - 1])) {
-                lcs[--index] = s1[i - 1];
-                i--;
-                j--;
-            } else if (dp[i - 1][j] > dp[i][j - 1]) {
-                i--;
-            } else {
-                j--;
-            }
-        }
-
-        return lcs;
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    return "";
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar(){
-            return next().charAt(0);
-        }
-
-    }
-}
diff --git a/Problemas/Strings/LCS/LCS.java b/Problemas/Strings/LCS/LCS.java
deleted file mode 100644
index e2cae52..0000000
--- a/Problemas/Strings/LCS/LCS.java
+++ /dev/null
@@ -1,79 +0,0 @@
-//https://vjudge.net/problem/AtCoder-dp_f
-import java.io.*;
-import java.util.*;
-public class Main{
-    static double[][] dp;
-    static double[] p;
-    public static void main(String[] args) throws IOException {
-        Scanner sc = new Scanner();
-        String s=sc.nextLine();
-        String t=sc.nextLine();
-        System.out.println(findLCS(s,t));
-    }
-    public static String findLCS(String s1, String s2) {
-        int m = s1.length();
-        int k = s2.length();
-        int[][] dp = new int[m + 1][k + 1];
-        for (int i = 1; i <= m; i++) {
-            for (int j = 1; j <= k; j++) {
-                if (s1.charAt(i-1)==s2.charAt(j-1)) {
-                    dp[i][j] = dp[i - 1][j - 1] + 1;
-                } else {
-                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
-                }
-            }
-        }
-        int index = dp[m][k];
-        char[] lcs = new char[index];
-        int i = m, j = k;
-
-        while (i > 0 && j > 0) {
-            if (s1.charAt(i-1)==s2.charAt(j-1))  {
-                lcs[--index] = s1.charAt(i-1);
-                i--;
-                j--;
-            } else if (dp[i - 1][j] > dp[i][j - 1]) {
-                i--;
-            } else {
-                j--;
-            }
-        }
-
-        return new String(lcs);
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    return "";
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar(){
-            return next().charAt(0);
-        }
-
-    }
-}
diff --git a/Problemas/Strings/Largest subsequence.java b/Problemas/Strings/Largest subsequence.java
deleted file mode 100644
index 3b68dcc..0000000
--- a/Problemas/Strings/Largest subsequence.java	
+++ /dev/null
@@ -1,81 +0,0 @@
-//https://codeforces.com/problemset/problem/1905/C
-import java.io.*;
-import java.util.*;
-
-public class Main {
-
-    public static void main(String[] args) throws Exception {
-        Scanner sc = new Scanner();
-        int t=sc.nextInt();
-        for (int times = 0; times < t; times++) {
-            int n=sc.nextInt();
-            String r="!"+sc.next();
-            char[] s=r.toCharArray();
-            Stack<Integer> q=new Stack<>();
-            for (int i = 1; i <= n; i++) {
-                while (!q.isEmpty()&&s[q.peek()]<s[i])
-                    q.pop();
-                q.add(i);
-            }
-            int[] arr=new int[q.size()];
-            for (int i = q.size()-1; i >=0; i--) {
-                int a=q.pop();
-                arr[i] = a;
-            }
-            int ans=0;
-            int m=arr.length-1;
-            while (ans<=m&&s[arr[ans]]==s[arr[0]])
-                ans++;
-            ans=m-ans+1;
-            for (int i = 0; i <= m; i++) {
-                if(i<m-i){
-                    char aux=s[arr[i]];
-                    s[arr[i]]=s[arr[m-i]];
-                    s[arr[m-i]]=aux;
-                }
-            }
-            for (int i =1;i<s.length-1;i++)
-                if(s[i]>s[i+1]){
-                    ans=-1;
-                    break;
-                }
-            System.out.println(ans);
-        }
-    }
-
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-
-}
diff --git a/Problemas/Strings/Message transmision error(easy version).java b/Problemas/Strings/Message transmision error(easy version).java
deleted file mode 100644
index 61a5bde..0000000
--- a/Problemas/Strings/Message transmision error(easy version).java	
+++ /dev/null
@@ -1,67 +0,0 @@
-//https://codeforces.com/problemset/problem/2010/C1
-import java.io.*;
-import java.util.*;
-
-public class Main{
-    public static void main(String[] args) throws Exception{
-        Scanner sc=new Scanner();
-        String s=sc.next();
-        int n=s.length();
-        if(n<3){
-            System.out.println("NO");
-            return;
-        }
-        int i=s.length()/2,j=s.length()/2;
-        if(n%2==0)
-            i--;
-        for (int k=0;k<n/2;k++) {
-            if(i==0)
-                break;
-            if(s.substring(0,j+1).equals(s.substring(i,n))){
-                System.out.println("YES");
-                System.out.println(s.substring(0,j+1));
-                return;
-            }
-            i--;
-            j++;
-        }
-        System.out.println("NO");
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-
-}
diff --git a/Problemas/Strings/Palindrome Reorder.java b/Problemas/Strings/Palindrome Reorder.java
deleted file mode 100644
index 47cd4d7..0000000
--- a/Problemas/Strings/Palindrome Reorder.java	
+++ /dev/null
@@ -1,107 +0,0 @@
-//https://vjudge.net/problem/CSES-1755
-import java.util.*;
-import java.io.*;
-
-public class Main {
-    public static void main(String[] args) throws IOException {
-        Scanner sc = new Scanner();
-        String s=sc.next();
-        HashMap<Character, Integer> map=new HashMap<>();
-        for (int i = 0; i < s.length(); i++) {
-            if(!map.containsKey(s.charAt(i)))
-                map.put(s.charAt(i),1);
-            else
-                map.put(s.charAt(i),map.get(s.charAt(i))+1);
-        }
-        int n=0;
-        char c='1';
-        char[] ans=new char[s.length()];
-        int j=0;
-        int k=s.length()-1;
-        for (Map.Entry<Character,Integer> e :map.entrySet()){
-            char a=e.getKey();
-            int f=e.getValue();
-            if(f%2==1){
-                if(c!='1'){
-                    System.out.println("NO SOLUTION");
-                    return;
-                }
-                c=a;
-                n=f;
-                for (int i = s.length()/2-f/2; i <= s.length()/2+f/2; i++)
-                    ans[i]=c;
-
-            }
-            else{
-                for (int i=0;i<f/2;j++,i++)
-                    ans[j]=a;
-                for (int i = 0; i < f/2; i++,k--)
-                    ans[k]=a;
-
-            }
-        }
-        System.out.println(ans);
-    }
-    private static class Edge implements Comparable<Edge>{
-        int a;
-        char w;
-        public Edge(int u, char c){
-            a=u;
-            w=c;
-        }
-        public int compareTo(Edge o){
-            if(w<o.w)
-                return -1;
-            if(w>o.w)
-                return 1;
-            if(a<o.a)
-                return -1;
-            if(a>o.a)
-                return 1;
-            return 0;
-        }
-        public String toString() {
-            return "<"+a+", "+w+">";
-        }
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Strings/Periodic Strings.java b/Problemas/Strings/Periodic Strings.java
deleted file mode 100644
index b17c2ec..0000000
--- a/Problemas/Strings/Periodic Strings.java	
+++ /dev/null
@@ -1,46 +0,0 @@
-https://vjudge.net/problem/UVA-455
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.LinkedList;
-import java.util.Objects;
-
-public class Main {
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
-        int n=Integer.parseInt(bf.readLine());
-        bf.readLine();
-        for (int h = 0; h < n; h++) {
-            String s=bf.readLine();
-            LinkedList<Integer> divisores=new LinkedList<>();
-            for (int i = 1; i <= s.length()/2; i++)
-                if(s.length()%i==0)
-                    divisores.add(i);
-            int size=0;
-            for(int i: divisores){
-                if(size!=0)
-                    break;
-                boolean cambio= true;
-                String p1=s.substring(0,i);
-                for (int j = i; j+i <=s.length() ; j+=i) {
-                    if(!cambio)
-                        break;
-                    String p2=s.substring(j,j+i);
-                    if(!p1.equals(p2))
-                        cambio=false;
-                }
-                if(cambio)
-                    size = i;
-            }
-            if(size==0)
-                System.out.println(s.length());
-            else
-                System.out.println(size);
-            
-            if(h+1<n) {
-                System.out.println();
-                bf.readLine();
-            }
-        }
-    }
-}
diff --git a/Problemas/Strings/Phone List.java b/Problemas/Strings/Phone List.java
deleted file mode 100644
index c9486d3..0000000
--- a/Problemas/Strings/Phone List.java	
+++ /dev/null
@@ -1,40 +0,0 @@
-// https://vjudge.net/problem/UVA-11362
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.HashSet;
-import java.util.TreeSet;
-
-public class Main {
-//junacho
-    public static void main(String[] args)throws IOException {
-        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
-        int t=Integer.parseInt(bf.readLine());
-        for (int times = 0; times < t; times++) {
-            int n=Integer.parseInt(bf.readLine());
-            HashSet<String> nums=new HashSet<>();
-            //System.out.println("Hash: "+nums+" "+nums.size());
-            for (int i = 0; i < n; i++)
-                nums.add(bf.readLine());
-            boolean call=false;
-            for(String i:nums){
-                if(call)
-                    break;
-                if(i.length()==1)
-                    continue;
-                for (int j = 0; j < i.length(); j++) {
-                    String p=i.substring(0,j);
-                    if(nums.contains(p)){
-                        call=true;
-                        //System.out.println(p);
-                        System.out.println("NO");
-                        break;
-                    }
-                }
-
-            }
-            if(!call)
-                System.out.println("YES");
-        }
-    }
-}
diff --git a/Problemas/Strings/Power Strings.java b/Problemas/Strings/Power Strings.java
deleted file mode 100644
index d7658ae..0000000
--- a/Problemas/Strings/Power Strings.java	
+++ /dev/null
@@ -1,84 +0,0 @@
-// https://vjudge.net/problem/UVA-10298#google_vignette
-import java.util.*;
-import java.io.*;
-
-public class Main {
-
-    public static void main(String[] args) {
-        Scanner sc = new Scanner();
-        PrintWriter pw = new PrintWriter(System.out);
-        while (true){
-            String r=sc.next();
-            if(r.equals("."))
-                break;
-            LinkedList<Integer> div=new LinkedList<>();
-            for (int i = 1; i <=r.length()/2 ; i++)
-                if(r.length()%i==0)
-                    div.add(i);
-            boolean flag=true;
-            int ans=-1;
-            for(int i : div){
-                String s = r.substring(0,i);
-                flag=true;
-                for (int j = i; j <= r.length()-i; j+=i) {
-                    String t=r.substring(j,j+i);
-                    if(!s.equals(t)){
-                        flag=false;
-                        break;
-                    }
-                }
-                if(flag){
-                    ans=i;
-                    break;
-                }
-            }
-            if(ans<1)
-                System.out.println(1);
-            else
-                System.out.println(r.length()/ans);
-
-        }
-
-
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Strings/Scrolling Sign.java b/Problemas/Strings/Scrolling Sign.java
deleted file mode 100644
index 03f0e21..0000000
--- a/Problemas/Strings/Scrolling Sign.java	
+++ /dev/null
@@ -1,37 +0,0 @@
-// https://vjudge.net/problem/UVA-11576
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-
-public class Main {
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
-        int n=Integer.parseInt(bf.readLine());
-        for (int i = 0; i < n; i++) {
-            String[] l1=bf.readLine().split(" ");
-            int k=Integer.parseInt(l1[0]);
-            int m=Integer.parseInt(l1[1]);
-            String s=bf.readLine();
-            for (int j = 0; j < m-1; j++) {
-                String t=bf.readLine();
-                int index=0;
-                int start=-1;
-                for (int l = s.length()-k; l < s.length(); l++) {
-                    if(s.charAt(l)==t.charAt(index)) {
-                        index++;
-                        if (start == -1)
-                            start = l;
-                    }
-                    else if(start!=-1){
-                        l=start;
-                        index=0;
-                        start=-1;
-                    }
-                }
-                for (int l = index; l < t.length(); l++)
-                    s=s.concat(String.valueOf(t.charAt(l)));
-            }
-            System.out.println(s.length());
-        }
-    }
-}
diff --git a/Problemas/Strings/Shifts and Sorting.py b/Problemas/Strings/Shifts and Sorting.py
deleted file mode 100644
index b704efd..0000000
--- a/Problemas/Strings/Shifts and Sorting.py	
+++ /dev/null
@@ -1,23 +0,0 @@
-# https://codeforces.com/problemset/problem/1969/B
-t=int(input())
-for _ in range(t):
-    s=input()
-    ceros=[]
-    uno=-1
-    for i in range(len(s)):
-        if(s[i]=='0'):
-            ceros.append(i)
-        elif(uno==-1):
-            uno=i
-    sum=0
-    if(len(ceros)==len(s)):
-        print(0)
-        continue
-    if(len(ceros)>0 and ceros[0]==0):
-        ceros.pop(0)
-    for i in ceros:
-        if(uno>i):
-            continue
-        sum+=i-uno+1
-        uno+=1
-    print(sum)
diff --git a/Problemas/Strings/Sort.java b/Problemas/Strings/Sort.java
deleted file mode 100644
index 8d91be6..0000000
--- a/Problemas/Strings/Sort.java
+++ /dev/null
@@ -1,90 +0,0 @@
-//https://codeforces.com/contest/1996/problem/C
-import java.math.BigInteger;
-import java.util.*;
-import java.io.*;
-
-public class Pruebas {
-    public static void main(String[] args) {
-        Scanner sc = new Scanner();
-        int ti=sc.nextInt();
-        for (int times = 0; times < ti; times++) {
-            int n=sc.nextInt();
-            int q=sc.nextInt();
-            String s=sc.next();
-            String t=sc.next();
-            int[][] prefixS=prefix(s,n);
-            int[][] prefixT=prefix(t,n);
-            /*for (int[] i:prefixS)
-                System.out.println(Arrays.toString(i));
-            System.out.println("sf");
-            for (int[] i:prefixS)
-                System.out.println(Arrays.toString(i));*/
-            for (int i = 0; i < q; i++) {
-                int ans=0;
-                int l=sc.nextInt()-1;
-                int r=sc.nextInt()-1;
-                for (int j = 0; j < 26; j++) {
-                    int a;
-                    int b;
-                    if(l==0){
-                        a=prefixS[r][j];
-                        b=prefixT[r][j];
-                    }
-                    else{
-                        //System.out.println(l);
-                        a=prefixS[r][j]-prefixS[l-1][j];
-                        b=prefixT[r][j]-prefixT[l-1][j];
-                    }
-                    ans+=Math.abs(a-b);
-                }
-                System.out.println(ans/2);
-            }
-        }
-    }
-    static int[][] prefix(String s, int n){
-        int[][] prefix=new int[n][26];
-        for (int i = 0; i < s.length(); i++) {
-            prefix[i][s.charAt(i)-'a']++;
-            if(i>0)
-                for (int j = 0; j < 26; j++)
-                    prefix[i][j]+=prefix[i-1][j];
-        }
-        return prefix;
-    }
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-        double nextDouble(){
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Strings/Suffix Array/Double-ended Strings.java b/Problemas/Strings/Suffix Array/Double-ended Strings.java
deleted file mode 100644
index a2a4ca8..0000000
--- a/Problemas/Strings/Suffix Array/Double-ended Strings.java	
+++ /dev/null
@@ -1,159 +0,0 @@
-//https://codeforces.com/problemset/problem/1506/C
-import java.util.*;
-import java.io.*;
-public class Main {
-    public static void main(String[] args) throws IOException {
-        Scanner sc = new Scanner();
-        PrintWriter out = new PrintWriter(System.out);
-        int ti=sc.nextInt();
-        for (int trw = 0; trw < ti; trw++) {
-            String s=sc.next()+"$";
-            int[] nums=new int[2];
-            nums[0]=s.length();
-            s+=sc.next()+"%";
-            nums[1]=s.length();
-            int[] p=suffix_array_construction(s);
-            int[] lcp=lcpConstruction(s,p);
-            int max=0;
-            for (int i = 1; i <lcp.length ; i++)
-                if(getI(p[i],nums)!=getI(p[i+1],nums)&&lcp[i]>max)
-                    max=lcp[i];
-            int n=s.length()-2;
-            n-=max*2;
-            System.out.println(n);
-
-        }
-        out.close();
-    }
-    static int getI(int j,int[] nums){
-        return j<nums[0] ? 0:1;
-    }
-    static int[] suffix_array_construction(String s) {
-        int[] sorted_shifts = sortCyclicShifts(s);
-        return Arrays.copyOfRange(sorted_shifts, 0, sorted_shifts.length);
-    }
-
-    public static int[] lcpConstruction(String s, int[] p) {
-        int n = s.length();
-        int[] rank = new int[n];
-        for (int i = 0; i < n; i++) {
-            rank[p[i]] = i;
-        }
-        int k = 0;
-        int[] lcp = new int[n - 1];
-        for (int i = 0; i < n; i++) {
-            if (rank[i] == n - 1) {
-                k = 0;
-                continue;
-            }
-            int j = p[rank[i] + 1];
-            while (i + k < n && j + k < n && s.charAt(i + k) == s.charAt(j + k)) {
-                k++;
-            }
-            lcp[rank[i]] = k;
-            if (k > 0) {
-                k--;
-            }
-        }
-        return lcp;
-    }
-
-    public static int[] sortCyclicShifts(String s) {
-        int n = s.length();
-        int alphabet = 256;
-        int[] p = new int[n];
-        int[] c = new int[n];
-        int[] cnt = new int[Math.max(alphabet, n)];
-        for (int i = 0; i < n; i++)
-            cnt[s.charAt(i)]++;
-        for (int i = 1; i < alphabet; i++)
-            cnt[i] += cnt[i - 1];
-        for (int i = 0; i < n; i++)
-            p[--cnt[s.charAt(i)]] = i;
-        int classes = 1;
-        for (int i = 1; i < n; i++) {
-            if (s.charAt(p[i]) != s.charAt(p[i - 1])) {
-                classes++;
-            }
-            c[p[i]] = classes - 1;
-        }
-
-        int[] pn = new int[n];
-        int[] cn = new int[n];
-        for (int h = 0; (1 << h) < n; h++) {
-            for (int i = 0; i < n; i++) {
-                pn[i] = p[i] - (1 << h);
-                if (pn[i] < 0) {
-                    pn[i] += n;
-                }
-            }
-            Arrays.fill(cnt, 0, classes, 0);
-            for (int i = 0; i < n; i++) {
-                cnt[c[pn[i]]]++;
-            }
-            for (int i = 1; i < classes; i++) {
-                cnt[i] += cnt[i - 1];
-            }
-            for (int i = n - 1; i >= 0; i--) {
-                p[--cnt[c[pn[i]]]] = pn[i];
-            }
-            cn[p[0]] = 0;
-            classes = 1;
-            for (int i = 1; i < n; i++) {
-                int cur1 = c[p[i]];
-                int cur2 = c[(p[i] + (1 << h)) % n];
-                int prev1 = c[p[i - 1]];
-                int prev2 = c[(p[i - 1] + (1 << h)) % n];
-                if (cur1 != prev1 || cur2 != prev2) {
-                    classes++;
-                }
-                cn[p[i]] = classes - 1;
-            }
-            int[] temp = c;
-            c = cn;
-            cn = temp;
-        }
-        return p;
-    }
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    return null;
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Strings/Suffix Array/Editor.java b/Problemas/Strings/Suffix Array/Editor.java
deleted file mode 100644
index 366555e..0000000
--- a/Problemas/Strings/Suffix Array/Editor.java	
+++ /dev/null
@@ -1,151 +0,0 @@
-//https://vjudge.net/problem/UVA-1223
-import java.util.*;
-import java.io.*;
-
-public class Main {
-    public static void main(String[] args) {
-        Scanner sc = new Scanner();
-        PrintWriter pw = new PrintWriter(System.out);
-        int ti = sc.nextInt();
-        for (int times = 0; times < ti; times++) {
-            String s=sc.next();
-            int[] ans=lcpConstruction(s,suffix_array_construction(s));
-            int max=0;
-            for (int i:ans)
-                max= Math.max(max,i);
-            pw.println(max);
-        }
-        pw.close();
-    }
-
-    static int[] suffix_array_construction(String s) {
-        s += "$";
-        int[] sorted_shifts = sortCyclicShifts(s);
-        return Arrays.copyOfRange(sorted_shifts, 1, sorted_shifts.length);
-    }
-
-    public static int[] lcpConstruction(String s, int[] p) {
-        int n = s.length();
-        int[] rank = new int[n];
-        for (int i = 0; i < n; i++) {
-            rank[p[i]] = i;
-        }
-        int k = 0;
-        int[] lcp = new int[n - 1];
-        for (int i = 0; i < n; i++) {
-            if (rank[i] == n - 1) {
-                k = 0;
-                continue;
-            }
-            int j = p[rank[i] + 1];
-            while (i + k < n && j + k < n && s.charAt(i + k) == s.charAt(j + k)) {
-                k++;
-            }
-            lcp[rank[i]] = k;
-            if (k > 0) {
-                k--;
-            }
-        }
-        return lcp;
-    }
-
-    public static int[] sortCyclicShifts(String s) {
-        int n = s.length();
-        int alphabet = 256;
-        int[] p = new int[n];
-        int[] c = new int[n];
-        int[] cnt = new int[Math.max(alphabet, n)];
-        for (int i = 0; i < n; i++)
-            cnt[s.charAt(i)]++;
-        for (int i = 1; i < alphabet; i++)
-            cnt[i] += cnt[i - 1];
-        for (int i = 0; i < n; i++)
-            p[--cnt[s.charAt(i)]] = i;
-        int classes = 1;
-        for (int i = 1; i < n; i++) {
-            if (s.charAt(p[i]) != s.charAt(p[i - 1])) {
-                classes++;
-            }
-            c[p[i]] = classes - 1;
-        }
-
-        int[] pn = new int[n];
-        int[] cn = new int[n];
-        for (int h = 0; (1 << h) < n; h++) {
-            for (int i = 0; i < n; i++) {
-                pn[i] = p[i] - (1 << h);
-                if (pn[i] < 0) {
-                    pn[i] += n;
-                }
-            }
-            Arrays.fill(cnt, 0, classes, 0);
-            for (int i = 0; i < n; i++) {
-                cnt[c[pn[i]]]++;
-            }
-            for (int i = 1; i < classes; i++) {
-                cnt[i] += cnt[i - 1];
-            }
-            for (int i = n - 1; i >= 0; i--) {
-                p[--cnt[c[pn[i]]]] = pn[i];
-            }
-            cn[p[0]] = 0;
-            classes = 1;
-            for (int i = 1; i < n; i++) {
-                int cur1 = c[p[i]];
-                int cur2 = c[(p[i] + (1 << h)) % n];
-                int prev1 = c[p[i - 1]];
-                int prev2 = c[(p[i - 1] + (1 << h)) % n];
-                if (cur1 != prev1 || cur2 != prev2) {
-                    classes++;
-                }
-                cn[p[i]] = classes - 1;
-            }
-            int[] temp = c;
-            c = cn;
-            cn = temp;
-        }
-        return p;
-    }
-
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Strings/Suffix Array/File Recover.cpp b/Problemas/Strings/Suffix Array/File Recover.cpp
deleted file mode 100644
index 104f24e..0000000
--- a/Problemas/Strings/Suffix Array/File Recover.cpp	
+++ /dev/null
@@ -1,83 +0,0 @@
-//https://vjudge.net/problem/UVA-12191
-#include <iostream>
-#include <algorithm>
-#include <cstring>
-#define pb push_back
-using namespace std;
-const int N=200000;
-int sz;
-struct SA {
-#define REP(i,n) for(int i=0;i<int(n);i++)
-#define REP1(i,a,b) for(int i=a;i<=int(b);i++)
-    bool _t[N*2];
-    int _s[N*2], _sa[N*2], _c[N*2], x[N], _p[N], _q[N*2], r[N], hei[N];
-    int operator [] (int i) {return _sa[i];}
-    void build(int* s, int n, int m) {
-        memcpy(_s, s, sizeof(int) * n);
-        sais(_s,_sa,_p,_q,_t,_c,n,m);
-        mkhei(n);
-    }
-    void mkhei(int n) {
-        REP(i,n) r[_sa[i]]=i;
-        hei[0]=0;
-        REP(i,n) if(r[i]) {
-            int ans = i>0 ? max(hei[r[i-1]]-1,0):0;
-            while (_s[i+ans]==_s[_sa[r[i]-1]+ans])ans++;
-            hei[r[i]]=ans;
-        }
-    }
-    void sais(int *s, int *sa, int *p, int *q, bool *t, int *c, int n, int z) {
-        bool uniq = t[n-1] = true, neq;
-        int nn = 0, nmxz = -1, *nsa = sa + n, *ns = s + n, lst = -1;
-#define MS0(x,n) memset((x),0,n*sizeof(*(x)))
-#define MAGIC(XD) MS0(sa, n); \
-        memcpy(x,c,sizeof(int) * z); \
-        XD; \
-        memcpy(x+1,c,sizeof(int) * (z-1));\
-        REP(i,n) if(sa[i] && !t[sa[i]-1]) sa[x[s[sa[i]-1]]++] =sa[i]-1;\
-        memcpy(x,c,sizeof(int) * z); \
-        for(int i =n-1; i>=0;i--)if(sa[i] && t[sa[i]-1]) sa[--x[s[sa[i]-1]]]=sa[i]-1;
-        MS0(c,z);
-        REP(i,n) uniq&= ++c[s[i]]<2;
-        REP(i,z-1) c[i+1] +=c[i];
-        if(uniq) {REP(i,n) sa[--c[s[i]]]=i;return;}
-        for (int i =n-2;i>=0;i--) t[i]=s[i]==s[i+1] ? t[i+1] : s[i]<s[i+1];
-        MAGIC(REP1(i,1,n-1) if(t[i] && !t[i-1]) sa[--x[s[i]]]=p[q[i]=nn++]=i);
-        REP(i,n) if (sa[i] && t[sa[i]] && !t[sa[i]-1]) {
-            neq=lst<0||memcmp(s+sa[i],s+lst,(p[q[sa[i]]+1]-sa[i])*sizeof(int));
-            ns[q[lst=sa[i]]]=nmxz+=neq;
-        }
-        sais(ns, nsa, p+nn, q+n,t+n, c+z, nn, nmxz +1);
-        MAGIC(for (int i = nn-1; i>=0;i--) sa[--x[s[p[nsa[i]]]]]=p[nsa[i]]);
-    }
-}sa;
-int lcp[N], p[N];
-void suffix_array(int* ip, int len) {
-    ip[len++] = 0;
-    sa.build(ip, len, 128);
-    for (int i = 0; i < len; i++) {
-        lcp[i] = sa.hei[i + 1];
-        p[i] = sa._sa[i + 1];
-    }
-}
-int arr[N];
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    string s;
-    while (true) {
-        cin>>s;
-        if(s=="*")
-            break;
-        s+='$';
-        for(int i =0;i<s.size();i++) arr[i]=s[i];
-        suffix_array(arr,s.size());
-        unsigned long long ans=0;
-        for(int i =2;i<s.size();i++) {
-            ans+=max(0,lcp[i]-lcp[i-1]);
-        }
-        cout<<ans<<"\n";
-    }
-    return 0;
-}
diff --git a/Problemas/Strings/Suffix Array/GATTACA.java b/Problemas/Strings/Suffix Array/GATTACA.java
deleted file mode 100644
index c05bada..0000000
--- a/Problemas/Strings/Suffix Array/GATTACA.java	
+++ /dev/null
@@ -1,164 +0,0 @@
-//https://vjudge.net/problem/UVA-11512
-import java.util.*;
-import java.io.*;
-
-public class Main {
-    public static void main(String[] args) {
-        Scanner sc = new Scanner();
-        PrintWriter pw = new PrintWriter(System.out);
-        int ti = sc.nextInt();
-        for (int times = 0; times < ti; times++) {
-            String s=sc.next();
-            int[] p=suffix_array_construction(s);
-            int[] ans=lcpConstruction(s,p);
-            int max=0,rep=-1,j=-1;
-            for (int i = 0; i < ans.length; i++) {
-                if(ans[i]>max){
-                    max=ans[i];
-                    j=i;
-                    rep=2;
-                    while (i<ans.length-1 && ans[i+1]==max){
-                        rep++;
-                        i++;
-                    }
-                }
-            }
-            if(rep==-1)
-                pw.println("No repetitions found!");
-            else
-                pw.println(s.substring(p[j],p[j]+max)+" "+rep);
-        }
-        pw.close();
-    }
-
-    static int[] suffix_array_construction(String s) {
-        s += "$";
-        int[] sorted_shifts = sortCyclicShifts(s);
-        return Arrays.copyOfRange(sorted_shifts, 1, sorted_shifts.length);
-    }
-
-    public static int[] lcpConstruction(String s, int[] p) {
-        int n = s.length();
-        int[] rank = new int[n];
-        for (int i = 0; i < n; i++) {
-            rank[p[i]] = i;
-        }
-        int k = 0;
-        int[] lcp = new int[n - 1];
-        for (int i = 0; i < n; i++) {
-            if (rank[i] == n - 1) {
-                k = 0;
-                continue;
-            }
-            int j = p[rank[i] + 1];
-            while (i + k < n && j + k < n && s.charAt(i + k) == s.charAt(j + k)) {
-                k++;
-            }
-            lcp[rank[i]] = k;
-            if (k > 0) {
-                k--;
-            }
-        }
-        return lcp;
-    }
-
-    public static int[] sortCyclicShifts(String s) {
-        int n = s.length();
-        int alphabet = 256;
-        int[] p = new int[n];
-        int[] c = new int[n];
-        int[] cnt = new int[Math.max(alphabet, n)];
-        for (int i = 0; i < n; i++)
-            cnt[s.charAt(i)]++;
-        for (int i = 1; i < alphabet; i++)
-            cnt[i] += cnt[i - 1];
-        for (int i = 0; i < n; i++)
-            p[--cnt[s.charAt(i)]] = i;
-        int classes = 1;
-        for (int i = 1; i < n; i++) {
-            if (s.charAt(p[i]) != s.charAt(p[i - 1])) {
-                classes++;
-            }
-            c[p[i]] = classes - 1;
-        }
-
-        int[] pn = new int[n];
-        int[] cn = new int[n];
-        for (int h = 0; (1 << h) < n; h++) {
-            for (int i = 0; i < n; i++) {
-                pn[i] = p[i] - (1 << h);
-                if (pn[i] < 0) {
-                    pn[i] += n;
-                }
-            }
-            Arrays.fill(cnt, 0, classes, 0);
-            for (int i = 0; i < n; i++) {
-                cnt[c[pn[i]]]++;
-            }
-            for (int i = 1; i < classes; i++) {
-                cnt[i] += cnt[i - 1];
-            }
-            for (int i = n - 1; i >= 0; i--) {
-                p[--cnt[c[pn[i]]]] = pn[i];
-            }
-            cn[p[0]] = 0;
-            classes = 1;
-            for (int i = 1; i < n; i++) {
-                int cur1 = c[p[i]];
-                int cur2 = c[(p[i] + (1 << h)) % n];
-                int prev1 = c[p[i - 1]];
-                int prev2 = c[(p[i - 1] + (1 << h)) % n];
-                if (cur1 != prev1 || cur2 != prev2) {
-                    classes++;
-                }
-                cn[p[i]] = classes - 1;
-            }
-            int[] temp = c;
-            c = cn;
-            cn = temp;
-        }
-        return p;
-    }
-
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Strings/Suffix Array/Longest Common Substring II .cpp b/Problemas/Strings/Suffix Array/Longest Common Substring II .cpp
deleted file mode 100644
index bceb65e..0000000
--- a/Problemas/Strings/Suffix Array/Longest Common Substring II .cpp	
+++ /dev/null
@@ -1,222 +0,0 @@
-//https://vjudge.net/problem/SPOJ-LCS2
-#include <iostream>
-#include <algorithm>
-#include <cstring>
-#include <vector>
-#define pb push_back
-using namespace std;
-const int N=2000010;
-int sz;
-int* t;
-int* tt;
-void buildST(int a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        buildST(a, v*2, tl, tm);
-        buildST(a, v*2+1, tm+1, tr);
-        t[v] = min(t[v*2] ,t[v*2+1]);
-    }
-}
-void build(int a[], int n) {
-    buildST(a,1,0,n-1);
-}
-int sumQ(int v, int tl, int tr, int l, int r) {
-    if (l > r)
-        return 2140000000;
-    if (l == tl && r == tr) {
-        return t[v];
-    }
-    int tm = (tl + tr) / 2;
-    return min(sumQ(v*2, tl, tm, l, min(r, tm))
-           , sumQ(v*2+1, tm+1, tr, max(l, tm+1), r));
-}
-int sum(int n,int l, int r) {
-    return sumQ(1,0,n-1,l,r);
-}
-void updateQ(int v, int tl, int tr, int pos, int new_val) {
-    if (tl == tr) {
-        t[v]= new_val;
-    } else {
-        int tm = (tl + tr) / 2;
-        if (pos <= tm)
-            updateQ(v*2, tl, tm, pos, new_val);
-        else
-            updateQ(v*2+1, tm+1, tr, pos, new_val);
-        t[v] = min(t[v*2] , t[v*2+1]);
-    }
-}
-void update(int n, int pos, int x) {
-    updateQ(1,0,n-1,pos,x);
-}
-
-
-//segundo segment
-
-void buildST2(int a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        tt[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        buildST2(a, v*2, tl, tm);
-        buildST2(a, v*2+1, tm+1, tr);
-        tt[v] = min(tt[v*2] ,tt[v*2+1]);
-    }
-}
-void build2(int a[], int n) {
-    buildST2(a,1,0,n-1);
-}
-int sumQ2(int v, int tl, int tr, int l, int r) {
-    if (l > r)
-        return 2140000000;
-    if (l == tl && r == tr) {
-        return tt[v];
-    }
-    int tm = (tl + tr) / 2;
-    return min(sumQ2(v*2, tl, tm, l, min(r, tm))
-           , sumQ2(v*2+1, tm+1, tr, max(l, tm+1), r));
-}
-int sum2(int n,int l, int r) {
-    return sumQ2(1,0,n-1,l,r);
-}
-void updateQ2(int v, int tl, int tr, int pos, int new_val) {
-    if (tl == tr) {
-        tt[v]= new_val;
-    } else {
-        int tm = (tl + tr) / 2;
-        if (pos <= tm)
-            updateQ2(v*2, tl, tm, pos, new_val);
-        else
-            updateQ2(v*2+1, tm+1, tr, pos, new_val);
-        tt[v] = min(tt[v*2] , tt[v*2+1]);
-    }
-}
-void update2(int n, int pos, int x) {
-    updateQ2(1,0,n-1,pos,x);
-}
-struct SA {
-#define REP(i,n) for(int i=0;i<int(n);i++)
-#define REP1(i,a,b) for(int i=a;i<=int(b);i++)
-    bool _t[N*2];
-    int _s[N*2], _sa[N*2], _c[N*2], x[N], _p[N], _q[N*2], r[N], hei[N];
-    int operator [] (int i) {return _sa[i];}
-    void build(int* s, int n, int m) {
-        memcpy(_s, s, sizeof(int) * n);
-        sais(_s,_sa,_p,_q,_t,_c,n,m);
-        mkhei(n);
-    }
-    void mkhei(int n) {
-        REP(i,n) r[_sa[i]]=i;
-        hei[0]=0;
-        REP(i,n) if(r[i]) {
-            int ans = i>0 ? max(hei[r[i-1]]-1,0):0;
-            while (_s[i+ans]==_s[_sa[r[i]-1]+ans])ans++;
-            hei[r[i]]=ans;
-        }
-    }
-    void sais(int *s, int *sa, int *p, int *q, bool *t, int *c, int n, int z) {
-        bool uniq = t[n-1] = true, neq;
-        int nn = 0, nmxz = -1, *nsa = sa + n, *ns = s + n, lst = -1;
-#define MS0(x,n) memset((x),0,n*sizeof(*(x)))
-#define MAGIC(XD) MS0(sa, n); \
-        memcpy(x,c,sizeof(int) * z); \
-        XD; \
-        memcpy(x+1,c,sizeof(int) * (z-1));\
-        REP(i,n) if(sa[i] && !t[sa[i]-1]) sa[x[s[sa[i]-1]]++] =sa[i]-1;\
-        memcpy(x,c,sizeof(int) * z); \
-        for(int i =n-1; i>=0;i--)if(sa[i] && t[sa[i]-1]) sa[--x[s[sa[i]-1]]]=sa[i]-1;
-        MS0(c,z);
-        REP(i,n) uniq&= ++c[s[i]]<2;
-        REP(i,z-1) c[i+1] +=c[i];
-        if(uniq) {REP(i,n) sa[--c[s[i]]]=i;return;}
-        for (int i =n-2;i>=0;i--) t[i]=s[i]==s[i+1] ? t[i+1] : s[i]<s[i+1];
-        MAGIC(REP1(i,1,n-1) if(t[i] && !t[i-1]) sa[--x[s[i]]]=p[q[i]=nn++]=i);
-        REP(i,n) if (sa[i] && t[sa[i]] && !t[sa[i]-1]) {
-            neq=lst<0||memcmp(s+sa[i],s+lst,(p[q[sa[i]]+1]-sa[i])*sizeof(int));
-            ns[q[lst=sa[i]]]=nmxz+=neq;
-        }
-        sais(ns, nsa, p+nn, q+n,t+n, c+z, nn, nmxz +1);
-        MAGIC(for (int i = nn-1; i>=0;i--) sa[--x[s[p[nsa[i]]]]]=p[nsa[i]]);
-    }
-}sa;
-int lcp[N], p[N];
-
-void suffix_array(int* ip, int len) {
-    ip[len++] = 0;
-    sa.build(ip, len, 128);
-    for (int i = 0; i < len; i++) {
-        lcp[i] = sa.hei[i + 1];
-        p[i] = sa._sa[i + 1];
-    }
-}
-
-int arr[N];
-
-
-int getI(int j, int* nums)  {
-
-    int l = 0;
-    int r = sz - 1;
-    while (l <= r) {
-        int mid = l + (r - l) / 2;
-        if (j < nums[mid]) {
-            if (j > nums[mid - 1])
-                return mid - 1;
-            r = mid - 1;
-        } else {
-            if (j < nums[mid + 1])
-                return mid;
-            l = mid + 1;
-        }
-    }
-    return -1;
-}
-
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    string r;
-    vector<string> cad(0);
-    while (true) {
-        getline(cin,r);
-        if(r.empty())
-            break;
-        cad.pb(r);
-    }
-    int n=cad.size();
-    int* nums=new int[n+1];
-    int* index=new int[n];
-    fill_n(index,n,-1);
-    string s;
-    cout<<endl;
-    for(int i =0;i<cad.size();i++) {
-        s+=cad[i]+static_cast<char>('A' + i);
-        nums[i+1]=s.length();
-    }
-    sz=cad.size()+1;
-    nums[0]=0;
-    for(int i =0;i<s.size();i++) arr[i]=s[i];
-    suffix_array(arr,s.size());
-    int* a1=new int[s.size()];
-    for(int i =0;i<s.size();i++)
-        a1[i]=lcp[i];
-    t=new int[s.size()*4];
-    tt=new int[cad.size()*4];
-    build(a1,s.size());
-    build2(index,cad.size());
-    int ans=0;
-    for (int i = n;i<s.size();i++) {
-        update2(n,getI(p[i],nums),i);
-        int mn=sum2(n,0,n-1);
-        if(mn!=-1) {
-            ans=max(ans,sum(s.size(),mn+1,i));
-        }
-    }
-    cout<<"\n"<<ans;
-    delete[] nums;
-    delete[] index;
-    delete[] t;
-    return 0;
-}
diff --git a/Problemas/Strings/Suffix Array/Longest Common Substring.cpp b/Problemas/Strings/Suffix Array/Longest Common Substring.cpp
deleted file mode 100644
index 1f94fe8..0000000
--- a/Problemas/Strings/Suffix Array/Longest Common Substring.cpp	
+++ /dev/null
@@ -1,90 +0,0 @@
-//https://vjudge.net/problem/SPOJ-LCS
-#include <iostream>
-#include <algorithm>
-#include <cstring>
-
-using namespace std;
-typedef long long ll;
-int nums[3];
-const int N=500010;
-struct SA {
-#define REP(i,n) for(int i=0;i<int(n);i++)
-#define REP1(i,a,b) for(int i=a;i<=int(b);i++)
-    bool _t[N*2];
-    int _s[N*2], _sa[N*2], _c[N*2], x[N], _p[N], _q[N*2], r[N], hei[N];
-    int operator [] (int i) {return _sa[i];}
-    void build(int* s, int n, int m) {
-        memcpy(_s, s, sizeof(int) * n);
-        sais(_s,_sa,_p,_q,_t,_c,n,m);
-        mkhei(n);
-    }
-    void mkhei(int n) {
-        REP(i,n) r[_sa[i]]=i;
-        hei[0]=0;
-        REP(i,n) if(r[i]) {
-            int ans = i>0 ? max(hei[r[i-1]]-1,0):0;
-            while (_s[i+ans]==_s[_sa[r[i]-1]+ans])ans++;
-            hei[r[i]]=ans;
-        }
-    }
-    void sais(int *s, int *sa, int *p, int *q, bool *t, int *c, int n, int z) {
-        bool uniq = t[n-1] = true, neq;
-        int nn = 0, nmxz = -1, *nsa = sa + n, *ns = s + n, lst = -1;
-#define MS0(x,n) memset((x),0,n*sizeof(*(x)))
-#define MAGIC(XD) MS0(sa, n); \
-        memcpy(x,c,sizeof(int) * z); \
-        XD; \
-        memcpy(x+1,c,sizeof(int) * (z-1));\
-        REP(i,n) if(sa[i] && !t[sa[i]-1]) sa[x[s[sa[i]-1]]++] =sa[i]-1;\
-        memcpy(x,c,sizeof(int) * z); \
-        for(int i =n-1; i>=0;i--)if(sa[i] && t[sa[i]-1]) sa[--x[s[sa[i]-1]]]=sa[i]-1;
-        MS0(c,z);
-        REP(i,n) uniq&= ++c[s[i]]<2;
-        REP(i,z-1) c[i+1] +=c[i];
-        if(uniq) {REP(i,n) sa[--c[s[i]]]=i;return;}
-        for (int i =n-2;i>=0;i--) t[i]=s[i]==s[i+1] ? t[i+1] : s[i]<s[i+1];
-        MAGIC(REP1(i,1,n-1) if(t[i] && !t[i-1]) sa[--x[s[i]]]=p[q[i]=nn++]=i);
-        REP(i,n) if (sa[i] && t[sa[i]] && !t[sa[i]-1]) {
-            neq=lst<0||memcmp(s+sa[i],s+lst,(p[q[sa[i]]+1]-sa[i])*sizeof(int));
-            ns[q[lst=sa[i]]]=nmxz+=neq;
-        }
-        sais(ns, nsa, p+nn, q+n,t+n, c+z, nn, nmxz +1);
-        MAGIC(for (int i = nn-1; i>=0;i--) sa[--x[s[p[nsa[i]]]]]=p[nsa[i]]);
-    }
-}sa;
-int lcp[N], p[N];
-
-void suffix_array(int* ip, int len) {
-    ip[len++] = 0;
-    sa.build(ip, len, 128);
-    for (int i = 0; i < len; i++) {
-        lcp[i] = sa.hei[i + 1];
-        p[i] = sa._sa[i + 1];
-    }
-}
-
-int arr[N];
-
-
-int getI(int j) {
-    return j < nums[1] ? 0 : 1;
-}
-
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    string s, t;
-    cin >> s >> t;
-    nums[1] = s.length() + 1;
-    s += "$" + t  +"%"  ;
-    for (int i =0;i<s.length();i++) arr[i]=s[i];
-    nums[2] = s.length();
-    suffix_array(arr,s.size());
-    int maxLCP = 0;
-    for (int i = 2; i<s.size() ; i++) {
-        if (getI(p[i]) != getI(p[i - 1]) && lcp[i] > maxLCP)
-            maxLCP = lcp[i];
-    }
-    cout << maxLCP << endl;
-    return 0;
-}
diff --git a/Problemas/Strings/Suffix Array/Longest Common Substring.java b/Problemas/Strings/Suffix Array/Longest Common Substring.java
deleted file mode 100644
index 60ab631..0000000
--- a/Problemas/Strings/Suffix Array/Longest Common Substring.java	
+++ /dev/null
@@ -1,164 +0,0 @@
-//https://vjudge.net/problem/SPOJ-LCS
-import java.util.*;
-import java.io.*;
-
-public class Main {
-    public static void main(String[] args) {
-        Scanner sc = new Scanner();
-        PrintWriter pw = new PrintWriter(System.out);
-        int[] sum=new int[2];
-        String s=sc.next()+'$';
-        sum[0]=s.length();
-        s+=sc.next()+'$';
-        sum[1]=s.length();
-        int[] p=suffix_array_construction(s);
-        int[] lcp=lcpConstruction(s,p);
-        int ans=0;
-        //System.out.println(Arrays.toString(p));
-        //System.out.println(Arrays.toString(lcp));
-        for (int i = 2; i < p.length-1; i++)
-            if(search(sum,p[i])!=search(sum,p[i+1])) {
-                //System.out.println("akjbsdj");
-                ans = Math.max(ans, lcp[i]);
-            }
-        System.out.println(ans);
-
-    }
-    static int search(int[] arr,int x){
-        for (int i = 0; i < arr.length; i++) {
-            if(x<arr[i])
-                return i;
-        }
-        return arr.length-1;
-    }
-
-    static int[] suffix_array_construction(String s) {
-        return sortCyclicShifts(s);
-        //return Arrays.copyOfRange(sorted_shifts, 1, sorted_shifts.length);
-    }
-
-    public static int[] lcpConstruction(String s, int[] p) {
-        int n = s.length();
-        int[] rank = new int[n];
-        for (int i = 0; i < n; i++) {
-            rank[p[i]] = i;
-        }
-        int k = 0;
-        int[] lcp = new int[n - 1];
-        for (int i = 0; i < n; i++) {
-            if (rank[i] == n - 1) {
-                k = 0;
-                continue;
-            }
-            int j = p[rank[i] + 1];
-            while (i + k < n && j + k < n && s.charAt(i + k) == s.charAt(j + k)) {
-                k++;
-            }
-            lcp[rank[i]] = k;
-            if (k > 0) {
-                k--;
-            }
-        }
-        return lcp;
-    }
-
-    public static int[] sortCyclicShifts(String s) {
-        int n = s.length();
-        int alphabet = 256;
-        int[] p = new int[n];
-        int[] c = new int[n];
-        int[] cnt = new int[Math.max(alphabet, n)];
-        for (int i = 0; i < n; i++)
-            cnt[s.charAt(i)]++;
-        for (int i = 1; i < alphabet; i++)
-            cnt[i] += cnt[i - 1];
-        for (int i = 0; i < n; i++)
-            p[--cnt[s.charAt(i)]] = i;
-        int classes = 1;
-        for (int i = 1; i < n; i++) {
-            if (s.charAt(p[i]) != s.charAt(p[i - 1])) {
-                classes++;
-            }
-            c[p[i]] = classes - 1;
-        }
-
-        int[] pn = new int[n];
-        int[] cn = new int[n];
-        for (int h = 0; (1 << h) < n; h++) {
-            for (int i = 0; i < n; i++) {
-                pn[i] = p[i] - (1 << h);
-                if (pn[i] < 0) {
-                    pn[i] += n;
-                }
-            }
-            Arrays.fill(cnt, 0, classes, 0);
-            for (int i = 0; i < n; i++) {
-                cnt[c[pn[i]]]++;
-            }
-            for (int i = 1; i < classes; i++) {
-                cnt[i] += cnt[i - 1];
-            }
-            for (int i = n - 1; i >= 0; i--) {
-                p[--cnt[c[pn[i]]]] = pn[i];
-            }
-            cn[p[0]] = 0;
-            classes = 1;
-            for (int i = 1; i < n; i++) {
-                int cur1 = c[p[i]];
-                int cur2 = c[(p[i] + (1 << h)) % n];
-                int prev1 = c[p[i - 1]];
-                int prev2 = c[(p[i - 1] + (1 << h)) % n];
-                if (cur1 != prev1 || cur2 != prev2) {
-                    classes++;
-                }
-                cn[p[i]] = classes - 1;
-            }
-            int[] temp = c;
-            c = cn;
-            cn = temp;
-        }
-        return p;
-    }
-
-
-    static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        char nextChar() throws IOException {
-            return (char) br.read();
-        }
-
-    }
-}
diff --git a/Problemas/Strings/Suffix Array/The longest constant gene.cpp b/Problemas/Strings/Suffix Array/The longest constant gene.cpp
deleted file mode 100644
index ed1669f..0000000
--- a/Problemas/Strings/Suffix Array/The longest constant gene.cpp	
+++ /dev/null
@@ -1,220 +0,0 @@
-//https://vjudge.net/problem/UVA-1227
-#include <iostream>
-#include <algorithm>
-#include <cstring>
-#include <vector>
-#define pb push_back
-using namespace std;
-const int N=7100010;
-int sz;
-int* t;
-int* tt;
-void buildST(int a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        t[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        buildST(a, v*2, tl, tm);
-        buildST(a, v*2+1, tm+1, tr);
-        t[v] = min(t[v*2] ,t[v*2+1]);
-    }
-}
-void build(int a[], int n) {
-    buildST(a,1,0,n-1);
-}
-int sumQ(int v, int tl, int tr, int l, int r) {
-    if (l > r)
-        return 2140000000;
-    if (l == tl && r == tr) {
-        return t[v];
-    }
-    int tm = (tl + tr) / 2;
-    return min(sumQ(v*2, tl, tm, l, min(r, tm))
-           , sumQ(v*2+1, tm+1, tr, max(l, tm+1), r));
-}
-int sum(int n,int l, int r) {
-    return sumQ(1,0,n-1,l,r);
-}
-void updateQ(int v, int tl, int tr, int pos, int new_val) {
-    if (tl == tr) {
-        t[v]= new_val;
-    } else {
-        int tm = (tl + tr) / 2;
-        if (pos <= tm)
-            updateQ(v*2, tl, tm, pos, new_val);
-        else
-            updateQ(v*2+1, tm+1, tr, pos, new_val);
-        t[v] = min(t[v*2] , t[v*2+1]);
-    }
-}
-void update(int n, int pos, int x) {
-    updateQ(1,0,n-1,pos,x);
-}
-
-
-//segundo segment
-
-void buildST2(int a[], int v, int tl, int tr) {
-    if (tl == tr) {
-        tt[v] = a[tl];
-    } else {
-        int tm = (tl + tr) / 2;
-        buildST2(a, v*2, tl, tm);
-        buildST2(a, v*2+1, tm+1, tr);
-        tt[v] = min(tt[v*2] ,tt[v*2+1]);
-    }
-}
-void build2(int a[], int n) {
-    buildST2(a,1,0,n-1);
-}
-int sumQ2(int v, int tl, int tr, int l, int r) {
-    if (l > r)
-        return 2140000000;
-    if (l == tl && r == tr) {
-        return tt[v];
-    }
-    int tm = (tl + tr) / 2;
-    return min(sumQ2(v*2, tl, tm, l, min(r, tm))
-           , sumQ2(v*2+1, tm+1, tr, max(l, tm+1), r));
-}
-int sum2(int n,int l, int r) {
-    return sumQ2(1,0,n-1,l,r);
-}
-void updateQ2(int v, int tl, int tr, int pos, int new_val) {
-    if (tl == tr) {
-        tt[v]= new_val;
-    } else {
-        int tm = (tl + tr) / 2;
-        if (pos <= tm)
-            updateQ2(v*2, tl, tm, pos, new_val);
-        else
-            updateQ2(v*2+1, tm+1, tr, pos, new_val);
-        tt[v] = min(tt[v*2] , tt[v*2+1]);
-    }
-}
-void update2(int n, int pos, int x) {
-    updateQ2(1,0,n-1,pos,x);
-}
-struct SA {
-#define REP(i,n) for(int i=0;i<int(n);i++)
-#define REP1(i,a,b) for(int i=a;i<=int(b);i++)
-    bool _t[N*2];
-    int _s[N*2], _sa[N*2], _c[N*2], x[N], _p[N], _q[N*2], r[N], hei[N];
-    int operator [] (int i) {return _sa[i];}
-    void build(int* s, int n, int m) {
-        memcpy(_s, s, sizeof(int) * n);
-        sais(_s,_sa,_p,_q,_t,_c,n,m);
-        mkhei(n);
-    }
-    void mkhei(int n) {
-        REP(i,n) r[_sa[i]]=i;
-        hei[0]=0;
-        REP(i,n) if(r[i]) {
-            int ans = i>0 ? max(hei[r[i-1]]-1,0):0;
-            while (_s[i+ans]==_s[_sa[r[i]-1]+ans])ans++;
-            hei[r[i]]=ans;
-        }
-    }
-    void sais(int *s, int *sa, int *p, int *q, bool *t, int *c, int n, int z) {
-        bool uniq = t[n-1] = true, neq;
-        int nn = 0, nmxz = -1, *nsa = sa + n, *ns = s + n, lst = -1;
-#define MS0(x,n) memset((x),0,n*sizeof(*(x)))
-#define MAGIC(XD) MS0(sa, n); \
-        memcpy(x,c,sizeof(int) * z); \
-        XD; \
-        memcpy(x+1,c,sizeof(int) * (z-1));\
-        REP(i,n) if(sa[i] && !t[sa[i]-1]) sa[x[s[sa[i]-1]]++] =sa[i]-1;\
-        memcpy(x,c,sizeof(int) * z); \
-        for(int i =n-1; i>=0;i--)if(sa[i] && t[sa[i]-1]) sa[--x[s[sa[i]-1]]]=sa[i]-1;
-        MS0(c,z);
-        REP(i,n) uniq&= ++c[s[i]]<2;
-        REP(i,z-1) c[i+1] +=c[i];
-        if(uniq) {REP(i,n) sa[--c[s[i]]]=i;return;}
-        for (int i =n-2;i>=0;i--) t[i]=s[i]==s[i+1] ? t[i+1] : s[i]<s[i+1];
-        MAGIC(REP1(i,1,n-1) if(t[i] && !t[i-1]) sa[--x[s[i]]]=p[q[i]=nn++]=i);
-        REP(i,n) if (sa[i] && t[sa[i]] && !t[sa[i]-1]) {
-            neq=lst<0||memcmp(s+sa[i],s+lst,(p[q[sa[i]]+1]-sa[i])*sizeof(int));
-            ns[q[lst=sa[i]]]=nmxz+=neq;
-        }
-        sais(ns, nsa, p+nn, q+n,t+n, c+z, nn, nmxz +1);
-        MAGIC(for (int i = nn-1; i>=0;i--) sa[--x[s[p[nsa[i]]]]]=p[nsa[i]]);
-    }
-}sa;
-int lcp[N], p[N];
-
-void suffix_array(int* ip, int len) {
-    ip[len++] = 0;
-    sa.build(ip, len, 128);
-    for (int i = 0; i < len; i++) {
-        lcp[i] = sa.hei[i + 1];
-        p[i] = sa._sa[i + 1];
-    }
-}
-
-int arr[N];
-
-
-int getI(int j, int* nums)  {
-
-    int l = 0;
-    int r = sz - 1;
-    while (l <= r) {
-        int mid = l + (r - l) / 2;
-        if (j < nums[mid]) {
-            if (j > nums[mid - 1])
-                return mid - 1;
-            r = mid - 1;
-        } else {
-            if (j < nums[mid + 1])
-                return mid;
-            l = mid + 1;
-        }
-    }
-    return -1;
-}
-
-int main() {
-    ios_base::sync_with_stdio(0);
-    cin.tie(0);
-    cout.tie(0);
-    int ti;
-    cin>>ti;
-    while (ti--) {
-        string r;
-        string s;
-        int n;
-        cin>>n;
-        int* nums=new int[n+1];
-        int* index=new int[n];
-        fill_n(index,n,-1);
-        for (int i = 0; i < n; i++) {
-            cin>>r;
-            s+=r+(char)(0+i);
-            nums[i+1]=s.length();
-        }
-        nums[0]=0;
-        sz=n+1;
-        for(int i =0;i<s.size();i++) arr[i]=s[i];
-        suffix_array(arr,s.size());
-        int* a1=new int[s.size()];
-        for(int i =0;i<s.size();i++)
-            a1[i]=lcp[i];
-        t=new int[s.size()*4];
-        tt=new int[n*4];
-        build(a1,s.size());
-        build2(index,n);
-        int ans=0;
-        for (int i = n;i<s.size();i++) {
-            update2(n,getI(p[i],nums),i);
-            int mn=sum2(n,0,n-1);
-            if(mn!=-1) {
-                ans=max(ans,sum(s.size(),mn+1,i));
-            }
-        }
-        cout<<ans<<endl;
-        delete[] nums;
-        delete[] index;
-        delete[] t;
-    }
-    return 0;
-}
diff --git a/Problemas/Strings/Wheres Waldorf.java b/Problemas/Strings/Wheres Waldorf.java
deleted file mode 100644
index 79c44c5..0000000
--- a/Problemas/Strings/Wheres Waldorf.java	
+++ /dev/null
@@ -1,172 +0,0 @@
-// https://open.kattis.com/problems/stringmatching
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.*;
-
-public class Main {
-    public static void main(String[] args)throws IOException {
-        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
-        int t=Integer.parseInt(bf.readLine());
-        for (int time = 0; time < t; time++) {
-            bf.readLine();
-            String[] l1=bf.readLine().split(" ");
-            int m=Integer.parseInt(l1[0]);
-            int n=Integer.parseInt(l1[1]);
-            char[][] l=new char[m][n];
-            for (int i = 0; i < m; i++) {
-                for (int j = 0; j < n; j++) {
-                    char c=(char)bf.read();
-                    if(c>='A'&&c<='Z')
-                        c+=32;
-                    l[i][j]=c;
-                }
-                bf.readLine();
-            }
-            int cases=Integer.parseInt(bf.readLine());
-            for (int times = 0; times < cases; times++) {
-                String s=bf.readLine().toLowerCase();
-                ArrayList<int[]> ans=solve(l,s);
-                Collections.sort(ans,new CustomComparator());
-                System.out.println(ans.get(0)[0]+" "+ans.get(0)[1]);
-            }
-            if(time!=t-1)
-                System.out.println();
-        }
-    }
-    static ArrayList<int[]> solve(char[][] m,String s){
-        ArrayList<int[]> l=new ArrayList<>();
-        for (int i = 0; i < m.length; i++) {
-            int index=0;
-            for (int j = 0; j < m[0].length; j++) {
-                if(m[i][j]==s.charAt(index))
-                    index++;
-                else if(index>0){
-                    index=0;
-                    j--;
-                }
-                if(index==s.length()) {
-                    l.add(new int[]{i + 1, j + 2 - index});
-                    break;
-                }
-            }
-        }
-        for (int i = m.length-1; i >=0; i--) {
-            int index=0;
-            for (int j = m[0].length-1; j >=0; j--) {
-                if(m[i][j]==s.charAt(index))
-                    index++;
-                else if(index>0){
-                    index=0;
-                    j++;
-                }
-                if(index==s.length()){
-                    l.add(new int[]{i + 1, j + index});
-                    break;
-                }
-            }
-        }
-        for (int i = 0; i < m[0].length; i++) {
-            int index=0;
-            for (int j = 0; j < m.length; j++) {
-                if(m[j][i]==s.charAt(index))
-                    index++;
-                else if(index>0) {
-                    index = 0;
-                    j--;
-                }
-                if(index==s.length()){
-                    l.add(new int[]{j + 2-index, i + 1});
-                    break;
-                }
-
-            }
-        }
-        for (int i = 0; i <m.length ; i++) {
-            for (int j = 0; j < m[0].length; j++) {
-                if(m[i][j]==s.charAt(0))
-                    if(searchDownUp(m,s,i,j))
-                        l.add(new int[]{i+1,j+1});
-            }
-        }
-        for (int i = 0; i < m.length; i++) {
-            for (int j = 0; j < m[0].length; j++) {
-                if(m[i][j]==s.charAt(0)) {
-                    int d=searchDiagonal(m,s,i,j);
-                    if (d==0) {
-                        l.add(new int[]{i + 1, j + 1});
-                        break;
-                    }
-                    else if(d==1){
-                        l.add(new int[]{i + 1, j + 1});
-                        break;
-                    }
-                    else if(d==2){
-                        l.add(new int[]{i + 1, j + 1});
-                        break;
-                    }
-                    else if(d==3){
-                        l.add(new int[]{i + 1, j + 1});
-                        break;
-                    }
-                }
-            }
-        }
-        return l;
-    }
-    static boolean searchDownUp(char[][]m,String s,int a,int b){
-        int index=0;
-        for (int i = a; i >=0; i--) {
-            if(m[i][b]==s.charAt(index))
-                index++;
-            else
-                return false;
-            if(index==s.length())
-                return true;
-
-        }
-        return false;
-    }
-    static int searchDiagonal(char[][]m,String s,int a,int b){
-        int index=0;
-        for (int i = 0; i < m.length&&a+i<m.length&&b+i<m[0].length; i++) {
-            if(m[a+i][b+i]==s.charAt(index))
-                index++;
-            else break;
-            if(index==s.length())
-                return 0;
-        }index=0;
-        for (int i = 0; i < m.length&&a+i<m.length&&b-i>=0; i++) {
-            if(m[a+i][b-i]==s.charAt(index))
-                index++;
-            else break;
-            if(index==s.length())
-                return 1;
-        }index=0;
-        for (int i = 0; i < m.length&&a-i>=0&&b+i<m[0].length; i++) {
-            if(m[a-i][b+i]==s.charAt(index))
-                index++;
-            else break;
-            if(index==s.length())
-                return 2;
-        }index=0;
-        for (int i = 0; i < m.length&&a-i>=0&&b-i>=0; i++) {
-            if(m[a-i][b-i]==s.charAt(index))
-                index++;
-            else break;
-            if(index==s.length())
-                return 3;
-        }
-        return -1;
-    }
-    public static class CustomComparator implements Comparator<int[]> {
-        @Override
-        public int compare(int[] a, int[] b) {
-            if (a[0] != b[0]) {
-                return Integer.compare(a[0], b[0]);
-            } else {
-                return Integer.compare(a[1], b[1]);
-            }
-        }
-    }
-}
diff --git a/Problemas/Strings/WordSearchWonder.java b/Problemas/Strings/WordSearchWonder.java
deleted file mode 100644
index 9f8724c..0000000
--- a/Problemas/Strings/WordSearchWonder.java
+++ /dev/null
@@ -1,120 +0,0 @@
-// https://vjudge.net/problem/UVA-422
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-
-
-public class Main {
-    public static void main(String[] args) throws IOException {
-        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));
-        int l= Integer.parseInt(bf.readLine());
-        char[][] m=new char[l][l];
-        for (int i = 0; i < l; i++) {
-            for (int j = 0; j < l; j++) {
-                m[i][j]=(char)bf.read();
-            }
-            bf.readLine();
-        }
-        while(true){
-            String s=bf.readLine();
-            if(s.length()>l){
-                System.out.println("Not found");
-                return;
-            }
-            if(s.equals("0"))
-                return;
-            System.out.println(solve(m,s));
-        }
-    }
-    static String solve(char[][] m,String s){
-        for (int i = 0; i < m.length; i++) {
-            int index=0;
-            for (int j = 0; j < m.length; j++) {
-                if(m[i][j]==s.charAt(index))
-                    index++;
-                else if(index>0){
-
-                    index=0;
-                    j--;
-                }
-                if(index==s.length())
-                    return (i+1)+","+(j+2-index)+" "+(i+1)+","+(j+1);
-            }
-        }
-        for (int i = m.length-1; i >=0; i--) {
-            int index=0;
-            for (int j = m.length-1; j >=0; j--) {
-                if(m[i][j]==s.charAt(index))
-                    index++;
-                else if(index>0){
-                    index=0;
-                    j++;
-                }
-                if(index==s.length())
-                    return (i+1)+","+(j+index)+" "+(i+1)+","+(j+1);
-            }
-        }
-        for (int i = 0; i < m.length; i++) {
-            int index=0;
-            for (int j = 0; j < m.length; j++) {
-                if(m[j][i]==s.charAt(index))
-                    index++;
-                else if(index>0) {
-
-                    index = 0;
-                    j--;
-                }
-                if(index==s.length())
-                    return ((j+2)-index)+","+(i+1)+" "+(j+1)+","+(i+1);
-            }
-        }
-        for (int i = 0; i < m.length; i++) {
-            for (int j = 0; j < m.length; j++) {
-                if(m[i][j]==s.charAt(0)) {
-                    int d=searchDiagonal(m,s,i,j);
-                    if (d==0)
-                        return (i + 1) + "," + (j + 1) + " " + (i + s.length()) + "," + (j + s.length());
-                    else if(d==1)
-                        return (i + 1) + "," + (j + 1) + " " + (i + s.length()) + "," + (j +2- s.length());
-                    else if(d==2)
-                        return (i + 1) + "," + (j + 1) + " " + (i +2- s.length()) + "," + (j + s.length());
-                    else if(d==3)
-                        return (i + 1) + "," + (j + 1) + " " + (i +2- s.length()) + "," + (j +2- s.length());
-                }
-            }
-        }
-        return "Not found";
-    }
-    static int searchDiagonal(char[][]m,String s,int a,int b){
-        int index=0;
-        for (int i = 0; i < m.length&&a+i<m.length&&b+i<m.length; i++) {
-            if(m[a+i][b+i]==s.charAt(index))
-                index++;
-            else break;
-            if(index==s.length())
-                return 0;
-        }index=0;
-        for (int i = 0; i < m.length&&a+i<m.length&&b-i>=0; i++) {
-            if(m[a+i][b-i]==s.charAt(index))
-                index++;
-            else break;
-            if(index==s.length())
-                return 1;
-        }index=0;
-        for (int i = 0; i < m.length&&a-i>=0&&b+i<m.length; i++) {
-            if(m[a-i][b+i]==s.charAt(index))
-                index++;
-            else break;
-            if(index==s.length())
-                return 2;
-        }index=0;
-        for (int i = 0; i < m.length&&a-i>=0&&b-i>=0; i++) {
-            if(m[a-i][b-i]==s.charAt(index))
-                index++;
-            else break;
-            if(index==s.length())
-                return 3;
-        }
-        return -1;
-    }
-}
diff --git a/Proyecto-Nestor b/Proyecto-Nestor
new file mode 160000
index 0000000..9d28e4c
--- /dev/null
+++ b/Proyecto-Nestor
@@ -0,0 +1 @@
+Subproject commit 9d28e4c3133bdcb6c9ae2efca775a1ad0d50f2bb
diff --git a/README.md b/README.md
deleted file mode 100644
index e6364dc..0000000
--- a/README.md
+++ /dev/null
@@ -1,16 +0,0 @@
-                    _ooOoo_
-                   o8888888o
-                   88" . "88
-                   (| -_- |)
-                   O\  =  /O
-                ____/`---'\____
-              .'  \\|     |//  `.
-             /  \\|||  :  |||//  \
-            /  _||||| -:- |||||_  \	
-            |   | \\\  -  /'| |   |
-            | \_|  `\`---'//  |_/ |
-            \  .-\__ `-. -'__/-.  /
-          ___`. .'  /--.--\  `. .'___
-       ."" '<  `.___\_<|>_/___.' _> \"".
-      | | :  `- \`. ;`. _/; .'/ /  .' ; |
-      \  \ `-.   \_\_`. _.'_/_/  -' _.' /
diff --git a/Scanner.java b/Scanner.java
deleted file mode 100644
index 50a0482..0000000
--- a/Scanner.java
+++ /dev/null
@@ -1,59 +0,0 @@
-static class Scanner {
-        BufferedReader br;
-        StringTokenizer st;
-
-        public Scanner() {
-            br = new BufferedReader(new InputStreamReader(System.in));
-        }
-
-        public boolean ready() throws IOException {
-            return br.ready();
-        }
-
-        String nextLine() throws IOException {
-            return br.readLine();
-        }
-
-        String next() {
-            while (st == null || !st.hasMoreTokens()) {
-                try {
-                    st = new StringTokenizer(br.readLine());
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-            return st.nextToken();
-        }
-
-        double nextDouble() {
-            return Double.parseDouble(next());
-        }
-
-        int nextInt() {
-            return Integer.parseInt(next());
-        }
-
-        long nextLong() {
-            return Long.parseLong(next());
-        }
-
-        char Char() throws IOException {
-            return (char) br.read();
-        }
-
-        char nextChar() {
-            return next().charAt(0);
-        }
-
-        public boolean hasNext() {
-            try {
-                while (st == null || !st.hasMoreTokens())
-                    st = new StringTokenizer(br.readLine());
-
-            } catch (Exception e) {
-                return false;
-            }
-            return true;
-        }
-
-    }
